<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>翁恺C语言学习笔记 | fish的学习之旅~</title><meta name="author" content="鱼浩琳"><meta name="copyright" content="鱼浩琳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、数据表达与计算模块1.1 存储单位换算这是最基础的送分题，但容易在“位”和“字节”上翻车。  核心换算：  进率： 计算机中通常使用  () 作为进率。   $1\text{KB} &#x3D; 1024\text{B}$ $1\text{MB} &#x3D; 1024\text{KB}$ $1\text{GB} &#x3D; 1024\text{MB}$ $1\text{TB} &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="翁恺C语言学习笔记">
<meta property="og:url" content="https://yuhaolin-79.github.io/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/index.html">
<meta property="og:site_name" content="fish的学习之旅~">
<meta property="og:description" content="一、数据表达与计算模块1.1 存储单位换算这是最基础的送分题，但容易在“位”和“字节”上翻车。  核心换算：  进率： 计算机中通常使用  () 作为进率。   $1\text{KB} &#x3D; 1024\text{B}$ $1\text{MB} &#x3D; 1024\text{KB}$ $1\text{GB} &#x3D; 1024\text{MB}$ $1\text{TB} &#x3D;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yuhaolin-79.github.io/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg">
<meta property="article:published_time" content="2026-01-23T16:00:00.000Z">
<meta property="article:modified_time" content="2026-01-24T10:42:25.454Z">
<meta property="article:author" content="鱼浩琳">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuhaolin-79.github.io/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "翁恺C语言学习笔记",
  "url": "https://yuhaolin-79.github.io/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/",
  "image": "https://yuhaolin-79.github.io/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg",
  "datePublished": "2026-01-23T16:00:00.000Z",
  "dateModified": "2026-01-24T10:42:25.454Z",
  "author": [
    {
      "@type": "Person",
      "name": "鱼浩琳",
      "url": "https://yuhaolin-79.github.io/true"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuhaolin-79.github.io/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '翁恺C语言学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/transpancy.css"><meta name="generator" content="Hexo 8.1.1"><link rel="stylesheet" href="/css/prism-dracula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="web_bg" style="background-image: url(https://pic2.zhimg.com/v2-90f557e990a0cfbb65da45bb1ffaa812_r.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-box-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-solid fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-solid fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-user"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/001.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">fish的学习之旅~</span></a><a class="nav-page-title" href="/"><span class="site-name">翁恺C语言学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-box-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa-solid fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa-solid fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-user"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">翁恺C语言学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-23T16:00:00.000Z" title="Created 2026-01-24 00:00:00">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T10:42:25.454Z" title="Updated 2026-01-24 18:42:25">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、数据表达与计算模块"><a href="#一、数据表达与计算模块" class="headerlink" title="一、数据表达与计算模块"></a>一、数据表达与计算模块</h1><h2 id="1-1-存储单位换算"><a href="#1-1-存储单位换算" class="headerlink" title="1.1 存储单位换算"></a>1.1 存储单位换算</h2><p>这是最基础的送分题，但容易在“位”和“字节”上翻车。</p>
<ul>
<li><strong>核心换算：</strong> </li>
<li><strong>进率：</strong> 计算机中通常使用  () 作为进率。</li>
</ul>
<ul>
<li>$1\text{KB} &#x3D; 1024\text{B}$</li>
<li>$1\text{MB} &#x3D; 1024\text{KB}$</li>
<li>$1\text{GB} &#x3D; 1024\text{MB}$</li>
<li>$1\text{TB} &#x3D; 1024\text{GB}$</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 考试时看清是 <strong>bit</strong>（位&#x2F;比特）还是 <strong>Byte</strong>（字节）。</p>
</blockquote>
<hr>
<h2 id="1-2-数制转换与对应关系"><a href="#1-2-数制转换与对应关系" class="headerlink" title="1.2 数制转换与对应关系"></a>1.2 数制转换与对应关系</h2><p>需要掌握如何在二进制 (B)、八进制 (O)、十进制 (D) 和十六进制 (H) 之间快速切换。</p>
<ul>
<li><p><strong>十六进制与二进制（重点）：</strong> 记住“<strong>4位合1</strong>”原则。</p>
</li>
<li><p>例： 前四位 <code>1010</code> 是 <code>A</code>，后四位 <code>1100</code> 是 <code>C</code>，结果为 <code>ACH</code>。</p>
</li>
<li><p><strong>十进制与十六进制对应：</strong></p>
</li>
<li><p><code>0-9</code> 对应 <code>0-9</code></p>
</li>
<li><p><code>10-15</code> 对应 <code>A, B, C, D, E, F</code>（必记：<code>A=10</code>, <code>F=15</code>）</p>
</li>
</ul>
<blockquote>
<p><strong>详细讲讲十进制转二进制</strong></p>
</blockquote>
<h3 id="整数部分：除-2-取余法-Divide-by-2"><a href="#整数部分：除-2-取余法-Divide-by-2" class="headerlink" title="整数部分：除 2 取余法 (Divide by 2)"></a>整数部分：除 2 取余法 (Divide by 2)</h3><p>这是最熟悉的，核心逻辑是：<strong>倒序排列</strong>。</p>
<ul>
<li><strong>步骤：</strong> 将十进制整数除以 2，记录余数（0 或 1），得到的商继续除以 2，直到商为 0 为止。</li>
<li><strong>结果：</strong> 将所有余数<strong>从后往前</strong>（从最后一次余数到第一次余数）排列。</li>
</ul>
<p><strong>例题：将十进制 $(13)_{10}$ 转换为二进制</strong></p>
<ol>
<li>$13 \div 2 &#x3D; 6 \dots \dots$余 <strong>1</strong> (LSB，最低位)</li>
<li>$6 \div 2 &#x3D; 3 \dots \dots$余 <strong>0</strong></li>
<li>$3 \div 2 &#x3D; 1 \dots \dots$余 <strong>1</strong></li>
<li>$1 \div 2 &#x3D; 0 \dots \dots$余 <strong>1</strong> (MSB，最高位)</li>
</ol>
<ul>
<li><strong>结果：</strong> $(1101)_2$</li>
</ul>
<hr>
<h3 id="小数部分：乘-2-取整法-Multiply-by-2"><a href="#小数部分：乘-2-取整法-Multiply-by-2" class="headerlink" title="小数部分：乘 2 取整法 (Multiply by 2)"></a>小数部分：乘 2 取整法 (Multiply by 2)</h3><p>这是容易记混的地方，核心逻辑是：<strong>顺序排列</strong>。</p>
<ul>
<li><strong>步骤：</strong> 用十进制小数乘以 2，将乘积的<strong>整数部分</strong>（0 或 1）记录下来，再用剩余的小数部分继续乘以 2，直到小数部分为 0（或达到题目要求的精度）。</li>
<li><strong>结果：</strong> 将记录的整数部分<strong>从前往后</strong>（从第一次到最后一次）排列。</li>
</ul>
<p><strong>例题：将十进制 $(0.625)_{10}$ 转换为二进制</strong></p>
<ol>
<li>$0.625 \times 2 &#x3D; 1.25 \dots \dots$取整 <strong>1</strong></li>
<li>$0.25 \times 2 &#x3D; 0.5 \dots \dots$取整 <strong>0</strong></li>
<li>$0.5 \times 2 &#x3D; 1.0 \dots \dots$取整 <strong>1</strong> (小数部分变0，结束)</li>
</ol>
<ul>
<li><strong>结果：</strong> $(0.101)_2$</li>
</ul>
<hr>
<h3 id="进阶考点：无法精确转换的情况"><a href="#进阶考点：无法精确转换的情况" class="headerlink" title="进阶考点：无法精确转换的情况"></a>进阶考点：无法精确转换的情况</h3><p><strong>这是一个非常高频的考点：</strong> 并不是所有十进制小数都能转换成有限长度的二进制小数。</p>
<ul>
<li><strong>例子：</strong> 将 $0.2$ 转换为二进制。</li>
</ul>
<ol>
<li>$0.2 \times 2 &#x3D; 0.4 \dots 0$</li>
<li>$0.4 \times 2 &#x3D; 0.8 \dots 0$</li>
<li>$0.8 \times 2 &#x3D; 1.6 \dots 1$</li>
<li>$0.6 \times 2 &#x3D; 1.2 \dots 1$</li>
<li>$0.2 \times 2 &#x3D; 0.4 \dots 0$（开始循环了！）</li>
</ol>
<ul>
<li><strong>结论：</strong>  在二进制下是 ****$0.0011\ 0011\dots$无限循环**。</li>
<li><strong>考试坑点：</strong> 题目可能会问“为什么 $0.1 + 0.2$ 在计算机中不等于$0.3$ ？” 答案就是：<strong>因为部分十进制小数在转换为二进制时会产生精度丢失。</strong></li>
</ul>
<hr>
<h3 id="快速转换技巧（凑数法）"><a href="#快速转换技巧（凑数法）" class="headerlink" title="快速转换技巧（凑数法）"></a>快速转换技巧（凑数法）</h3><p>对于比较小的数，考试时为了省时间，可以用“权值相加”的方法。<br>记住 2 的幂次方：<code>128, 64, 32, 16, 8, 4, 2, 1 | 0.5, 0.25, 0.125, 0.0625</code></p>
<ul>
<li><strong>例子：</strong> $10.75$</li>
<li>$10 &#x3D; 8 + 2 \rightarrow (1010)_2$</li>
<li>$0.75 &#x3D; 0.5 + 0.25 \rightarrow (0.11)_2$</li>
<li><strong>合并：</strong> $(1010.11)_2$</li>
</ul>
<hr>
<h2 id="1-3-详解：原码、反码、补码"><a href="#1-3-详解：原码、反码、补码" class="headerlink" title="1.3 详解：原码、反码、补码"></a>1.3 详解：原码、反码、补码</h2><p>这部分是重灾区，记住一个铁律：<strong>正数的原、反、补三码合一（完全一样）；只有负数才需要复杂的转换。</strong></p>
<h4 id="1-定义与转换流程（以8位字长为例）"><a href="#1-定义与转换流程（以8位字长为例）" class="headerlink" title="1. 定义与转换流程（以8位字长为例）"></a>1. 定义与转换流程（以8位字长为例）</h4><ul>
<li><strong>原码：</strong> 最高位为符号位（0正1负），其余位表示数值。</li>
<li><strong>反码：</strong> 符号位不变，数值位按位取反（0变1, 1变0）。</li>
<li><strong>补码：</strong> 反码的基础上，在最低位 +1。</li>
</ul>
<h4 id="2-经典例子对比"><a href="#2-经典例子对比" class="headerlink" title="2. 经典例子对比"></a>2. 经典例子对比</h4><table>
<thead>
<tr>
<th>十进制数</th>
<th><strong>原码</strong> (符号+数值)</th>
<th><strong>反码</strong> (符号不变，数值取反)</th>
<th><strong>补码</strong> (反码+1)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>+5</strong></td>
<td><code>0000 0101</code></td>
<td><code>0000 0101</code></td>
<td><code>0000 0101</code> (三码合一)</td>
</tr>
<tr>
<td><strong>-5</strong></td>
<td><code>1000 0101</code></td>
<td><code>1111 1010</code></td>
<td><code>1111 1011</code></td>
</tr>
<tr>
<td><strong>+0</strong></td>
<td><code>0000 0000</code></td>
<td><code>0000 0000</code></td>
<td><code>0000 0000</code></td>
</tr>
<tr>
<td><strong>-0</strong></td>
<td><code>1000 0000</code></td>
<td><code>1111 1111</code></td>
<td><strong><code>0000 0000</code></strong> (唯一性!)</td>
</tr>
</tbody></table>
<h4 id="3-补码求和运算"><a href="#3-补码求和运算" class="headerlink" title="3. 补码求和运算"></a>3. 补码求和运算</h4><p><strong>公式：</strong> $[A+B]_补 &#x3D; [A]_补 + [B]_补$<br><strong>例题：</strong> 计算 $10 - 5$（即 $10 + (-5)$）</p>
<ol>
<li>$[+10]_补 &#x3D; 0000\ 1010$</li>
<li>$[-5]_补 &#x3D; 1111\ 1011$</li>
<li><strong>相加：</strong></li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0000 1010 (+10补)</span><br><span class="line">+ 1111 1011 (-5补)</span><br><span class="line">------------------</span><br><span class="line"> 10000 0101 (最高位进位舍弃) -&gt; 结果为 0000 0101 (即 +5)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-4-汉字编码（国标码、机内码、字形码）"><a href="#1-4-汉字编码（国标码、机内码、字形码）" class="headerlink" title="1.4 汉字编码（国标码、机内码、字形码）"></a>1.4 汉字编码（国标码、机内码、字形码）</h2><p>考试常考这几种码之间的<strong>换算关系</strong>。</p>
<h4 id="1-汉字的“三码”关系"><a href="#1-汉字的“三码”关系" class="headerlink" title="1. 汉字的“三码”关系"></a>1. 汉字的“三码”关系</h4><ul>
<li><strong>区位码：</strong> 国家标准局定义的坐标，由“区码”和“位码”组成。为了方便看，通常是十进制。</li>
<li><strong>国标码 (交换码)：</strong> 汉字信息交换的标准。</li>
<li><strong>机内码 (内码)：</strong> 计算机内部存储汉字的代码。<strong>特点：</strong> 两个字节的最高位都是 1（为了区别于 ASCII 码）。</li>
</ul>
<h4 id="2-核心换算公式（必记！）"><a href="#2-核心换算公式（必记！）" class="headerlink" title="2. 核心换算公式（必记！）"></a>2. 核心换算公式（必记！）</h4><ol>
<li><strong>区位码 $\rightarrow$ 国标码：</strong></li>
</ol>
<ul>
<li>(区码, 位码) 分别转换成十六进制，再加上 <code>2020H</code>。</li>
</ul>
<ol start="2">
<li><strong>国标码 $\rightarrow$ 机内码：</strong></li>
</ol>
<ul>
<li>国标码直接加上 <code>8080H</code>。</li>
</ul>
<ol start="3">
<li><strong>区位码 $\rightarrow$ 机内码（终极公式）：</strong></li>
</ol>
<ul>
<li><strong>机内码 &#x3D; 区位码(十六进制) + <code>A0A0H</code>。</strong></li>
</ul>
<h4 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h4><p>假设某汉字区位码是 <code>1601</code>：</p>
<ul>
<li>十六进制换算：<code>16</code> 是 <code>10H</code>，<code>01</code> 是 <code>01H</code>  <code>1001H</code>。</li>
<li><strong>国标码：</strong> <code>1001H + 2020H = 3021H</code>。</li>
<li><strong>机内码：</strong> <code>3021H + 8080H = B0A1H</code>。</li>
</ul>
<h4 id="4-字形码（字库码）"><a href="#4-字形码（字库码）" class="headerlink" title="4. 字形码（字库码）"></a>4. 字形码（字库码）</h4><ul>
<li><strong>作用：</strong> 用于显示和打印，由点阵组成（如 $16 \times 16$, $24 \times 24$）。</li>
<li><strong>计算存储空间：</strong></li>
<li>例：$16 \times 16$ 点阵汉字占用多少字节？</li>
<li>$16 \times 16 &#x3D; 256$个点（bit）。</li>
<li>换算成字节：$256 \div 8 &#x3D; 32$ 字节。</li>
</ul>
<hr>
<h3 id="1-5-浮点数的“阶码”与“尾数”"><a href="#1-5-浮点数的“阶码”与“尾数”" class="headerlink" title="1.5 浮点数的“阶码”与“尾数”"></a>1.5 浮点数的“阶码”与“尾数”</h3><ul>
<li><strong>阶码 (Exponent)：</strong> 指数部分。决定了浮点数的<strong>范围大小</strong>。如果阶码位数增加，能表示的数值范围就更大。</li>
<li><strong>尾数 (Mantissa)：</strong> 有效数字部分。决定了浮点数的<strong>精度</strong>。如果尾数位数增加，计算结果就更精确。</li>
<li><strong>溢出：</strong></li>
<li>上溢：计算结果绝对值太大，超过阶码能表示的最大范围。</li>
<li>下溢：计算结果太接近 0（太小），通常当作 0 处理。</li>
</ul>
<hr>
<h3 id="1-6-字符编码大小比较"><a href="#1-6-字符编码大小比较" class="headerlink" title="1.6 字符编码大小比较"></a>1.6 字符编码大小比较</h3><p>考试如果考排序，直接背这个顺序：<br><strong>空格 (32) &lt; 数字 (0-9) &lt; 大写字母 (A-Z) &lt; 小写字母 (a-z)</strong></p>
<ul>
<li><code>&#39;A&#39;</code> 是 <code>65</code> (十六进制 <code>41H</code>)</li>
<li><code>&#39;a&#39;</code> 是 <code>97</code> (十六进制 <code>61H</code>)</li>
<li><strong>注意：</strong> 汉字的机内码最高位是 1，所以<strong>汉字内码 &gt; ASCII 码</strong>。</li>
</ul>
<hr>
<h1 id="二、计算机体系结构"><a href="#二、计算机体系结构" class="headerlink" title="二、计算机体系结构"></a>二、计算机体系结构</h1><h2 id="2-1-存储层次结构（Memory-Hierarchy）"><a href="#2-1-存储层次结构（Memory-Hierarchy）" class="headerlink" title="2.1 存储层次结构（Memory Hierarchy）"></a>2.1 存储层次结构（Memory Hierarchy）</h2><p>计算机并不是只用一种内存，而是采用“金字塔”式的层次结构。<br>![[Pasted image 20260117160646.png]]</p>
<ul>
<li><strong>层次逻辑：</strong> 每一层都充当其下一层的 <strong>Cache（缓存）</strong>。例如，L1 缓存 L2 的内容，L2 缓存 L3 的内容，而主存（DRAM）缓存磁盘（Disk）的内容。</li>
<li><strong>金字塔规律：</strong> 越往上，<strong>速度越快、成本越高、容量越小</strong>；越往下，<strong>速度越慢、成本越低、容量越大</strong>。</li>
<li><strong>介质差异：</strong> 注意图中的标注，L1-L3 Cache 使用的是 <strong>SRAM</strong>（静态随机存储器），而主内存使用的是 <strong>DRAM</strong>（动态随机存储器）。SRAM 比 DRAM 快得多，但也贵得多。</li>
<li></li>
</ul>
<h3 id="1-存储层次的目标"><a href="#1-存储层次的目标" class="headerlink" title="1. 存储层次的目标"></a>1. 存储层次的目标</h3><ul>
<li><strong>核心目标：</strong> 解决<strong>主存速度慢</strong>、<strong>容量小</strong>与 <strong>CPU 高速度</strong>之间的矛盾。</li>
<li><strong>最终效果：</strong> 使得整个存储系统看起来既有 Cache 的<strong>高速度</strong>，又有硬盘的<strong>大容量</strong>，且成本可控。</li>
</ul>
<h3 id="2-Cache（高速缓冲存储器）"><a href="#2-Cache（高速缓冲存储器）" class="headerlink" title="2. Cache（高速缓冲存储器）"></a>2. Cache（高速缓冲存储器）</h3><h4 id="1-高速缓存（Cache）的分类"><a href="#1-高速缓存（Cache）的分类" class="headerlink" title="(1) 高速缓存（Cache）的分类"></a>(1) 高速缓存（Cache）的分类</h4><p>高速缓存是CPU与内存之间的“高速临时存储区”，按与CPU的距离分为三级：</p>
<ul>
<li><strong>L1 Cache（一级缓存）</strong>：距离CPU最近，速度最快、容量最小（通常几KB到几十KB），直接集成在CPU核心内；</li>
<li><strong>L2 Cache（二级缓存）</strong>：速度、容量介于L1与L3之间（通常几十KB到几MB），部分CPU将其集成在核心内；</li>
<li><strong>L3 Cache（三级缓存）</strong>：距离CPU最远，容量最大（通常几MB到几十MB），多为CPU核心共享的缓存。</li>
</ul>
<h4 id="2-CPU、Cache、内存、外存的层级关系"><a href="#2-CPU、Cache、内存、外存的层级关系" class="headerlink" title="(2) CPU、Cache、内存、外存的层级关系"></a>(2) CPU、Cache、内存、外存的层级关系</h4><p>这四者构成了“速度从快到慢、容量从小到大”的存储层级，数据访问遵循“就近原则”：</p>
<ol>
<li>CPU优先读取<strong>Cache</strong>中的数据（速度最快）；</li>
<li>若Cache中无所需数据，再读取<strong>内存</strong>（速度次之）；</li>
<li>若内存中也无数据，最后读取<strong>外存</strong>（如硬盘、U盘，速度最慢但容量最大）。</li>
</ol>
<h4 id="3-核心作用"><a href="#3-核心作用" class="headerlink" title="(3) 核心作用"></a>(3) 核心作用</h4><p>Cache的存在是为了<strong>缓解CPU与内存之间的速度差</strong>：CPU运算速度远快于内存读取速度，通过将CPU近期常用的数据暂存到Cache中，可减少CPU等待内存数据的时间，提升整体运行效率。</p>
<ul>
<li><strong>三级结构（L1&#x2F;L2&#x2F;L3）的目的：</strong> 进一步缓冲。L1 最快、容量最小且紧挨着核心；L3 相对慢一些但容量大，通常由多个核心共享。</li>
<li><strong>速度对比：</strong> <strong>寄存器 &gt; Cache &gt; 内存 (RAM) &gt; 硬盘</strong>。<ul>
<li>Cache 的存取速度比内存快 <strong>10 到 100 倍</strong>。</li>
</ul>
</li>
<li><strong>工作原理：</strong> 基于<strong>程序局部性原理</strong>（时间局部性和空间局部性）。CPU 访问数据时先找 Cache，找不到再去内存。</li>
</ul>
<hr>
<h2 id="2-2-CPU-组成与功能"><a href="#2-2-CPU-组成与功能" class="headerlink" title="2.2 CPU 组成与功能"></a>2.2 CPU 组成与功能</h2><p>CPU 是大脑，主要由<strong>运算器</strong>、<strong>控制器</strong>和<strong>寄存器</strong>组成。</p>
<h3 id="1-运算器（Arithmetic-Logic-Unit-ALU）"><a href="#1-运算器（Arithmetic-Logic-Unit-ALU）" class="headerlink" title="1. 运算器（Arithmetic Logic Unit, ALU）"></a>1. 运算器（Arithmetic Logic Unit, ALU）</h3><ul>
<li><strong>核心部件：</strong> <strong>ALU（算术逻辑单元）</strong>。</li>
<li><strong>ALU 的作用：</strong> 负责执行所有的<strong>算术运算</strong>（加减乘除）和<strong>逻辑运算</strong>（与、或、非、异或）。</li>
<li><strong>辅助部件：</strong> 累加器 (AC)、状态寄存器 (PSW) 等。</li>
<li><strong>考点提示：</strong> ALU 的输入通常来自寄存器（GPRs），输出结果要么写回寄存器，要么作为地址去访问内存。</li>
</ul>
<h3 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><ul>
<li>负责“发号施令”，决定什么时候取指令，什么时候分析指令。</li>
</ul>
<h3 id="3-CPU-直接读写的存储介质"><a href="#3-CPU-直接读写的存储介质" class="headerlink" title="3. CPU 直接读写的存储介质"></a>3. CPU 直接读写的存储介质</h3><ul>
<li><strong>重点考点：</strong> CPU <strong>只能</strong>直接访问<strong>寄存器、Cache 和主存储器（内存）</strong>。</li>
<li><strong>注意：</strong> CPU <strong>不能直接访问</strong>外存（如硬盘、U 盘、光盘）。外存的数据必须先加载到内存，才能被 CPU 处理。</li>
</ul>
<hr>
<h2 id="2-3-指令执行（Instruction-Execution）"><a href="#2-3-指令执行（Instruction-Execution）" class="headerlink" title="2.3 指令执行（Instruction Execution）"></a>2.3 指令执行（Instruction Execution）</h2><h3 id="1-计算机直接执行的代码类型"><a href="#1-计算机直接执行的代码类型" class="headerlink" title="1. 计算机直接执行的代码类型"></a>1. 计算机直接执行的代码类型</h3><ul>
<li><strong>机器语言：</strong> 只有<strong>二进制代码</strong>（0 和 1）是计算机唯一能直接识别并执行的语言。</li>
<li><em>注意：汇编语言和高级语言（C++, Python）都必须翻译成机器语言才能运行。</em></li>
</ul>
<h3 id="2-指令周期顺序（必考步骤）"><a href="#2-指令周期顺序（必考步骤）" class="headerlink" title="2. 指令周期顺序（必考步骤）"></a>2. 指令周期顺序（必考步骤）</h3><p>一个指令的完整执行过程通常分为以下阶段：</p>
<ol>
<li><strong>取指令 (Fetch)：</strong> 从内存中取出指令送入指令寄存器。</li>
<li><strong>分析指令&#x2F;译码 (Decode)：</strong> 翻译这行代码要做什么（是加法还是存数）。</li>
<li><strong>执行指令 (Execute)：</strong> 发出控制信号，操作 ALU 或访问数据。</li>
<li><strong>写回 (Write Back)：</strong> 将结果存回寄存器或内存。</li>
</ol>
<blockquote>
<p><em><strong>下面给出示例</strong></em><br>![[Pasted image 20260117161016.png]]</p>
</blockquote>
<p>这张图展示了高级语言（如 C 语言）变成计算机可执行代码的 <strong>四个必经阶段</strong>：</p>
<ol>
<li><strong>预处理 (Pre-processor)：</strong> 处理 <code>#include</code> 和宏定义，生成 <code>.i</code> 文件。</li>
<li><strong>编译 (Compiler)：</strong> 将修改后的源码翻译成 <strong>汇编程序 (<code>.s</code>)</strong>。这是最核心的一步。</li>
<li><strong>汇编 (Assembler)：</strong> 将汇编指令翻译成机器能够识别的 <strong>二进制目标程序 (<code>.o</code>)</strong>。此时它已经是二进制了，但还不能直接运行。</li>
<li><strong>链接 (Linker)：</strong> 将你的 <code>.o</code> 文件和系统库文件（如 <code>printf.o</code>）合并，生成最终的 <strong>可执行目标文件</strong>。</li>
</ol>
<h3 id="3-指令流水线技术-Pipelining"><a href="#3-指令流水线技术-Pipelining" class="headerlink" title="3. 指令流水线技术 (Pipelining)"></a>3. 指令流水线技术 (Pipelining)</h3><ul>
<li><strong>定义：</strong> 像工厂流水线一样，让多个指令的不同阶段<strong>重叠执行</strong>。</li>
<li><strong>目的：</strong> 为了<strong>提高 CPU 的执行效率&#x2F;吞吐量</strong>，而不是缩短单个指令的执行时间。</li>
<li><strong>例子：</strong> 取第 2 条指令的同时，CPU 正在分析第 1 条指令。<br>![[Pasted image 20260117161210.png]]</li>
<li><strong>并行原理：</strong> 它并不增加计算资源，而是通过“重叠执行”来提高利用率。</li>
<li><strong>五级流水线（经典）：</strong><ol>
<li><strong>Fetch (取指)</strong>：从指令存储器拿代码。</li>
<li><strong>Decode (译码)</strong>：分析这行代码要干嘛，读取寄存器。</li>
<li><strong>Execute (执行)</strong>：调用 <strong>ALU</strong> 进行计算。</li>
<li><strong>Memory (访存)</strong>：如果需要，去数据内存读写数据。</li>
<li><strong>Write-back (写回)</strong>：把结果写回寄存器。</li>
</ol>
</li>
<li><strong>性能提升：</strong><ul>
<li><strong>超流水线 (Super-pipelining)：</strong> 将流水线分得更细（如 Pentium 4 的 20 段）。段数越多，时钟频率就能跑得越高。</li>
<li><strong>超标量 (Superscalar)：</strong> 在硬件上提供多条流水线（如图 2 提到的 U 流水线和 V 流水线）。这意味着在同一个时刻，CPU 可以 <strong>同时执行两条或多条指令</strong>，前提是它们之间没有数据依赖。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="⚠️-总结避坑："><a href="#⚠️-总结避坑：" class="headerlink" title="⚠️ 总结避坑："></a>⚠️ 总结避坑：</h3><ul>
<li><strong>问：</strong> 流水线技术能缩短单条指令的执行时间吗？</li>
<li><strong>答：</strong> <strong>不能。</strong> 实际上，由于增加了流水线寄存器，单条指令的延迟反而可能略微增加。但它大幅提高了单位时间内完成指令的数量（即 <strong>吞吐量</strong>）。</li>
</ul>
<ol>
<li><strong>Cache 的单位：</strong> Cache 空间很小，通常以 <strong>KB 或 MB</strong> 为单位，而内存是以 <strong>GB</strong> 为单位。</li>
<li><strong>运算器 vs 控制器：</strong> 考试常问“ALU 属于什么？”，记得它是<strong>运算器</strong>的核心。</li>
<li><strong>直接访问：</strong> 记住这句话——“CPU 和硬盘不熟，它们中间隔着内存”。</li>
</ol>
<hr>
<h1 id="三、操作系统模块"><a href="#三、操作系统模块" class="headerlink" title="三、操作系统模块"></a>三、操作系统模块</h1><h3 id="3-1-进程与线程（Process-vs-Thread）"><a href="#3-1-进程与线程（Process-vs-Thread）" class="headerlink" title="3.1 进程与线程（Process vs. Thread）"></a>3.1 进程与线程（Process vs. Thread）</h3><p>这是操作系统最核心的概念，考试常考两者的区别与联系。</p>
<h4 id="1-进程（Process）"><a href="#1-进程（Process）" class="headerlink" title="1. 进程（Process）"></a>1. 进程（Process）</h4><ul>
<li><strong>定义</strong>：进程是程序的一次执行过程，是系统进行<strong>资源分配和保护的基本单位</strong>。</li>
<li><strong>特点</strong>：每个进程都有自己独立的地址空间（内存）、数据栈和资源句柄。</li>
</ul>
<h4 id="2-线程（Thread）"><a href="#2-线程（Thread）" class="headerlink" title="2. 线程（Thread）"></a>2. 线程（Thread）</h4><ul>
<li><strong>定义</strong>：线程是进程内的一个执行单元，是<strong>系统独立调度和分派的基本单位</strong>（核心调度单位）。</li>
<li><strong>线程的特点</strong>：</li>
<li><strong>轻量级</strong>：线程的创建和销毁开销比进程小得多。</li>
<li><strong>共享性</strong>：同一进程下的多个线程<strong>共享该进程的资源</strong>（如内存地址空间、全局变量、打开的文件），但拥有自己独立的栈和程序计数器。</li>
</ul>
<h4 id="3-区别与联系（高频考点）"><a href="#3-区别与联系（高频考点）" class="headerlink" title="3. 区别与联系（高频考点）"></a>3. 区别与联系（高频考点）</h4><ul>
<li><strong>调度</strong>：线程是独立调度的基本单位，进程是拥有资源的基本单位。</li>
<li><strong>并发性</strong>：进程间并发执行，同一进程内的多个线程也可以并发执行。</li>
<li><strong>拥有资源</strong>：进程拥有完整的资源；线程基本上不拥有系统资源，但可以访问所属进程的资源。</li>
<li><strong>系统开销</strong>：进程切换涉及整个 CPU 环境的保存和恢复（开销大）；线程切换只需保存和恢复少量寄存器内容（开销小）。</li>
<li><strong>健壮性</strong>：一个进程崩溃不会影响其他进程；但一个线程崩溃，整个进程（及其所有线程）通常都会死掉。</li>
</ul>
<hr>
<h3 id="3-2-资源管理"><a href="#3-2-资源管理" class="headerlink" title="3.2 资源管理"></a>3.2 资源管理</h3><p>操作系统本质上是一个<strong>资源管理者</strong>。</p>
<h4 id="1-操作系统核心功能"><a href="#1-操作系统核心功能" class="headerlink" title="1. 操作系统核心功能"></a>1. 操作系统核心功能</h4><p>操作系统主要负责四大管理任务：</p>
<ol>
<li><strong>处理器管理</strong>（进程调度）。</li>
<li><strong>存储器管理</strong>（内存分配、回收、虚拟内存）。</li>
<li><strong>设备管理</strong>（I&#x2F;O 设备驱动、分配）。</li>
<li><strong>文件管理</strong>（数据的组织、存储、访问控制）。</li>
</ol>
<h4 id="2-设备管理目标"><a href="#2-设备管理目标" class="headerlink" title="2. 设备管理目标"></a>2. 设备管理目标</h4><ul>
<li><strong>主要目标</strong>：提高设备的利用率（让设备尽可能忙起来）和方便用户使用（用户不需要了解硬件底层细节，只需调用统一接口）。</li>
</ul>
<h4 id="3-时间片（Time-Slice）定义"><a href="#3-时间片（Time-Slice）定义" class="headerlink" title="3. 时间片（Time Slice）定义"></a>3. 时间片（Time Slice）定义</h4><ul>
<li><strong>定义</strong>：在分时操作系统中，系统分配给每个进程轮流使用 CPU 的<strong>一段固定时间长度</strong>。</li>
<li><strong>意义</strong>：通过快速切换，给用户的感觉是多个程序在“同时”运行。</li>
</ul>
<hr>
<h3 id="三、-进程调度与上下文切换"><a href="#三、-进程调度与上下文切换" class="headerlink" title="三、 进程调度与上下文切换"></a>三、 进程调度与上下文切换</h3><h4 id="1-上下文切换（Context-Switch）的定义"><a href="#1-上下文切换（Context-Switch）的定义" class="headerlink" title="1. 上下文切换（Context Switch）的定义"></a>1. 上下文切换（Context Switch）的定义</h4><p>当操作系统决定让正在运行的进程 A 暂停，转而运行进程 B 时，必须完成以下动作：</p>
<ul>
<li><strong>保存</strong>：将进程 A 的当前状态（包括 CPU 寄存器、程序计数器、内存管理信息等，即“上下文”）保存到内存的 PCB（进程控制块）中。</li>
<li><strong>恢复</strong>：从内存中读取进程 B 之前保存的“上下文”，加载到 CPU 寄存器中，使 B 恢复运行。</li>
<li><strong>考点</strong>：上下文切换是<strong>有开销的</strong>，切换过于频繁会降低系统有效工作时间。</li>
</ul>
<h4 id="2-进程的三种基本状态（补充考点）"><a href="#2-进程的三种基本状态（补充考点）" class="headerlink" title="2. 进程的三种基本状态（补充考点）"></a>2. 进程的三种基本状态（补充考点）</h4><p>考试常画图考这三者的转换：</p>
<ol>
<li><strong>就绪态 (Ready)</strong>：具备运行条件，等待分配 CPU。</li>
<li><strong>运行态 (Running)</strong>：正在占用 CPU 运行。</li>
<li><strong>等待&#x2F;阻塞态 (Blocked&#x2F;Waiting)</strong>：因等待某事件（如 I&#x2F;O 操作、等待信号量）而暂停运行。</li>
</ol>
<hr>
<h3 id="💡-避坑小贴士："><a href="#💡-避坑小贴士：" class="headerlink" title="💡 避坑小贴士："></a>💡 避坑小贴士：</h3><ul>
<li><strong>易错题</strong>：问“计算机中资源分配的最小单位是什么？” 选 <strong>进程</strong>。</li>
<li><strong>易错题</strong>：问“CPU 调度的基本单位是什么？” 选 <strong>线程</strong>。</li>
<li><strong>逻辑题</strong>：线程之间共享内存，所以它们通信很快，但需要注意“同步”问题（防止大家同时改同一个变量）。</li>
</ul>
<hr>
<h1 id="四、数据库模块"><a href="#四、数据库模块" class="headerlink" title="四、数据库模块"></a>四、数据库模块</h1><h2 id="4-1-关系模型（Relational-Model）"><a href="#4-1-关系模型（Relational-Model）" class="headerlink" title="4.1 关系模型（Relational Model）"></a>4.1 关系模型（Relational Model）</h2><p>数据库的核心是“表”，而在学术上我们称之为“关系”。</p>
<ul>
<li><p><strong>元组的唯一性要求：</strong></p>
</li>
<li><p>在关系模型中，表中的每一行被称为一个<strong>元组（Tuple）</strong>。</p>
</li>
<li><p><strong>核心要求：</strong> 关系中的元组必须是<strong>唯一的</strong>，不允许出现完全重复的行。</p>
</li>
<li><p><strong>实现方式：</strong> 通过定义**主键（Primary Key）**来保证唯一性，主键的值不能为空且不能重复。</p>
</li>
<li><p><strong>属性（Attribute）：</strong> 表中的列。</p>
</li>
<li><p><strong>域（Domain）：</strong> 属性的取值范围（例如“性别”属性的域是 {男, 女}）。</p>
</li>
</ul>
<hr>
<h2 id="4-2-SQL-语言基础"><a href="#4-2-SQL-语言基础" class="headerlink" title="4.2 SQL 语言基础"></a>4.2 SQL 语言基础</h2><p>SQL 是结构化查询语言，是操作数据库的标准。</p>
<h3 id="1-查询语句类型（DQL-DML-DDL-DCL）"><a href="#1-查询语句类型（DQL-DML-DDL-DCL）" class="headerlink" title="1. 查询语句类型（DQL&#x2F;DML&#x2F;DDL&#x2F;DCL）"></a>1. 查询语句类型（DQL&#x2F;DML&#x2F;DDL&#x2F;DCL）</h3><p>考试常考这几类操作的区别：</p>
<ul>
<li><strong>数据查询 (DQL)：</strong> <code>SELECT</code>（最常用）。</li>
<li><strong>数据操纵 (DML)：</strong> <code>INSERT</code> (插入), <code>UPDATE</code> (更新), <code>DELETE</code> (删除)。—— <em>针对数据本身</em>。</li>
<li><strong>数据定义 (DDL)：</strong> <code>CREATE</code> (创建表), <code>DROP</code> (删除表), <code>ALTER</code> (修改表结构)。—— <em>针对表的结构</em>。</li>
<li><strong>数据控制 (DCL)：</strong> <code>GRANT</code> (授权), <code>REVOKE</code> (撤销权限)。—— <em>针对安全权限</em>。</li>
</ul>
<h3 id="2-SELECT-的作用"><a href="#2-SELECT-的作用" class="headerlink" title="2. SELECT * 的作用"></a>2. <code>SELECT *</code> 的作用</h3><ul>
<li><strong>含义：</strong> <code>*</code> 是通配符，代表“所有列”。</li>
<li><strong>作用：</strong> 从指定的表中检索出<strong>所有字段</strong>的数据。</li>
<li><strong>例句：</strong> <code>SELECT * FROM Students;</code> 会列出学生表里所有学生的所有信息（姓名、学号、年龄等）。</li>
</ul>
<h3 id="3-SQL-的定义与约束"><a href="#3-SQL-的定义与约束" class="headerlink" title="3. SQL 的定义与约束"></a>3. <strong>SQL 的定义与约束</strong></h3><ul>
<li><strong>主码 (Primary Key)</strong>：唯一标识元组。如 <code>PRIMARY KEY (Sno, Cno)</code> 表示两个属性共同构成主键（复合主键）。</li>
<li><strong>外码 (Foreign Key)</strong>：表之间的逻辑连接。如 <code>FOREIGN KEY (Sno) REFERENCES S(Sno)</code>。</li>
<li><strong>唯一索引 (Unique Index)</strong>：通过 <code>CREATE UNIQUE INDEX</code> 提高查询效率并保证数据不重复。</li>
</ul>
<hr>
<h2 id="4-3-DBMS-功能（数据库管理系统）"><a href="#4-3-DBMS-功能（数据库管理系统）" class="headerlink" title="4.3 DBMS 功能（数据库管理系统）"></a>4.3 DBMS 功能（数据库管理系统）</h2><p>DBMS 是位于用户和操作系统之间的支撑软件（如 MySQL, Oracle, SQL Server）。</p>
<h3 id="1-数据库系统的构成"><a href="#1-数据库系统的构成" class="headerlink" title="1. 数据库系统的构成"></a>1. <strong>数据库系统的构成</strong></h3><ul>
<li><strong>DB (Database)</strong>：数据的集合。</li>
<li><strong>DBMS (Database Management System)</strong>：管理数据库的<strong>系统软件</strong>（处于核心地位，连接硬件、操作系统和应用）。</li>
<li><strong>DBA (Database Administrator)</strong>：数据库管理员（负责设计、安全和维护的人）。</li>
</ul>
<h3 id="2-DBMS-的主要功能"><a href="#2-DBMS-的主要功能" class="headerlink" title="2. DBMS 的主要功能"></a>2. DBMS 的主要功能</h3><ul>
<li><strong>数据定义功能 (DDL)：</strong> 定义数据库的结构。</li>
<li><strong>数据操纵功能 (DML)：</strong> 对数据进行增、删、改、查。</li>
<li><strong>数据库的事务管理和运行管理：</strong> 保证数据的安全性、完整性以及多用户并发时的正确性。</li>
<li><strong>数据库的建立和维护：</strong> 数据的导入导出、恢复和备份。</li>
</ul>
<h3 id="3-数据操纵-vs-数据控制（易混淆点）"><a href="#3-数据操纵-vs-数据控制（易混淆点）" class="headerlink" title="3. 数据操纵 vs 数据控制（易混淆点）"></a>3. 数据操纵 vs 数据控制（易混淆点）</h3><table>
<thead>
<tr>
<th>功能名称</th>
<th>英文</th>
<th>核心关注点</th>
<th>典型操作</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据操纵</strong></td>
<td>DML</td>
<td><strong>内容</strong>：对表里的数据进行处理</td>
<td>增加、修改、删除记录</td>
</tr>
<tr>
<td><strong>数据控制</strong></td>
<td>DCL</td>
<td><strong>安全</strong>：谁能看，谁能改</td>
<td>权限授予、用户登录管理</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-4-补充考点：关系运算"><a href="#4-4-补充考点：关系运算" class="headerlink" title="4.4 补充考点：关系运算"></a>4.4 补充考点：关系运算</h2><p>但“关系代数”经常伴随数据库出现，简单记一下：</p>
<ul>
<li><strong>投影 (Projection)：</strong> 选出特定的<strong>列</strong>（比如只要姓名）。</li>
<li><strong>选择 (Selection)：</strong> 选出满足条件的<strong>行</strong>（比如只要年龄 &gt; 20 的）。</li>
<li><strong>连接 (Join)：</strong> 把两张表拼在一起。</li>
</ul>
<hr>
<h3 id="4-5-数据库模块综合大题"><a href="#4-5-数据库模块综合大题" class="headerlink" title="4.5 数据库模块综合大题"></a>4.5 数据库模块综合大题</h3><p><strong>题目背景：</strong> 某大学需要管理学生选课信息，现有三张表：</p>
<ol>
<li>学生表 <strong>S</strong> (学号 <code>Sno</code>, 姓名 <code>Sname</code>, 性别 <code>Sex</code>)</li>
<li>课程表 <strong>C</strong> (课程号 <code>Cno</code>, 课程名 <code>Cname</code>, 学分 <code>Credit</code>)</li>
<li>选课表 <strong>SC</strong> (学号 <code>Sno</code>, 课程号 <code>Cno</code>, 成绩 <code>Grade</code>)</li>
</ol>
<hr>
<h4 id="任务-1：数据定义-DDL"><a href="#任务-1：数据定义-DDL" class="headerlink" title="任务 1：数据定义 (DDL)"></a><strong>任务 1：数据定义 (DDL)</strong></h4><p>请写出创建“选课表 <strong>SC</strong>”的 SQL 语句，要求：<code>Sno</code> 和 <code>Cno</code> 共同作为主码，且分别作为外码引用 S 表和 C 表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> SC (</span><br><span class="line">    Sno <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    Cno <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">    Grade <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (Sno, Cno),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (Sno) <span class="keyword">REFERENCES</span> S(Sno),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (Cno) <span class="keyword">REFERENCES</span> C(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="任务-2：索引创建"><a href="#任务-2：索引创建" class="headerlink" title="任务 2：索引创建"></a><strong>任务 2：索引创建</strong></h4><p>为了加快查询速度，请为学生表 <strong>S</strong> 的学号 <code>Sno</code> 创建一个唯一的升序索引，索引名为 <code>Stusno</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Stusno <span class="keyword">ON</span> S(Sno <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure>
<h4 id="任务-3：数据查询-DQL-核心"><a href="#任务-3：数据查询-DQL-核心" class="headerlink" title="任务 3：数据查询 (DQL - 核心)"></a><strong>任务 3：数据查询 (DQL - 核心)</strong></h4><p>查询选修了课程名为“计算机导论”且成绩大于 90 分的学生学号和姓名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.Sno, S.Sname</span><br><span class="line"><span class="keyword">FROM</span> S, C, SC</span><br><span class="line"><span class="keyword">WHERE</span> C.Cname <span class="operator">=</span> <span class="string">&#x27;计算机导论&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> S.Sno <span class="operator">=</span> SC.Sno </span><br><span class="line">  <span class="keyword">AND</span> C.Cno <span class="operator">=</span> SC.Cno </span><br><span class="line">  <span class="keyword">AND</span> SC.Grade <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>注意：这里涉及了三表连接查询，必须在 WHERE 中写清连接条件 <code>S.Sno = SC.Sno</code> 等，否则会出现笛卡尔积错误。</em></p>
</blockquote>
<h4 id="任务-4：数据修改与删除-DML"><a href="#任务-4：数据修改与删除-DML" class="headerlink" title="任务 4：数据修改与删除 (DML)"></a><strong>任务 4：数据修改与删除 (DML)</strong></h4><ol>
<li>将学号为 ‘001’ 的学生的“计算机导论”（课程号 ‘C01’）成绩修改为 100 分。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC <span class="keyword">SET</span> Grade <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;001&#x27;</span> <span class="keyword">AND</span> Cno <span class="operator">=</span> <span class="string">&#x27;C01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>删除所有成绩小于 60 分的选课记录。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<h3 id="💡-避坑小贴士：-1"><a href="#💡-避坑小贴士：-1" class="headerlink" title="💡 避坑小贴士："></a>💡 避坑小贴士：</h3><ul>
<li><strong>区分 <code>DROP</code> 和 <code>DELETE</code>：</strong> <code>DROP TABLE</code> 是把整个表（包括结构和数据）都扔了；<code>DELETE</code> 只是把表里的数据删了，表的“壳子”还在。</li>
<li><strong>元组顺序：</strong> 在关系模型中，元组的顺序并不重要，交换两行的位置不影响关系的本质。</li>
</ul>
<ul>
<li><strong>SELECT * 的风险</strong>：虽然 <code>SELECT *</code> 方便，但在实际开发和大型考试中，明确列名（投影）更高效，也更安全。</li>
<li><strong>主键唯一性</strong>：记住 <code>PRIMARY KEY</code>。只要主键确定了，这一行（元组）就必须是唯一的。</li>
<li><strong>连接条件</strong>：看到复杂的 $\Pi$ 和 $\sigma$ 嵌套，转换成 SQL 时，别忘了把所有表都写在 <code>FROM</code> 里，把所有匹配条件写在 <code>WHERE</code> 里。</li>
</ul>
<hr>
<h1 id="五、计算机编程模块"><a href="#五、计算机编程模块" class="headerlink" title="五、计算机编程模块"></a>五、计算机编程模块</h1><h2 id="5-1-语言类型与翻译方式"><a href="#5-1-语言类型与翻译方式" class="headerlink" title="5.1 语言类型与翻译方式"></a>5.1 语言类型与翻译方式</h2><h3 id="1-语言类型识别"><a href="#1-语言类型识别" class="headerlink" title="1. 语言类型识别"></a>1. 语言类型识别</h3><ul>
<li><strong>机器语言</strong>：二进制代码，计算机唯一能直接识别的语言。</li>
<li><strong>汇编语言</strong>：用助记符代替机器指令，需要<strong>汇编器 (Assembler)</strong> 翻译。</li>
<li><strong>高级语言</strong>：接近自然语言和数学表达式。</li>
<li><strong>面向对象 (Object-Oriented)</strong>：Java, C++, Python, C#。</li>
<li><strong>过程化 (Procedural)</strong>：C, Pascal, Fortran。</li>
</ul>
<h3 id="2-高级语言的翻译方式（必考区别）"><a href="#2-高级语言的翻译方式（必考区别）" class="headerlink" title="2. 高级语言的翻译方式（必考区别）"></a>2. 高级语言的翻译方式（必考区别）</h3><p>高级语言编写的源码必须经过“翻译”才能运行：</p>
<ul>
<li><strong>编译 (Compilation)</strong>：将源程序<strong>一次性全部</strong>翻译成目标程序（机器代码文件，如 <code>.exe</code> 或 <code>.o</code>），之后可直接运行。代表语言：C, C++。</li>
<li><strong>解释 (Interpretation)</strong>：将源程序<strong>逐句</strong>翻译并立即执行，不产生独立的目标程序文件。代表语言：Python, JavaScript。</li>
</ul>
<h3 id="3-三种编程范式"><a href="#3-三种编程范式" class="headerlink" title="3. 三种编程范式"></a>3. 三种编程范式</h3><ul>
<li><p><strong>过程化范式 (Procedural Paradigm)</strong>：</p>
<ul>
<li><strong>核心</strong>：计算机按照程序员编写的<strong>指令顺序</strong>执行任务。</li>
<li><strong>典型语言</strong>：C、Pascal、Fortran、机器语言和汇编语言。</li>
</ul>
</li>
<li><p><strong>面向对象范式 (Object-Oriented Paradigm)</strong>：</p>
<ul>
<li><strong>核心</strong>：计算机处理的是<strong>对象</strong>以及对象之间的关系，执行过程不一定按照顺序步骤进行。</li>
<li><strong>关键概念</strong>：<ul>
<li><strong>类 (Class)</strong>：对象的模板。如定义的 <code>Ppizza</code> 类，它规定了披萨具有“形状”和“价格”等属性。</li>
<li><strong>封装 (Encapsulation)</strong>：将数据和处理数据的方法（如 <code>getSquareInchPrice()</code>）包装在类中。</li>
<li><strong>继承 (Inheritance)</strong>：子类自动获得父类的属性和方法。<code>RectanglePizza</code> 是 <code>Pizza</code> 类的<strong>子类</strong>，它继承了基础属性，并增加了长、宽等特有属性。</li>
</ul>
</li>
<li><strong>典型语言</strong>：Java、C++、Python、JavaScript。</li>
</ul>
</li>
<li><p><strong>声明性范式 (Declarative Paradigm)</strong>：</p>
<ul>
<li><strong>核心</strong>：程序员描述<strong>事实和规则</strong>，而不是具体的解决步骤。</li>
<li><strong>代表</strong>：SQL、Prolog。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-2-算法-Algorithm"><a href="#5-2-算法-Algorithm" class="headerlink" title="5.2 算法 (Algorithm)"></a>5.2 算法 (Algorithm)</h2><h3 id="1-算法的定义"><a href="#1-算法的定义" class="headerlink" title="1. 算法的定义"></a>1. 算法的定义</h3><p>算法是解决特定问题的具体步骤和方法。它必须具备：<strong>有穷性</strong>（步骤有限）、<strong>确定性</strong>（无歧义）、<strong>可行性</strong>、<strong>输入</strong>（0个或多个）和<strong>输出</strong>（至少1个）。</p>
<h3 id="2-算法的表达形式"><a href="#2-算法的表达形式" class="headerlink" title="2. 算法的表达形式"></a>2. 算法的表达形式</h3><ul>
<li><strong>自然语言</strong>：用中文&#x2F;英文描述，易懂但易产生歧义。</li>
<li><strong>流程图</strong>：用几何图形表示逻辑（如矩形表示处理，菱形表示判断）。</li>
<li><strong>伪代码</strong>：介于自然语言和编程语言之间，侧重逻辑。</li>
</ul>
<h3 id="3-算法的基本结构"><a href="#3-算法的基本结构" class="headerlink" title="3. 算法的基本结构"></a>3. 算法的基本结构</h3><p>任何复杂的算法都可以由这三种基本结构组合而成：</p>
<ol>
<li><strong>顺序结构</strong>：按先后顺序执行。</li>
<li><strong>分支结构（选择结构）</strong>：根据条件判断走不同的路径（<code>if-else</code>）。</li>
<li><strong>循环结构</strong>：重复执行某段代码直到满足退出条件（<code>for</code>, <code>while</code>）。</li>
</ol>
<hr>
<h2 id="5-3-编程范式：过程化-vs-面向对象"><a href="#5-3-编程范式：过程化-vs-面向对象" class="headerlink" title="5.3 编程范式：过程化 vs 面向对象"></a>5.3 编程范式：过程化 vs 面向对象</h2><p>这是理解现代软件开发的重点。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>过程化范式 (Procedural)</strong></th>
<th><strong>面向对象范式 (Object-Oriented)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心思想</strong></td>
<td><strong>自顶向下</strong>，以“步骤”为中心（做什么？）</td>
<td><strong>自底向上</strong>，以“事物”为中心（谁来做？）</td>
</tr>
<tr>
<td><strong>基本单元</strong></td>
<td>函数 &#x2F; 过程 (Function)</td>
<td>对象 &#x2F; 类 (Object &#x2F; Class)</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>结构清晰，性能高，适合底层开发</td>
<td>易维护、易复用、适合大型复杂系统</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>数据与操作分离，大型项目维护难</td>
<td>运行开销相对较大，学习曲线较陡</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-4-程序错误-Program-Errors"><a href="#5-4-程序错误-Program-Errors" class="headerlink" title="5.4 程序错误 (Program Errors)"></a>5.4 程序错误 (Program Errors)</h2><p>程序出错不可怕，关键要分清类别，考试常考选择题。</p>
<ol>
<li><strong>语法错误 (Syntax Error)</strong>：</li>
</ol>
<ul>
<li><strong>现象</strong>：不符合编程语言的规则（如少了个分号，括号不匹配）。</li>
<li><strong>发现时机</strong>：<strong>编译阶段</strong>就会报错，程序无法运行。</li>
</ul>
<ol start="2">
<li><strong>逻辑错误 (Logic Error &#x2F; Semantic Error)</strong>：</li>
</ol>
<ul>
<li><strong>现象</strong>：程序能跑，但结果不对（如算加法写成了减法）。</li>
<li><strong>发现时机</strong>：运行后发现输出不符合预期，是最难查的错误。</li>
</ul>
<ol start="3">
<li><strong>运行时错误 (Runtime Error)</strong>：</li>
</ol>
<ul>
<li><strong>现象</strong>：程序运行过程中突然崩溃（如除以0、内存溢出）。</li>
<li><strong>发现时机</strong>：<strong>执行阶段</strong>。</li>
</ul>
<hr>
<h2 id="5-5-补充"><a href="#5-5-补充" class="headerlink" title="5.5 补充"></a>5.5 补充</h2><h3 id="1-UML-图（统一建模语言）"><a href="#1-UML-图（统一建模语言）" class="headerlink" title="1. UML 图（统一建模语言）"></a>1. UML 图（统一建模语言）</h3><ul>
<li><strong>类图 (Class Diagram)</strong>：最常用。用矩形表示类，分为三层：类名、属性（变量）、方法（函数）。</li>
<li><strong>关系表达</strong>：在 UML 中，<strong>继承</strong>关系通常用带空心三角形的实线表示（从子类指向父类）。</li>
</ul>
<p><strong>例题：</strong><br>定义一个至少具有四个属性的名为People的类，并创建两个名为Students和Instructors的People的子类，用代码或UML图表示即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class People &#123;</span><br><span class="line">        +String name</span><br><span class="line">        +int age</span><br><span class="line">        +String gender</span><br><span class="line">        +String idNumber</span><br><span class="line">        +eat()</span><br><span class="line">        +sleep()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Students &#123;</span><br><span class="line">        +String studentID</span><br><span class="line">        +float GPA</span><br><span class="line">        +study()</span><br><span class="line">        +takeExam()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Instructors &#123;</span><br><span class="line">        +String employeeID</span><br><span class="line">        +String department</span><br><span class="line">        +teach()</span><br><span class="line">        +assignHomework()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    People &lt;|-- Students : 继承 (Inheritance)</span><br><span class="line">    People &lt;|-- Instructors : 继承 (Inheritance)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>类结构 (Class Structure)</strong>：<ul>
<li>每个矩形代表一个<strong>类 (Class)</strong>。</li>
<li>顶部是类名，中间是<strong>属性 (Attributes&#x2F;Fields)</strong>，底部是<strong>方法 (Methods&#x2F;Functions)</strong>。</li>
</ul>
</li>
<li><strong>继承与多态 (Inheritance)</strong>：<ul>
<li><code>Students</code> 和 <code>Instructors</code> 自动拥有了 <code>People</code> 的四个基础属性（姓名、年龄、性别、身份证号），这就是<strong>继承</strong>的威力。</li>
<li>子类可以在继承的基础上增加自己特有的属性（如学生的 <code>GPA</code>，教师的 <code>department</code>）。</li>
</ul>
</li>
<li><strong>封装 (Encapsulation)</strong>：<ul>
<li>属性名前的 <code>+</code> 号代表 <code>public</code>（公开），这体现了将数据和操作包装在一起的<strong>封装</strong>思想。</li>
</ul>
</li>
<li><strong>范式识别</strong>：<ul>
<li>这种以“类”和“对象”为核心的设计属于<strong>面向对象范式 (Object-Oriented Paradigm)</strong>。</li>
</ul>
</li>
</ul>
<h3 id="2-Prolog-逻辑编程"><a href="#2-Prolog-逻辑编程" class="headerlink" title="2. Prolog 逻辑编程"></a>2. Prolog 逻辑编程</h3><p>Prolog 是一种独特的声明性语言，主要用于人工智能和逻辑推理。</p>
<ul>
<li><strong>事实 (Fact)</strong>：提供解决问题的基本信息。</li>
<li><strong>语法规范</strong>：<ul>
<li>事实以<strong>小写字母</strong>开头，以<strong>句点</strong>结尾。</li>
<li>参数放在圆括号中，用逗号分隔。</li>
<li><strong>例子</strong>：<code>shapeof(pizza,round).</code> 表示“披萨的形状是圆的”这一事实。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="💡-考前避坑："><a href="#💡-考前避坑：" class="headerlink" title="💡 考前避坑："></a>💡 考前避坑：</h3><ul>
<li><strong>注意区分</strong>：汇编语言不是高级语言，它属于低级语言，虽然它用了英文单词。</li>
<li><strong>算法 vs 程序</strong>：算法是解决问题的逻辑，程序是算法在计算机上的具体实现。一个算法可以用多种语言写成程序。</li>
<li><strong>OOP 特性</strong>：如果题目提到“封装、继承、多态”，指的一定是<strong>面向对象</strong>。</li>
</ul>
<hr>
<h1 id="六、计算机网络模块"><a href="#六、计算机网络模块" class="headerlink" title="六、计算机网络模块"></a>六、计算机网络模块</h1><h3 id="6-1-网络架构模式：C-S-vs-B-S"><a href="#6-1-网络架构模式：C-S-vs-B-S" class="headerlink" title="6.1 网络架构模式：C&#x2F;S vs B&#x2F;S"></a>6.1 网络架构模式：C&#x2F;S vs B&#x2F;S</h3><p>这是关于“软件长在哪”的问题。</p>
<ul>
<li><p><strong>C&#x2F;S (Client&#x2F;Server，客户端&#x2F;服务器)</strong></p>
</li>
<li><p><strong>定义</strong>：用户必须安装专门的客户端软件才能使用（如：微信电脑版、英雄联盟、大型数据库客户端）。</p>
</li>
<li><p><strong>优点</strong>：响应速度快（本地处理一部分逻辑）、图形表现力强、安全性较高。</p>
</li>
<li><p><strong>缺点</strong>：安装麻烦、更新代价大（每个客户端都要升级）。</p>
</li>
<li><p><strong>B&#x2F;S (Browser&#x2F;Server，浏览器&#x2F;服务器)</strong></p>
</li>
<li><p><strong>定义</strong>：用户只需通过浏览器（Chrome, Edge）访问特定的网址即可使用（如：网页版微博、在线教务系统）。</p>
</li>
<li><p><strong>优点</strong>：无需安装、维护简单（只用更新服务器）、跨平台性强。</p>
</li>
<li><p><strong>缺点</strong>：受限于浏览器性能、安全性控制相对较难。</p>
</li>
</ul>
<hr>
<h3 id="6-2-核心网络模型：OSI-七层-vs-TCP-IP-四层"><a href="#6-2-核心网络模型：OSI-七层-vs-TCP-IP-四层" class="headerlink" title="6.2 核心网络模型：OSI 七层 vs TCP&#x2F;IP 四层"></a>6.2 核心网络模型：OSI 七层 vs TCP&#x2F;IP 四层</h3><p>这是考试最喜欢考的<strong>对应关系图</strong>。OSI 是理论标准，TCP&#x2F;IP 是事实上的工业标准。</p>
<table>
<thead>
<tr>
<th>OSI 七层参考模型</th>
<th>TCP&#x2F;IP 四层模型</th>
<th>功能简述</th>
<th>协议&#x2F;设备举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用层</strong> (Application)</td>
<td><strong>应用层</strong></td>
<td>用户接口，直接面向程序</td>
<td>HTTP, FTP, DNS, SMTP</td>
</tr>
<tr>
<td><strong>表示层</strong> (Presentation)</td>
<td>(合并到应用层)</td>
<td>格式转换、加密解密</td>
<td>-</td>
</tr>
<tr>
<td><strong>会话层</strong> (Session)</td>
<td>(合并到应用层)</td>
<td>建立、管理、终止会话</td>
<td>-</td>
</tr>
<tr>
<td><strong>传输层</strong> (Transport)</td>
<td><strong>传输层</strong></td>
<td>提供<strong>端到端</strong>的数据传输</td>
<td><strong>TCP</strong>, <strong>UDP</strong></td>
</tr>
<tr>
<td><strong>网络层</strong> (Network)</td>
<td><strong>网络层</strong> (或网际层)</td>
<td>寻址和路由选择（<strong>主机到主机</strong>）</td>
<td><strong>IP</strong>, ICMP, 路由器</td>
</tr>
<tr>
<td><strong>数据链路层</strong> (Data Link)</td>
<td><strong>网络接口层</strong></td>
<td>物理地址寻址（MAC）、成帧</td>
<td>以太网协议, 交换机</td>
</tr>
<tr>
<td><strong>物理层</strong> (Physical)</td>
<td><strong>网络接口层</strong></td>
<td>透明传输比特流（0和1）</td>
<td>网线, 集线器</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-3-传输层协议：TCP-与-UDP-的区别"><a href="#6-3-传输层协议：TCP-与-UDP-的区别" class="headerlink" title="6.3 传输层协议：TCP 与 UDP 的区别"></a>6.3 传输层协议：TCP 与 UDP 的区别</h3><p>这是必考的对比选择题。</p>
<ul>
<li><p><strong>TCP (Transmission Control Protocol, 传输控制协议)</strong></p>
</li>
<li><p><strong>特性</strong>：<strong>面向连接</strong>、可靠、有序。</p>
</li>
<li><p><strong>机制</strong>：三次握手（建立连接）、确认应答、超时重传。</p>
</li>
<li><p><strong>适用场景</strong>：对准确性要求极高的场景，如文件传输（FTP）、网页浏览（HTTP）、邮件（SMTP）。</p>
</li>
<li><p><strong>UDP (User Datagram Protocol, 用户数据报协议)</strong></p>
</li>
<li><p><strong>特性</strong>：<strong>无连接</strong>、不可靠、尽力而为。</p>
</li>
<li><p><strong>优点</strong>：开销小、速度极快、延迟低。</p>
</li>
<li><p><strong>适用场景</strong>：对实时性要求极高、丢一点包没关系的场景，如视频会议、在线直播、网络电话、多人在线游戏。</p>
</li>
</ul>
<hr>
<h3 id="6-4-网络地址与寻址"><a href="#6-4-网络地址与寻址" class="headerlink" title="6.4 网络地址与寻址"></a>6.4 网络地址与寻址</h3><h4 id="1-IP-地址：IPv4-vs-IPv6"><a href="#1-IP-地址：IPv4-vs-IPv6" class="headerlink" title="(1) IP 地址：IPv4 vs IPv6"></a>(1) IP 地址：IPv4 vs IPv6</h4><ul>
<li><strong>IPv4</strong>：32 位二进制，通常用“点分十进制”表示（如 <code>192.168.1.1</code>）。地址空间已耗尽。</li>
<li><strong>IPv6</strong>：128 位二进制，用“冒号十六进制”表示。它解决了地址枯竭问题，可以给地球上每一粒沙子分配一个 IP。</li>
</ul>
<h4 id="2-URL-统一资源定位符-的组成"><a href="#2-URL-统一资源定位符-的组成" class="headerlink" title="(2) URL (统一资源定位符) 的组成"></a>(2) URL (统一资源定位符) 的组成</h4><p>URL 是我们在浏览器输入的完整地址，格式如下：<br><code>协议名://域名:端口号/路径/文件名</code></p>
<p><strong>例子</strong>：<code>https://www.example.com:8080/news/index.html</code></p>
<ul>
<li><strong><code>https</code></strong>：协议（Protocol）。</li>
<li><strong><code>www.example.com</code></strong>：域名（Host），通过 <strong>DNS</strong> 翻译成 IP。</li>
<li><strong><code>8080</code></strong>：端口号（Port），默认为 80（HTTP）或 443（HTTPS）时常省略。</li>
<li><strong><code>/news/</code></strong>：路径。</li>
<li><strong><code>index.html</code></strong>：文件名。</li>
</ul>
<hr>
<h3 id="6-5-补充"><a href="#6-5-补充" class="headerlink" title="6.5 补充"></a>6.5 补充</h3><h3 id="1-计算机网络的类型（按覆盖范围划分）"><a href="#1-计算机网络的类型（按覆盖范围划分）" class="headerlink" title="1. 计算机网络的类型（按覆盖范围划分）"></a>1. 计算机网络的类型（按覆盖范围划分）</h3><p>这是最基础的分类方式，主要考察覆盖距离。</p>
<ul>
<li><strong>个人区域网 (PAN, Personal Area Network)</strong>：如手机与蓝牙耳机连接，范围几米。</li>
<li><strong>局域网 (LAN, Local Area Network)</strong>：覆盖一栋大楼或一个校园，传输速率高，延迟低。</li>
<li><strong>城域网 (MAN, Metropolitan Area Network)</strong>：覆盖一个城市。</li>
<li><strong>广域网 (WAN, Wide Area Network)</strong>：覆盖国家、洲甚至全球。<strong>因特网 (Internet)</strong> 是世界上最大的广域网。</li>
</ul>
<hr>
<h3 id="2-网络拓扑结构-Topology"><a href="#2-网络拓扑结构-Topology" class="headerlink" title="2. 网络拓扑结构 (Topology)"></a>2. 网络拓扑结构 (Topology)</h3><p>指的是网络中节点（电脑、路由器）的物理或逻辑连接布局。</p>
<ul>
<li><p><strong>星型拓扑 (Star)</strong>：所有节点连接到中心节点（如交换机）。</p>
</li>
<li><p><em>特点</em>：易于管理，中心节点坏了全网瘫痪。</p>
</li>
<li><p><strong>总线型拓扑 (Bus)</strong>：所有节点共享一根主传输线（总线）。</p>
</li>
<li><p><em>特点</em>：结构简单，但总线忙时效率低。</p>
</li>
<li><p><strong>环型拓扑 (Ring)</strong>：节点连成一个闭合环。</p>
</li>
<li><p><em>特点</em>：信号单向传输，一个节点断开全网中断。</p>
</li>
<li><p><strong>网状拓扑 (Mesh)</strong>：节点间有多条路径相连。</p>
</li>
<li><p><em>特点</em>：可靠性最高（冗余强），常用于广域网核心，但成本高。</p>
</li>
</ul>
<hr>
<h3 id="3-IP-地址的划分（重点计算题型）"><a href="#3-IP-地址的划分（重点计算题型）" class="headerlink" title="3. IP 地址的划分（重点计算题型）"></a>3. IP 地址的划分（重点计算题型）</h3><p>IPv4 地址（32 位）最初是按“类”来划分的，你需要记住每一类的第一个字节范围。</p>
<h4 id="1-有类地址划分"><a href="#1-有类地址划分" class="headerlink" title="(1) 有类地址划分"></a>(1) 有类地址划分</h4><table>
<thead>
<tr>
<th>类别</th>
<th>首字节范围 (十进制)</th>
<th>网络号&#x2F;主机号长度</th>
<th>适用规模</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A 类</strong></td>
<td><strong>1 ~ 126</strong></td>
<td>8位 &#x2F; 24位</td>
<td>超大型网络（如跨国巨头）</td>
</tr>
<tr>
<td><strong>B 类</strong></td>
<td><strong>128 ~ 191</strong></td>
<td>16位 &#x2F; 16位</td>
<td>中型网络（如大学、大企业）</td>
</tr>
<tr>
<td><strong>C 类</strong></td>
<td><strong>192 ~ 223</strong></td>
<td>24位 &#x2F; 8位</td>
<td>小型网络（如小公司、实验室）</td>
</tr>
<tr>
<td><strong>D 类</strong></td>
<td><strong>224 ~ 239</strong></td>
<td>多播地址</td>
<td>组播使用</td>
</tr>
<tr>
<td><strong>E 类</strong></td>
<td><strong>240 ~ 255</strong></td>
<td>保留地址</td>
<td>科学研究</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong> <code>127.x.x.x</code> 是<strong>回环地址</strong>（Loopback），用于测试本机网络协议栈是否正常。</p>
</blockquote>
<h4 id="2-子网掩码-Subnet-Mask"><a href="#2-子网掩码-Subnet-Mask" class="headerlink" title="(2) 子网掩码 (Subnet Mask)"></a>(2) 子网掩码 (Subnet Mask)</h4><ul>
<li><strong>作用</strong>：用来区分 IP 地址中哪部分是“网络号”，哪部分是“主机号”。</li>
<li><strong>标准掩码</strong>：</li>
<li>A 类：<code>255.0.0.0</code></li>
<li>B 类：<code>255.255.0.0</code></li>
<li>C 类：<code>255.255.255.0</code></li>
</ul>
<hr>
<h3 id="4-特殊-IP-与保留地址"><a href="#4-特殊-IP-与保留地址" class="headerlink" title="4. 特殊 IP 与保留地址"></a>4. 特殊 IP 与保留地址</h3><ul>
<li><strong>私有地址 (Private IP)</strong>：</li>
<li>这类地址在因特网上是<strong>不路由</strong>的，仅限内部局域网使用，通过 <strong>NAT (网络地址转换)</strong> 访问外网。</li>
<li>常见：<code>192.168.x.x</code>, <code>10.x.x.x</code>, <code>172.16.x.x</code>。</li>
<li><strong>广播地址</strong>：主机号全为 1 的地址（如 <code>192.168.1.255</code>）。</li>
<li><strong>网络地址</strong>：主机号全为 0 的地址（如 <code>192.168.1.0</code>）。</li>
</ul>
<hr>
<h3 id="✍️-考前针对性练习"><a href="#✍️-考前针对性练习" class="headerlink" title="✍️ 考前针对性练习"></a>✍️ 考前针对性练习</h3><p><strong>题 1：</strong> 当你在观看世界杯决赛直播时，如果网络偶尔卡顿，画面出现短暂的马赛克但随后恢复正常，这通常是由于底层使用了什么协议？</p>
<blockquote>
<p><strong>答案</strong>：<strong>UDP</strong>。因为它不重传丢掉的包，所以画面会花，但保证了直播的实时性。</p>
</blockquote>
<p><strong>题 2：</strong> 在 OSI 模型中，负责“路径选择”和“逻辑寻址”的是哪一层？</p>
<blockquote>
<p><strong>答案</strong>：<strong>网络层</strong>（记住：路由器的地盘就在网络层）。</p>
</blockquote>
<p><strong>题 3：</strong> 判断：在 B&#x2F;S 架构中，用户端的所有计算逻辑都必须在浏览器中完成。</p>
<blockquote>
<p><strong>答案</strong>：<strong>错</strong>。绝大部分核心业务逻辑是在后端的服务器上运行的。</p>
</blockquote>
<p><strong>题 2：</strong> 某公司分配到的 IP 地址是 <code>172.16.10.5</code>，请问它属于哪一类地址？其默认子网掩码是什么？</p>
<blockquote>
<p><strong>答案</strong>：属于 <strong>B 类</strong>（172 在 128~191 之间）。默认掩码为 <code>255.255.0.0</code>。</p>
</blockquote>
<p><strong>题 2：</strong> 如果你家里的几台设备通过同一个路由器上网，每台设备都有一个 <code>192.168.x.x</code> 的地址，这个地址属于？</p>
<blockquote>
<p><strong>答案</strong>：<strong>C 类</strong>地址，且属于<strong>私有地址</strong>。</p>
</blockquote>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href>鱼浩琳</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://yuhaolin-79.github.io/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/">https://yuhaolin-79.github.io/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">本文版权归作者所有，转载请注明出处</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/24/%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E8%BF%91%E4%BA%94%E5%B9%B4%E5%BE%AE%E7%A7%AF%E5%88%86I-1%E7%A7%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/" title="翁恺C语言学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">翁恺C语言学习笔记</div></div><div class="info-2"><div class="info-item-1">四川大学微积分（I）-1 五年考点分布与题型统计（2020-2024）一、统计概述基于2020-2021至2024-2025学年共5套四川大学微积分（I）-1期末A卷，统计维度包括题型结构、考点分类及频次、分值占比，覆盖所有试题的核心考查内容，为后续可视化和备考提供数据支撑。![[Figure_calculus_statics.png]] 二、题型结构统计1. 题型分类及分值占比   题型 出现年份 单题分值范围 每套卷总分值占比 核心功能    填空题 2020-2023（4套） 3分&#x2F;题 15%（5题×3分） 基础概念与简单计算，覆盖广   计算题 2020-2024（5套） 5-8分&#x2F;题 25%-48% 核心运算能力，含极限、积分等   解答题 2020-2024（5套） 8-10分&#x2F;题 20%-40% 综合应用，含分段函数、隐函数等   应用题 2020-2024（5套） 9-12分&#x2F;题 18%-22% 实际场景转化，含几何、物理应用   证明题 2020-2024（5套） 6-8分&#x2F;题 13%-15% 逻辑推理，含不等式...</div></div></div></a><a class="pagination-related" href="/2025/12/24/C%E8%AF%AD%E8%A8%80%E5%8E%86%E5%B9%B4%E6%9C%9F%E6%9C%AB%E7%9C%9F%E9%A2%98(%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86)/" title="C语言历年期末真题(上半部分)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">C语言历年期末真题(上半部分)</div></div><div class="info-2"><div class="info-item-1">1: 最小的数描述给定0-9数字各若干个，以任意顺序排列这些数字，使得最后得到的数尽可能小（0 不能做首位）。 输入在一行中给出 10 个非负整数，顺序表示数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。 输出在一行中输出能够组成的最小的数。 样例输入 12 2 0 0 0 3 0 0 1 0 输出 110015558  代码1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main(void)&#123;    int digits[10];    for(int i = 0;i&lt;10;i++)&#123;        scanf(&quot;%d&quot;,&amp;digits[i]);    &#125;    for(int i = 1;i&lt;10;i++)&#123;        if(digits[i] &gt; 0)&#123;            printf(&quot;%d&quo...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251016203042_20_118.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">鱼浩琳</div><div class="author-info-description">SCUer~</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuhaolin-79"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yuhaolin-79" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yuhaolin7.9@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BE%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">一、数据表达与计算模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 存储单位换算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 数制转换与对应关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%83%A8%E5%88%86%EF%BC%9A%E9%99%A4-2-%E5%8F%96%E4%BD%99%E6%B3%95-Divide-by-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">整数部分：除 2 取余法 (Divide by 2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86%EF%BC%9A%E4%B9%98-2-%E5%8F%96%E6%95%B4%E6%B3%95-Multiply-by-2"><span class="toc-number">1.2.2.</span> <span class="toc-text">小数部分：乘 2 取整法 (Multiply by 2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E8%80%83%E7%82%B9%EF%BC%9A%E6%97%A0%E6%B3%95%E7%B2%BE%E7%A1%AE%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.2.3.</span> <span class="toc-text">进阶考点：无法精确转换的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2%E6%8A%80%E5%B7%A7%EF%BC%88%E5%87%91%E6%95%B0%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">快速转换技巧（凑数法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 详解：原码、反码、补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A58%E4%BD%8D%E5%AD%97%E9%95%BF%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 定义与转换流程（以8位字长为例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 经典例子对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%A5%E7%A0%81%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 补码求和运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%EF%BC%88%E5%9B%BD%E6%A0%87%E7%A0%81%E3%80%81%E6%9C%BA%E5%86%85%E7%A0%81%E3%80%81%E5%AD%97%E5%BD%A2%E7%A0%81%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 汉字编码（国标码、机内码、字形码）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B1%89%E5%AD%97%E7%9A%84%E2%80%9C%E4%B8%89%E7%A0%81%E2%80%9D%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 汉字的“三码”关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%8D%A2%E7%AE%97%E5%85%AC%E5%BC%8F%EF%BC%88%E5%BF%85%E8%AE%B0%EF%BC%81%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 核心换算公式（必记！）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E5%BD%A2%E7%A0%81%EF%BC%88%E5%AD%97%E5%BA%93%E7%A0%81%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 字形码（字库码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E2%80%9C%E9%98%B6%E7%A0%81%E2%80%9D%E4%B8%8E%E2%80%9C%E5%B0%BE%E6%95%B0%E2%80%9D"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.5 浮点数的“阶码”与“尾数”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.6.</span> <span class="toc-text">1.6 字符编码大小比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%EF%BC%88Memory-Hierarchy%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 存储层次结构（Memory Hierarchy）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 存储层次的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Cache%EF%BC%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. Cache（高速缓冲存储器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%EF%BC%88Cache%EF%BC%89%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">(1) 高速缓存（Cache）的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CPU%E3%80%81Cache%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E5%A4%96%E5%AD%98%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">(2) CPU、Cache、内存、外存的层级关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">(3) 核心作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CPU-%E7%BB%84%E6%88%90%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 CPU 组成与功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E7%AE%97%E5%99%A8%EF%BC%88Arithmetic-Logic-Unit-ALU%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 运算器（Arithmetic Logic Unit, ALU）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CPU-%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%86%99%E7%9A%84%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. CPU 直接读写的存储介质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%88Instruction-Execution%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 指令执行（Instruction Execution）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. 计算机直接执行的代码类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F%EF%BC%88%E5%BF%85%E8%80%83%E6%AD%A5%E9%AA%A4%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. 指令周期顺序（必考步骤）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF-Pipelining"><span class="toc-number">2.3.3.</span> <span class="toc-text">3. 指令流水线技术 (Pipelining)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%80%BB%E7%BB%93%E9%81%BF%E5%9D%91%EF%BC%9A"><span class="toc-number">2.3.4.</span> <span class="toc-text">⚠️ 总结避坑：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">三、操作系统模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%EF%BC%88Process-vs-Thread%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 进程与线程（Process vs. Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 进程（Process）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 线程（Thread）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%EF%BC%88%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 区别与联系（高频考点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 操作系统核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9B%AE%E6%A0%87"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 设备管理目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E7%89%87%EF%BC%88Time-Slice%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 时间片（Time Slice）定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">三、 进程调度与上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Context-Switch%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 上下文切换（Context Switch）的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%88%E8%A1%A5%E5%85%85%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. 进程的三种基本状态（补充考点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E9%81%BF%E5%9D%91%E5%B0%8F%E8%B4%B4%E5%A3%AB%EF%BC%9A"><span class="toc-number">3.4.</span> <span class="toc-text">💡 避坑小贴士：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">四、数据库模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%EF%BC%88Relational-Model%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 关系模型（Relational Model）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-SQL-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 SQL 语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%B1%BB%E5%9E%8B%EF%BC%88DQL-DML-DDL-DCL%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 查询语句类型（DQL&#x2F;DML&#x2F;DDL&#x2F;DCL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SELECT-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. SELECT * 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SQL-%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. SQL 的定义与约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-DBMS-%E5%8A%9F%E8%83%BD%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 DBMS 功能（数据库管理系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">4.3.1.</span> <span class="toc-text">1. 数据库系统的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DBMS-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">4.3.2.</span> <span class="toc-text">2. DBMS 的主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5-vs-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">3. 数据操纵 vs 数据控制（易混淆点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%A1%A5%E5%85%85%E8%80%83%E7%82%B9%EF%BC%9A%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 补充考点：关系运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E7%BB%BC%E5%90%88%E5%A4%A7%E9%A2%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.5 数据库模块综合大题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89-DDL"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">任务 1：数据定义 (DDL)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-2%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">任务 2：索引创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-3%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2-DQL-%E6%A0%B8%E5%BF%83"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">任务 3：数据查询 (DQL - 核心)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4-DML"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">任务 4：数据修改与删除 (DML)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E9%81%BF%E5%9D%91%E5%B0%8F%E8%B4%B4%E5%A3%AB%EF%BC%9A-1"><span class="toc-number">4.4.2.</span> <span class="toc-text">💡 避坑小贴士：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">五、计算机编程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BF%BB%E8%AF%91%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 语言类型与翻译方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 语言类型识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BF%BB%E8%AF%91%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BF%85%E8%80%83%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 高级语言的翻译方式（必考区别）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%89%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">3. 三种编程范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%AE%97%E6%B3%95-Algorithm"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 算法 (Algorithm)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">1. 算法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">2. 算法的表达形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">3. 算法的基本结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%EF%BC%9A%E8%BF%87%E7%A8%8B%E5%8C%96-vs-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 编程范式：过程化 vs 面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF-Program-Errors"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 程序错误 (Program Errors)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E8%A1%A5%E5%85%85"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-UML-%E5%9B%BE%EF%BC%88%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%EF%BC%89"><span class="toc-number">5.5.1.</span> <span class="toc-text">1. UML 图（统一建模语言）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Prolog-%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.5.2.</span> <span class="toc-text">2. Prolog 逻辑编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E8%80%83%E5%89%8D%E9%81%BF%E5%9D%91%EF%BC%9A"><span class="toc-number">5.5.3.</span> <span class="toc-text">💡 考前避坑：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">六、计算机网络模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%9AC-S-vs-B-S"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 网络架构模式：C&#x2F;S vs B&#x2F;S</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%9AOSI-%E4%B8%83%E5%B1%82-vs-TCP-IP-%E5%9B%9B%E5%B1%82"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 核心网络模型：OSI 七层 vs TCP&#x2F;IP 四层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9ATCP-%E4%B8%8E-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 传输层协议：TCP 与 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%AF%BB%E5%9D%80"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 网络地址与寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP-%E5%9C%B0%E5%9D%80%EF%BC%9AIPv4-vs-IPv6"><span class="toc-number">6.4.1.</span> <span class="toc-text">(1) IP 地址：IPv4 vs IPv6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-URL-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">6.4.2.</span> <span class="toc-text">(2) URL (统一资源定位符) 的组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%A1%A5%E5%85%85"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%8C%89%E8%A6%86%E7%9B%96%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">1. 计算机网络的类型（按覆盖范围划分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-Topology"><span class="toc-number">6.7.</span> <span class="toc-text">2. 网络拓扑结构 (Topology)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86%EF%BC%88%E9%87%8D%E7%82%B9%E8%AE%A1%E7%AE%97%E9%A2%98%E5%9E%8B%EF%BC%89"><span class="toc-number">6.8.</span> <span class="toc-text">3. IP 地址的划分（重点计算题型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%89%E7%B1%BB%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86"><span class="toc-number">6.8.1.</span> <span class="toc-text">(1) 有类地址划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-Subnet-Mask"><span class="toc-number">6.8.2.</span> <span class="toc-text">(2) 子网掩码 (Subnet Mask)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%B9%E6%AE%8A-IP-%E4%B8%8E%E4%BF%9D%E7%95%99%E5%9C%B0%E5%9D%80"><span class="toc-number">6.9.</span> <span class="toc-text">4. 特殊 IP 与保留地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%8D%EF%B8%8F-%E8%80%83%E5%89%8D%E9%92%88%E5%AF%B9%E6%80%A7%E7%BB%83%E4%B9%A0"><span class="toc-number">6.10.</span> <span class="toc-text">✍️ 考前针对性练习</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/24/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="翁恺C语言学习笔记">翁恺C语言学习笔记</a><time datetime="2026-01-24T10:39:54.000Z" title="Created 2026-01-24 18:39:54">2026-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/" title="翁恺C语言学习笔记">翁恺C语言学习笔记</a><time datetime="2026-01-23T16:00:00.000Z" title="Created 2026-01-24 00:00:00">2026-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/24/%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E8%BF%91%E4%BA%94%E5%B9%B4%E5%BE%AE%E7%A7%AF%E5%88%86I-1%E7%A7%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/" title="翁恺C语言学习笔记">翁恺C语言学习笔记</a><time datetime="2026-01-23T16:00:00.000Z" title="Created 2026-01-24 00:00:00">2026-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/24/C%E8%AF%AD%E8%A8%80%E5%8E%86%E5%B9%B4%E6%9C%9F%E6%9C%AB%E7%9C%9F%E9%A2%98(%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86)/" title="C语言历年期末真题(上半部分)">C语言历年期末真题(上半部分)</a><time datetime="2025-12-24T12:56:34.000Z" title="Created 2025-12-24 20:56:34">2025-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E7%AC%94%E8%AE%B0/" title="蓝桥杯备赛笔记（全章节整理）">蓝桥杯备赛笔记（全章节整理）</a><time datetime="2025-12-15T12:00:00.000Z" title="Created 2025-12-15 20:00:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 鱼浩琳</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>