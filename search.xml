<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三大微分中值定理</title>
    <url>/2025/11/30/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[三大中值定理总结（含考研真题示例，每题1道例题）一、罗尔定理（Rolle’s Theorem）1. 核心定义若函数 $f(x)$ 满足 3个条件：

闭区间连续：$f(x) \in C[a,b]$（在$[a,b]$上连续）；
开区间可导：$f(x) \in D(a,b)$（在$(a,b)$内可导）；
端点值相等：$f(a) &#x3D; f(b)$；则存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; 0$。

几何意义：连续可导曲线在区间端点函数值相等时，曲线上至少有一点的切线与x轴平行（水平切线）。
2. 考研真题示例（2017年数学一&#x2F;二&#x2F;三）设函数 $f(x)$ 在$[0,1]$上连续，在$(0,1)$内可导，且 $f(1) &#x3D; 0$。证明：存在 $\xi \in (0,1)$，使得 $f’(\xi) &#x3D; -\frac{f(\xi)}{\xi}$。
证明步骤（可直接用于笔记&#x2F;答题）：

构造辅助函数：将待证式变形为 $\xi f’(\xi) + f(\xi) &#x3D; 0$，观察到左边是 $[x f(x)]’$ 的形式，故令 $F(x) &#x3D; x f(x)$。
验证罗尔定理条件：
连续性：$f(x)$ 连续、$x$ 连续，乘积 $F(x) \in C[0,1]$；
可导性：乘积求导得 $F’(x) &#x3D; f(x) + x f’(x)$，故 $F(x) \in D(0,1)$；
端点相等：$F(0) &#x3D; 0 \cdot f(0) &#x3D; 0$，$F(1) &#x3D; 1 \cdot f(1) &#x3D; 0$，即 $F(0) &#x3D; F(1)$。


应用定理：由罗尔定理，存在 $\xi \in (0,1)$ 使得 $F’(\xi) &#x3D; 0$，即 $f(\xi) + \xi f’(\xi) &#x3D; 0$，整理得 $f’(\xi) &#x3D; -\frac{f(\xi)}{\xi}$。

二、拉格朗日中值定理（Lagrange’s Mean Value Theorem）1. 核心定义若函数 $f(x)$ 满足 2个条件：

闭区间连续：$f(x) \in C[a,b]$；
开区间可导：$f(x) \in D(a,b)$；则存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; \frac{f(b) - f(a)}{b - a}$。

几何意义：连续可导曲线在区间上至少有一点的切线与区间端点连线（割线）平行。
常用等价形式：$f(b) - f(a) &#x3D; f’(\xi)(b - a)$（增量公式，可直接用于不等式证明、函数单调性判断）。
2. 考研真题示例（2019年数学一）设函数 $f(x)$ 在$[0,1]$上具有二阶导数，且 $f(1) &#x3D; 0$。记 $g(x) &#x3D; x f(x)$，证明：存在 $\xi \in (0,1)$，使得 $g’’(\xi) &#x3D; 0$。
证明步骤（可直接用于笔记&#x2F;答题）：

第一步：对 $g(x)$ 用罗尔定理找 $g’(x)$ 的零点：
$g(x) &#x3D; x f(x)$，则 $g(0) &#x3D; 0 \cdot f(0) &#x3D; 0$，$g(1) &#x3D; 1 \cdot f(1) &#x3D; 0$；
由罗尔定理，存在 $\eta \in (0,1)$ 使得 $g’(\eta) &#x3D; 0$。


第二步：分析 $g’(x)$ 的表达式：
求导得 $g’(x) &#x3D; f(x) + x f’(x)$，因 $f(x)$ 二阶可导，故 $g’(x) \in C[0,\eta]$ 且 $g’(x) \in D(0,\eta)$（可导必连续）。


第三步：对 $g’(x)$ 用罗尔定理：
代入 $x&#x3D;0$ 得 $g’(0) &#x3D; f(0) + 0 \cdot f’(0) &#x3D; f(0)$，结合 $g’(\eta) &#x3D; 0$，且 $g’(x)$ 可导，故存在 $\xi \in (0,\eta) \subset (0,1)$ 使得 $g’’(\xi) &#x3D; 0$。



简化记忆：二阶导数为零的证明，常通过“对一阶导数用罗尔定理”，核心是找到一阶导数的两个零点。
三、柯西中值定理（Cauchy’s Mean Value Theorem）1. 核心定义若函数 $f(x)$ 和 $g(x)$ 满足 4个条件：

闭区间连续：$f(x), g(x) \in C[a,b]$；
开区间可导：$f(x), g(x) \in D(a,b)$；
导数不同时为零：对任意 $x \in (a,b)$，$f’(x)^2 + g’(x)^2 \neq 0$；
端点函数值不等：$g(a) \neq g(b)$；则存在 $\xi \in (a,b)$，使得 $\frac{f(b) - f(a)}{g(b) - g(a)} &#x3D; \frac{f’(\xi)}{g’(\xi)}$。

几何意义：以 $x$ 为参数的曲线 $\begin{cases} X &#x3D; g(x) \ Y &#x3D; f(x) \end{cases}$ 上，至少有一点的切线与区间端点连线（割线）平行。
特殊情况：当 $g(x) &#x3D; x$ 时，柯西中值定理退化为拉格朗日中值定理（故拉格朗日是柯西的特例）。
2. 考研真题示例（2018年数学二）设函数 $f(x)$ 在$[a,b]$上连续，在$(a,b)$内可导，且 $f(a) &#x3D; f(b) &#x3D; 0$。证明：存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; f(\xi) \cdot \frac{g’(\xi)}{g(\xi)}$（其中 $g(x)$ 在$[a,b]$上连续且不为零，$g’(x)$ 存在）。
证明步骤（可直接用于笔记&#x2F;答题）：

构造辅助函数：将待证式变形为 $f’(\xi) g(\xi) - f(\xi) g’(\xi) &#x3D; 0$，观察到左边是 $\left[ \frac{f(x)}{g(x)} \right]’$ 的分子（商的求导法则：$\left( \frac{f}{g} \right)’ &#x3D; \frac{f’g - fg’}{g^2}$），故令 $F(x) &#x3D; \frac{f(x)}{g(x)}$。
验证柯西中值定理条件：
连续性：$f(x)$ 连续、$g(x)$ 连续且不为零，故 $F(x) \in C[a,b]$；
可导性：商的求导法则，$F’(x) &#x3D; \frac{f’(x) g(x) - f(x) g’(x)}{g^2(x)}$，故 $F(x) \in D(a,b)$；
端点相等：$F(a) &#x3D; \frac{f(a)}{g(a)} &#x3D; 0$，$F(b) &#x3D; \frac{f(b)}{g(b)} &#x3D; 0$，即 $F(a) &#x3D; F(b)$。


应用定理：由罗尔定理（或柯西中值定理，因 $g(x)$ 满足条件），存在 $\xi \in (a,b)$ 使得 $F’(\xi) &#x3D; 0$，即 $f’(\xi) g(\xi) - f(\xi) g’(\xi) &#x3D; 0$，整理得 $f’(\xi) &#x3D; f(\xi) \cdot \frac{g’(\xi)}{g(\xi)}$。

关键技巧：柯西中值定理的核心是“构造商式辅助函数”，本质是解决“两个函数的增量比与导数比”的关系问题。
总结（便于笔记记忆）


定理
核心条件
核心结论
考研常用技巧



罗尔定理
连续、可导、端点值相等
$f’(\xi) &#x3D; 0$
构造辅助函数（乘积、加减）


拉格朗日定理
连续、可导
$f’(\xi) &#x3D; \frac{f(b)-f(a)}{b-a}$
增量公式、不等式证明


柯西定理
两函数连续、可导、$g(a) \neq g(b)$
$\frac{f(b)-f(a)}{g(b)-g(a)} &#x3D; \frac{f’(\xi)}{g’(\xi)}$
构造商式辅助函数


共性：三大中值定理均是“连续+可导”的核心条件，本质是建立函数增量与导数的联系，考研重点在于“辅助函数构造”和“定理嵌套使用”（如拉格朗日定理嵌套罗尔定理）。
泰勒公式和中值定理的联系泰勒公式与三大中值定理（罗尔、拉格朗日、柯西）本质是 “局部近似”与“区间中值”的递进关系——泰勒公式是中值定理的“高阶推广”，中值定理是泰勒公式的“低阶特例”，核心联系如下：
1. 拉格朗日中值定理是泰勒公式的1阶特例泰勒公式（带拉格朗日余项）的一般形式：$f(x) &#x3D; f(x_0) + f’(x_0)(x - x_0) + \frac{f’’(x_0)}{2!}(x - x_0)^2 + \dots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n(x)$其中拉格朗日余项 $R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - x_0)^{n+1}$（$\xi$ 在 $x_0$ 与 $x$ 之间）。
当取 $n&#x3D;0$ 时（0阶泰勒公式）：$f(x) &#x3D; f(x_0) + f’(\xi)(x - x_0)$令 $x &#x3D; b$、$x_0 &#x3D; a$，即得拉格朗日中值定理：$f(b) - f(a) &#x3D; f’(\xi)(b - a)$。
2. 罗尔定理是泰勒公式的“特殊推论”对1阶泰勒公式，若 $f(a) &#x3D; f(b)$，则：$f(b) &#x3D; f(a) + f’(a)(b - a) + \frac{f’’(\xi)}{2!}(b - a)^2$因 $f(a) &#x3D; f(b)$，整理得 $f’(a) + \frac{f’’(\xi)}{2!}(b - a) &#x3D; 0$——但更直接的逻辑是：罗尔定理是证明泰勒公式余项的“基础工具”（证明泰勒余项时，常构造辅助函数，对其应用罗尔定理推导余项形式）。
3. 柯西中值定理与泰勒公式的“互补关系”
柯西中值定理聚焦 “两个函数的增量比与导数比”（解决比值型问题）；
泰勒公式聚焦 “单个函数的高阶近似”（解决精度要求高的问题，如极限计算、不等式证明、高阶导数相关问题）。

但二者本质一致：均依赖“函数连续可导”的条件，均通过“中值 $\xi$”建立函数与导数的联系，且柯西中值定理可作为证明泰勒公式的辅助工具（如推导柯西型余项时会用到）。
4. 核心共性：“中值思想”的统一无论是中值定理还是泰勒公式，核心都是 “在区间内存在一点 $\xi$，将函数的整体增量（或近似误差）用某阶导数表示”——中值定理是“1阶导数的整体关联”，泰勒公式是“多阶导数的局部近似”，前者是后者的简化，后者是前者的深化。
]]></content>
  </entry>
  <entry>
    <title>C语言程序设计基础(2025秋)</title>
    <url>/2025/11/29/SCU_C_Programming_2025_fall/</url>
    <content><![CDATA[我的课程笔记 - C语言程序设计（2025秋）🌟 SCU程序设计基础-软件(2025秋)总览这里汇总了 SCU程序设计基础-软件(2025秋) 的历次作业题目和我的个人解答，点击标题可进入对应内容页面：
必做
必做07 
必做08
必做09

选做
选做01
选做09



📌 说明：所有笔记持续更新，点击链接直接跳转到对应页面，返回总览可点击顶部导航栏的“SCU程序设计基础-软件(2025秋)总览”。

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/11/05/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯备赛笔记（全章节整理）</title>
    <url>/2025/12/15/lanqiaobei_notes/index/</url>
    <content><![CDATA[蓝桥杯备赛笔记（全章节整理）Hello 大家好！这是我的蓝桥杯算法竞赛备赛笔记，主要基于C&#x2F;C++语言，涵盖蓝桥杯省赛、国赛的核心考点，章节与实际学习文件夹一一对应，持续更新中~
如果觉得笔记对你有帮助，欢迎点赞、收藏~ 😜
📚 笔记目录


章节编号
章节名称
核心内容



01
第一章-语言基础
C++基础语法、数据类型、输入输出优化


02
第二章-算法基础
枚举、模拟、贪心等基础算法


03
第三章-搜索
深度优先搜索（DFS）、广度优先搜索（BFS）


04
第四章-动态规划
线性DP、背包问题、状态转移等


05
第五章-字符串
string操作、字符串匹配、哈希等


06
第六章-数学
数论、组合数学、高精度计算


07
第七章-数据结构
数组、栈、队列、链表、二叉树


08
第八章-图论
图的存储、最短路、最小生成树


09
第九章-计算几何
点、线、多边形相关计算


10
OJ部分习题及解答
经典真题、模拟题解析与代码实现



📖 章节内容01. 第一章-语言基础
对应笔记：第一章-语言基础

本章涵盖蓝桥杯备赛的核心语言基础：C++变量定义、数据类型（int&#x2F;long long&#x2F;string）、输入输出优化、循环与分支语句等，是后续算法实现的必备知识。
点击上方链接查看完整内容~
02. 第二章-算法基础
对应笔记：第二章-算法基础

本章讲解蓝桥杯高频基础算法：暴力枚举（如统计方形问题）、模拟法（日期&#x2F;字符串模拟）、贪心策略，附带真题案例与代码实现。
点击上方链接查看完整内容~
03. 第三章-搜索
对应笔记：第三章-搜索

本章覆盖DFS（深度优先搜索）、BFS（广度优先搜索）的基本框架、剪枝技巧，以及蓝桥杯常见的搜索类真题（如迷宫问题、全排列）。
点击上方链接查看完整内容~
04. 第四章-动态规划
对应笔记：第四章-动态规划

本章讲解动态规划的核心思想，包括线性DP（最长上升子序列）、背包问题（01背包、完全背包）、状态转移方程的推导，附带真题解析。
点击上方链接查看完整内容~
05. 第五章-字符串
对应笔记：第五章-字符串

本章涵盖C++ string类的常用操作（substr&#x2F;find&#x2F;compare）、字符串匹配（KMP算法）、哈希字符串等蓝桥杯高频考点。
点击上方链接查看完整内容~
06. 第六章-数学
对应笔记：第六章-数学

本章讲解数论（质数、约数、模运算）、组合数学（排列组合）、高精度计算（大整数加减乘除）等蓝桥杯数学类考点。
点击上方链接查看完整内容~
07. 第七章-数据结构
对应笔记：第七章-数据结构

本章覆盖数组、栈、队列、链表、二叉树的基本操作，以及蓝桥杯常考的数据结构应用（如栈的括号匹配、队列的广度优先搜索）。
点击上方链接查看完整内容~
08. 第八章-图论
对应笔记：第八章-图论

本章讲解图的存储方式（邻接矩阵&#x2F;邻接表）、最短路算法（Dijkstra、Floyd）、最小生成树（Kruskal、Prim）等图论核心考点。
点击上方链接查看完整内容~
09. 第九章-计算几何
对应笔记：第九章-计算几何

本章涵盖计算几何的基础问题：点与线的距离、线段相交判断、多边形面积计算等，是蓝桥杯进阶考点。
点击上方链接查看完整内容~
10. OJ部分习题及解答
对应笔记：OJ部分习题及解答

本章整理蓝桥杯历年真题、模拟题的详细解答，包含题目分析、代码实现、优化思路，帮助巩固知识点。
点击上方链接查看完整内容~
]]></content>
      <categories>
        <category>编程竞赛</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>备赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>翁恺C语言学习笔记</title>
    <url>/2025/11/05/%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[这是我学习C语言的笔记
1.1第一个C语言程序 #include&lt;stdio.h&gt;int main()&#123;printf(&quot;hello world!\n&quot;);return 0;  &#125;

程序框架
#include &lt;stdio.h&gt; int main() {
return 0;  

 }

1.2做点计算#include &lt;stdio.h&gt;int main()&#123;printf(&quot;%d&quot;,12+34);return 0;&#125;

1.2.2四则运算


四则运算
C符号
意义



+
+
加


-
-
减


×
*
乘


÷
&#x2F;
除



%
取余



2.1变量#include&lt;stdio.h&gt;int main()&#123;int price = 0;printf(&quot;请输入金额（元)：&quot;);scanf(&quot;%d&quot;,&amp;price);int change = 100 - price;printf(&quot;找您%d元。\n&quot;,change);return 0;&#125;


注意使用visual studio时，此处scanf需使用scanf_s

2.1.1变量定义
&lt;类型名称&gt;&lt;变量名称&gt;
int price;
int amount;
int price,amount;
变量的名字即标识符，标识符只能由数字，字母下划线组成，且数字不可以出现在第一个位置.



2.1.2赋值和初始化
int price &#x3D; 0；
这一行，定义了一个变量，变量的名字是price，类型是int，初始值是0
int price &#x3D; 0,amount &#x3D; 0;
左值必须是变量
变量和被赋的值（右值）类型应该相同

读整数
scanf(“%d”,&amp;price);
scanf()里的都是要输入的，必须满足每一项。

常量
我们称之为直接量(literal)
定义一个常量
const int AMOUNT &#x3D; 100




一般对一个const变量是全大写的，来强调它的只读性。

int a;int b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);printf(&quot;%d + %d = %d\n&quot;,a,b,a+b);

浮点数
两个整数的运算结果只能是整数
10和10.0在C中是完全不同的数

printf(&quot;请分别输入身高的英尺和英寸,&quot;&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;);int foot;int inch;scanf(&quot;%d %d&quot;,&amp;foot,&amp;inch);printf(&quot;身高是%f米。\n&quot;,((foot + inch/12.0)*0.3048));


double是双精度浮点数，上面的程序也可以这样写

printf(&quot;请分别输入身高的英尺和英寸,&quot;&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;);double foot;double inch;scanf(&quot;%lf %lf&quot;,&amp;foot,&amp;inch);printf(&quot;身高是%f米。\n&quot;,((foot + inch/12.0)*0.3048));


浮点数输出用%d,输入用%lf

表达式
一个表达式由运算符和算子组成
下面给一个计算时间差的程序

#include &lt;stdio.h&gt;int main()&#123; int hour1,minute1; int hour2,minute2; scanf(&quot;%d %d&quot;,&amp;hour1,&amp;minute1); scanf(&quot;%d %d&quot;,&amp;hour2,&amp;minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t2 - t1; printf(&quot;时间差是%d小时%d分。&quot;,t/60,t%60); return 0;&#125;

求平均值int a,b;scanf(&quot;%d %d&quot;,&amp;a,&amp;b);double c = (a+b)/2.0;printf(&quot;%d和%d的平均值=%f\n&quot;,a,b,c);


这引申出运算符优先级的概念，一般与数学运算相同，尤其注意的是_+,-在进行单目运算时优先级最高，即正负号，a*-b_

交换两个变量  int a = 5;int b = 6;int t;t = a;a = b;b = t;printf(&quot;a=%d,b=%d&quot;,a,b);

可以借用IDE的调试功能来观察如何进行交换，实际上就是要用一个临时变量来进行交换。

复合赋值
total +&#x3D; 5;
total &#x3D; total + 5;
注意两个运算符中间不要有空格
total *&#x3D; sum +12;
total &#x3D; total*(sum + 12);
都要先完成右边的运算

递增递减运算符
++，–是单目运算符，其效果是使变量+1或-1
注意其有前缀和后缀形式。
a++ &#x3D;10；
a &#x3D; 11;
++a &#x3D; 12;

条件判断int hour1,minute1;int hour2,minute2;scanf(&quot;%d %d&quot;,&amp;hour1,&amp;minute1);scanf(&quot;%d %d&quot;,&amp;hour2,&amp;minute2);int ih = hour2 - hour1;int im = minute2 - minute1;if (im &lt; 0)&#123;im = 60 + im;ih --;&#125; printf(&quot;时间差是%d小时%d分钟\n&quot;,ih,im);


关系运算符


运算符
意义



&#x3D;&#x3D;
相等


！&#x3D;
不相等


&gt;
大于


&lt;
小于


&gt;&#x3D;
大于或等于


&lt;&#x3D;
小于或等于



可以用printf(&quot;%d\n&quot;,5&gt;3)这样的代码来判断，输出1表示正确，0表示错误。且判断是否相等的优先级比其他的低，从左到右进行判断。

找零计算器//初始化int price = 0;int bill = 0;//读入金额和票面printf(&quot;请输入金额：&quot;);scanf(&quot;%d&quot;,&amp;price);printf(&quot;请输入金额：&quot;);scanf(&quot;%d&quot;,&amp;bill);//计算找零printf(&quot;应该找您：%d\n&quot;,bill - price);


注释可以用&#x2F;&#x2F;来开始（单行注释）也可以有/*  */用于多行注释和行内注释

if (bill&gt;= price)&#123;printf(&quot;应该找您：%d\n&quot;,bill - price);&#125;

不够怎么办if(bill&gt;= price)&#123;printf(&quot;应该找您：%d\n&quot;,bill - price);&#125;else&#123;printf(&quot;你的钱不够\n&quot;);&#125;


给出一个关于比较a和b的问题

方案一
int a,b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);int max = 0;if(a&gt;b)&#123; max = a;&#125;else&#123;max = b;&#125;printf(&quot;大的那个是%d\n&quot;,max);
方案二
int max = b;if(a&gt;b)&#123;max = a;&#125;

再探if语句if()后面可以不加大括号，那么紧接着的一行就是要执行的。else也相同。

下面给出一个例子，（计算工资）

const double RATE = 8.25;const int STANDARD = 40;double pay = 0.0;int hours;printf(&quot;请输入工作小时数:&quot;);scanf(&quot;%d&quot;,&amp;hours);printf(&quot;\n&quot;);if(hours &gt;STANDARD)pay = STANDARD*RATE+(hours - STANDARD)*(RATE*1.5);elsepay = hours*RATE;printf(&quot;应付工资：%f\n&quot;,pay);

嵌套if语句int a,b,c;scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);int max = 0;if(a&gt;b)&#123;if(a&gt;c)&#123;max = a;&#125;else&#123;max = c;&#125;&#125;else&#123;if(b&gt;c)&#123;max = b;&#125;else&#123;max = c;&#125;&#125;printf(&quot;The max is %d\n&quot;,max);

级联的if elseint f;if(x &lt; 0)&#123;  f = 1;&#125;else if(x == 0)&#123;  f = 0;&#125;else&#123;  f = 2 * x;&#125;printf(&quot;%d&quot;,f);

同时int f放在前面。即单一出口会更有效率。

switch case语句
为了提高运行效率，级联的if else可以用此替换

int type;scanf(&quot;%d&quot;,&amp;type);switch(type)&#123;	case 1:	printf(&quot;hello&quot;);	break;	case 2:	printf(&quot;okay&quot;);	break;	default:	printf(&quot;nothing correct&quot;);	break;&#125;


case只是一个入口，并不分隔，起分隔作用的是break且type位置只能是int类型case 后面必须是常量

循环
while循环

int x;int n = 0;scanf(&quot;%d&quot;,&amp;x);//下面两行是为了0的一位，因为0无法循环。n++;x /= 10;while(x &gt; 0)&#123;	n++;	x /= 10;&#125;printf(&quot;%d\n&quot;,n);

do while循环
进入循环时不做检查，在执行完一轮循环体代码之后再检查条件是否满足，满足则继续，不满足则结束循环。

int x;scanf(&quot;%d&quot;,&amp;x);int n = 0;do&#123;	x /= 10;	n++;&#125;while(x &gt; 0);printf(&quot;%d&quot;,n);

猜数游戏
要由计算机想一个随机数

#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123;	srand(time(0));	int number = rand()%100 + 1;	//那么由于随机数太大了，可以用%（取余），来得到多少位以内的数。	int count = 0;	int a = 0;	printf(&quot;我已经想好了一个1到100之间的整数。&quot;);	do&#123;		printf(&quot;请猜这个数:&quot;);		scanf(&quot;%d&quot;,&amp;a);		count ++;		if(a &gt; number)&#123;			printf(&quot;你猜的数大了&quot;);		&#125;else if(a &lt; number)&#123;			printf(&quot;你猜的数小了&quot;);		&#125;	&#125;while(a != number);	printf(&quot;太好了，你用了%d次就猜到了答案。\n&quot;,count);	return 0;&#125;

算平均数#include &lt;stdio.h&gt;int main()&#123;	int number;	int sum = 0;	int count =0;	scanf(&quot;%d&quot;,&amp;number);	while(number != -1)	&#123;		sum += number;		count++;		scanf(&quot;%d&quot;,&amp;number);	&#125;	printf(&quot;%f\n&quot;,1.0*sum/count);	return 0;&#125;

整数的分解
对一个整数做%10的操作，就得到了它的个位数；
对其做&#x2F;10的操作，就去掉了它的个位数；
然后再对2的结果做%10就得到了原来数的十位数。


下面给出一个整数逆序的代码

#include &lt;stdio.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	int digit;	int ret = 0;	while(x&gt;0)	&#123;		digit = x%10;		ret = ret*10 + digit;		x /= 10;		//可以给出调试结果		printf(&quot;x=%d,digit=%d,ret=%d\n&quot;,x,digit,ret);	&#125;	printf(&quot;%d&quot;,ret);	return 0;&#125;


那么注意，这样输出的是一个整数，如果想要输入700输出007可以做细微改动（实际上是更容易了）

//ret这个变量就不需要了。while(x&gt;0)&#123;	digit = x%10;	printf(&quot;%d&quot;,digit);	x /= 10;&#125;

阶乘#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int fact = 1;	int i =1;	while(i &lt;= n)	&#123;		fact *= i;		i++;	&#125;	printf(&quot;%d!=%d\n&quot;,n,fact);	return 0;&#125;


下面用for循环来写一下

for(i = 1;i &lt;= n;i++)&#123;	fact *= i;&#125;


还有一个小套路，在求积的时候变量初始化为1，求和时变量初始化为0。

判断是否为素数#include &lt;stdio.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	int i;	int is_prime = 1;	for(i = 2;i &lt; x;i++)	&#123;		if(x%i ==0)		&#123;			is_prime = 0;			break;		&#125;	&#125;	if(is_prime == 1)	//改为i&lt;x即可省去中间变量	&#123;		printf(&quot;是素数\n&quot;);	&#125;else&#123;		printf(&quot;不是素数\n&quot;);	&#125;	return 0;&#125;


那么实际上需要break来结束循环，会减少时间。还有一个循环控制语句continue，会跳过循环剩下的语句。

for(i=2;i&lt;x;i++)&#123;	if(x%i == 0)	&#123;		is_prime = 0;		continue;	&#125;	printf(&quot;%d\n&quot;,i);&#125;


给出流程图，作为对比![[Pasted image 20251009165244.png]]

循环的嵌套
下面要输出1到100之间的素数

#include &lt;stdio.h&gt;int main()&#123;	int x;	for(x = 2;x &lt; 100;x++)	&#123;		int is_prime = 1;		int i;		for(i = 2;i &lt; x;i++)			&#123;				if(x%i ==0)				&#123;					is_prime = 0;					break;				&#125;			&#125;			if(is_prime == 1)			&#123;				printf(&quot;%d &quot;,x);			&#125;	&#125;	return 0;&#125;


若int is_prime = 1;在for循环外面，代码只在程序开始时初始化了一次is_prime = 1，但在判断完一个数是否为质数后，没有重新将其重置为 1。这会导致一旦发现某个非质数后，is_prime就一直保持 0，后续的质数也无法被正确识别。那么想要输出前五十个素数只需要进行一下修改

#include &lt;stdio.h&gt;int main()&#123;	int x;	int cnt = 0;	for(x = 2;cnt &lt; 50;x++)	&#123;		int is_prime = 1;		int i;		for(i = 2;i &lt; x;i++)			&#123;				if(x%i ==0)				&#123;					is_prime = 0;					break;				&#125;			&#125;			if(is_prime == 1)			&#123;				printf(&quot;%d &quot;,x);				cnt++;			&#125;	&#125;	return 0;&#125;

接力breakint x;int one,two,five;int exit = 0;scanf(&quot;%d&quot;,&amp;x);for(one = 1;one &lt; x*10;one++)&#123;	for(two =1;two &lt; x*10/2;two++)	&#123;		for(five =1;five&lt;x*10/5;five++)		&#123;			if(one + two*2 +five*5 == x*10)			&#123;				printf(&quot;可以用%d个一角加%d个二角加%d个五角得到%d元\n&quot;,one,two,five,x);				exit = 1;				break;			&#125;		&#125;		if(exit)break;	&#125;	if(exit)break;//对于if来说（）内只要不为0就可以&#125;


还有一个更为方便的方法goto

for(one = 1;one &lt; x*10;one++)&#123;	for(two =1;two &lt; x*10/2;two++)	&#123;		for(five =1;five&lt;x*10/5;five++)		&#123;			if(one + two*2 +five*5 == x*10)			&#123;				printf(&quot;可以用%d个一角加%d个二角加%d个五角得到%d元\n&quot;,one,two,five,x);				exit = 1;				goto out;			&#125;		&#125;	&#125;&#125;out:


那么除了这种情况不建议使用goto

前n项求和int n;int i;double sum = 0.0;scanf(&quot;%d&quot;,&amp;n);for(i = 1;i&lt;=n;i++)&#123;	sum += 1.0/i;&#125;printf(&quot;f(%d)=%f&quot;,n,sum);


要实现加一个减一个，可以这样做

int n;int i;double sum = 0.0;double sgn = 1.0;scanf(&quot;%d&quot;,&amp;n);for(i = 1;i&lt;=n;i++)&#123;	sum += sgn/i;	sgn = -sgn;&#125;printf(&quot;f(%d)=%f&quot;,n,sum);

整数分解#include &lt;stdio.h&gt;//#include &lt;math.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	//引入一个新的变量t，不改变x	int t = x;	int mask = 1;	//不用t&gt;0是因为，那样会多循环一次，mask会多一位，同时为了实现下面几行同样的效果还可以	//int cnt = 0;	//do&#123;	//	x /= 10;	//	cnt++;	//&#125;while(x &gt; 0);	//int mask = pow(10,cnt - 1);	while(t&gt;9)	&#123;		t /= 10;		mask *= 10;	&#125;	do&#123;		int d = x/mask;		printf(&quot;%d&quot;,d);		if(mask&gt;9)		&#123;			printf(&quot; &quot;);		&#125;		x %= mask;		mask /= 10;	&#125;while(mask &gt; 0);	printf(&quot;\n&quot;);	return 0;&#125;

最大公约数#include &lt;stdio.h&gt;int main()&#123;	int a,b;	scanf(&quot;%d %d&quot;,&amp;a,&amp;b);	int ret;	int i;	for(i = 1;i&lt;=a &amp;&amp; i &lt;= b;i++)	&#123;		if(a%i == 0 &amp;&amp; b%i == 0)		ret = i;	&#125;	printf(&quot;%d和%d的最大公约数是%d&quot;,a,b,ret);	return 0;&#125;

下来介绍辗转相除法
如果b等于0，计算结束，a就是最大公约数
否则，计算a除以b的余数，让a等于b，让b等于那个余数
回到第一步

#include &lt;stdio.h&gt;int main()&#123;	int a,b;	int t;	scanf(&quot;%d %d&quot;,&amp;a,&amp;b);	while( b!= 0)	&#123;		t = a%b;		a = b;		b = t;	&#125;	printf(&quot;gcd=%d&quot;,a);	return 0;&#125;

习题课水仙花数#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int first = 1;	int i;	 &#125;


九九乘法表#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int i,j;	i = 1;	while(i&lt;=n)	&#123;		j = 1;		while(j &lt;= i)		&#123;			printf(&quot;%d*%d=%d&quot;,j,i,i*j);			if(i*j &lt; 9)			&#123;				printf(&quot;   &quot;);			&#125;else&#123;				printf(&quot;  &quot;);			&#125;			j++;		&#125;		printf(&quot;\n&quot;);		i++;	&#125;	return 0;	&#125;


可以用printf(&quot;%d*%d=%-4d&quot;,j,i,i*j);会更加简洁，且确保每个表达式占固定宽度。

数据类型
sizeof可以得到不同变量在内存中占用的字节的大小。
且sizeof是一个静态运算符，并不会实际运算里面的代码。

int a;a = 6;printf(&quot;sizeof(a++)=%ld\n&quot;,sizeof(a));print(&quot;sizeof(a+1.0)=%ld\n&quot;,sizeof(a + 1.0));

输出结果如下
sizeof(a++)=4sizeof(a+1.0)=8

原因在于变量a是一个int类型的变量，占4个字节+1.0后会变成一个浮点数，占8个字节

以下是C语言中常见数据类型在32位和64位系统中占用字节数的表格：



数据类型
32位系统
64位系统



char
1字节
1字节


short
2字节
2字节


int
4字节
4字节


long
4字节
8字节


long long
8字节
8字节


float
4字节
4字节


double
8字节
8字节


long double
10或16字节
16字节


指针
4字节
8字节


整数的内部表达
计算机内部一切都是二进制
18 00010010
0   00000000
-18


一个字节可以表达的数
0000000 -  11111111（255）
三种方案
仿照十进制，用一个特殊标志表示负数
取中间的数为0,1000000表示0，比他小的是负数，比他大的是正数
补码
-1 &#x3D; （1）00000000 - 00000001  -&gt; 11111111
在纯二进制时，11111111是255，在补码中是-1


char: -128~127
short: -32768~32767


要把该数（11111111）当做纯二进制数，需加unsigned也可以像255u这样字面量常数后加u或U

整数的输入输出
只有两种形式：int 或long long
%d  int
%u  unsigned
%ld long long
%lu unsigned long long


输入八进制在前面加上0，十六进制在前面加上0x
输出时%o和%x，但是这样不会输出前面的0和0x



浮点类型
float  和  double，但是这两个的范围![[Pasted image 20251013095853.png]]

输入输出


类型
scanf
printf



float
%f
%f,%e


double
%lf
%f,%e



输出用%e可以输出科学计数法的结果

1e-10,即1^(-10)
输出精度
在%和f之间加上.n是可以指定输出小数点后几位，这样的输出是做四舍五入的
在计算机里面是无法准确的表达一个数的

#include &lt;stdio.h&gt;int main()&#123;	printf(&quot;%.30f&quot;,0.0049);	return 0;&#125;

运行结果如下
0.004899999999999999841793218991

超过范围的浮点数
printf输出inf表示超过范围的浮点数：$\infty$
输出nan就表示不存在

浮点数的运算精度#include &lt;stdio.h&gt;int main()&#123;	float a,b,c;	a = 1.345;	b = 1.123;	c = a + b;	if(c == 2.468)	&#123;		printf(&quot;相等&quot;);	&#125;else	&#123;		printf(&quot;不相等！c=%.10f,或%f\n&quot;,c,c);	&#125;	return 0;&#125;
运行结果如下
不相等！c=2.4679999352,或2.468000


float需要用f或F后缀来表明身份，不加的话是double


f1 &#x3D;&#x3D; f2 可能失败
fabs（f1 - f2）&lt; 1e - 12(1e - 8一般就可以了)
fabs()是用来求绝对值的。



浮点数的内部表达![[Pasted image 20251013104911.png]]
字符类型
char是一种整数，也是字符
‘a’用单变量来表示，’ ‘也是一个字符
用%c来做输入输出
scanf(&quot;%c&quot;,&amp;c);—&gt; 1
scanf(&quot;%d&quot;,&amp;i);—&gt; 49
‘1’的ASCII编码是49，所以当c &#x3D;&#x3D; 49时，它代表’1’

逃逸字符


字符
意义
字符
意义



\b
回退一格
\“
双引号


\t
到下一个表格位
\‘
单引号


\n
换行
\\
反斜杠本身


\r
回车




类型转换自动类型转换
运算符两边出现不一致的类型时，会自动转换成较大的类型
大的意思是能表达的数的范围更大


char–&gt;short–&gt;int–&gt;long–&gt;long long
int–&gt;float–&gt;double
对于printf任何小于int的类型会被转换成int；float会转换成double但是scanf不会，要输入short，需要%hd



强制类型转换
（类型）值
比如
（int）2.0



逻辑类型bool
#include &lt;stdbool.h&gt;
之后就可以使用bool和true,false

逻辑运算
结果只有0和1




运算符
描述
示例



！
非
!a


&amp;&amp;
与
a &amp;&amp; b


||
或
a || b


条件运算符
count = (count&gt;20)?count-10:count+10;
相当于

if(count&gt;20)count -= 10;elsecount += 10;


逗号也是一个运算符需要注意的是，逗号运算符的优先级是 C 语言中最低的，因此在需要确保其运算顺序时，通常需要用括号括起来。

在for循环中，逗号运算符常用于初始化或更新多个变量，使代码更简洁：
for (int i = 0, j = 10; i &lt; j; i++, j--) &#123; 	printf(&quot;i=%d, j=%d\n&quot;, i, j); &#125;

函数函数的定义和使用void sum(int begin,int end)&#123;	int i;	int sum = 0;	for(i=begin;i&lt;=end;i++)	&#123;		sum += i;	&#125;	printf(&quot;%d到%d的和是%d\n&quot;,begin,end,sum);&#125;


返回类型 函数名（参数表）&#x2F;&#x2F;函数头{语句	}&#x2F;&#x2F;函数体


(起到了表示函数调用的作用，没有参数也需要，如果有参数则需要给出正确的数量和顺序)

从函数中返回值
return停止函数的执行，并送回一个值
return；
return 表达式；

函数先后关系
一般会把函数写在上面，一般而言C的编译器会自上而下的编译程序


C在调用函数的时候，永远只能传值给函数原因在于每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系

本地变量
函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量
定义在函数内部的变量和参数就是本地变量
定义在块内（就是大括号内）它的生存期只在块内
在不同的块内可以定义同名的变量

函数小知识没有参数时
void f(void)
void f()
在传统C中，它表示f函数的参数表未知，并不表示没有参数


因此一定要完整书写函数声明

逗号运算符
f(a,b)
f((a,b))
调用函数时的圆括号里的逗号是标点符号，不是运算符，但是加上括号就会先运算括号内的结果




C语言中不允许函数的嵌套定义

数组给一个情景引入，要输出一串数中大于这组数平均数的数
#include &lt;stdio.h&gt;int main(void)&#123;	int x;	double sum = 0;	int cnt = 0;	//定义数组	int number[100];	scanf(&quot;%d&quot;,&amp;x);	while(x!= -1)	&#123;	//对数组中的元素赋值		number[cnt] = x;		sum += x;		cnt++;		scanf(&quot;%d&quot;,&amp;x);	&#125;	if(cnt &gt; 0)	&#123;		int i;		double aver = sum/cnt;		for(i=0;i&lt;cnt;i++)		&#123;		//使用数组中的元素			if(number[i]&gt;aver)			&#123;				printf(&quot;%d&quot;,number[i]);			&#125;		&#125;	&#125;	return 0;&#125;

定义数组
&lt;类型&gt; 变量名称[元素数量]；
int grades[100];
double weight[20];


元素数量必须是整数
C99之前：元素数量必须是编译时刻确定的字面量

数组
是一种容器
其中所有的元素具有相同的数据类型；
一旦创建，不能改变大小
数组中的元素在内存中是连续依次排列的



数组的单元
使用数组时放在[ ]中的数字叫做下标或索引，从0开始计数

有效的下标范围
编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写
一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃
segmentation fault


但是也可能运气好，没有造成严重后果


下面给一个测试程序

#include&lt;stdio.h&gt;void f();int main()&#123;	f();	return 0;&#125;void f()&#123;	int a[10];	a[10] = 0;&#125;

经过运行，在VScode中没有报错。devcpp中也没有报错
数组的例子-统计个数
写一个程序，输入数量不确定的[0,9]范围内的整数，统计每一种数字出现的次数，输入-1表示结束。

#include &lt;stdio.h&gt;int main(void)&#123;	const int num = 10;	int x;	int cnt[num];	int i;	for(i=0;i&lt;num;i++)	&#123;		cnt[i] = 0;	&#125;	scanf(&quot;%d&quot;,&amp;x);	while(x != -1)	&#123;		if(x&gt;=0 &amp;&amp; x&lt;=9)		&#123;			cnt[x]++;		&#125;		scanf(&quot;%d&quot;,&amp;x);	&#125;	for(i = 0;i&lt;num;i++)	&#123;		printf(&quot;%d:%d\n&quot;,i,cnt[i]);	&#125;	return 0;&#125;

数组运算数组的集成初始化int a[] = &#123;2,4,5,6,7,8,9,11&#125;;


集成初始化时的定位int a[10] = { [0] = 2,[2] = 3,6,}用[n]在初始化数据中给出定位没有定位的数据接在前面的位置的后面其他位置的值补0也可以不给出数组大小特别适合初始数据稀疏的数组

数组的大小
sizeof给出整个数组所占据的内容的大小，单位是字节
sizeof(a)/sizeof(a[0])

数组的赋值
数组变量本身不能被赋值
要把一个数组的所有元素交给另一个数组，必须采用遍历

for(i=0;i&lt;length;i++)&#123;	b[i] = a[i];&#125;

遍历数组
***通常使用for循环，让循环变量i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标


***有一个常见错误，离开循环后，继续用i的值来做数组的下标


用数组作为函数参数时，往往必须再用另一个参数来传入数组的大小
而且不能在[]中给出数组的大小
不能再利用sizeof来计算数组的元素个数

数组例子从判断素数讲起
最原始的int is_prime(int x)&#123;	int ret = 1;	int i;	if(x == 1||(x%2 == 0 &amp;&amp; x != 2))	&#123;		ret = 0;	&#125;	for(i=3;i&lt;x;i++)&#123;		if(x%i == 0)&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;

时间复杂度O(n)

优化后的#include &lt;math.h&gt;int is_prime(int x)&#123;	int ret = 1;	int i;	if(x == 1||(x%2 == 0 &amp;&amp; x != 2))	&#123;		ret = 0;	&#125;	for(i=3;i&lt;sqrt(x);i++)&#123;		if(x%i == 0)&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;

时间复杂度O($\sqrt{n}$)

使用数组#include &lt;stdio.h&gt;#define number 100int is_prime(int x,int knownPrimes[],int number0fknownPrimes)&#123;	int ret = 1;	int i;	for(i=0;i&lt;number0fknownPrimes;i++)	&#123;		if(x%knownPrimes[i]==0)		&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;int main(void)&#123;	int prime[number] = &#123;2&#125;;	int cnt =1;	int i = 3;	while(cnt&lt;number)	&#123;		if(is_prime(i,prime,cnt))		&#123;			prime[cnt++] = i;			&#125;		i++;	&#125;	for(i=0;i&lt;number;i++)	&#123;		printf(&quot;%d&quot;,prime[i]);		if((i+1)%5) printf(&quot;\t&quot;);		else printf(&quot;\n&quot;);	&#125;	return 0;&#125;

运行结果如下
2       3       5       7       1113      17      19      23      2931      37      41      43      4753      59      61      67      7173      79      83      89      97101     103     107     109     113127     131     137     139     149151     157     163     167     173179     181     191     193     197199     211     223     227     229233     239     241     251     257263     269     271     277     281283     293     307     311     313317     331     337     347     349353     359     367     373     379383     389     397     401     409419     421     431     433     439443     449     457     461     463467     479     487     491     499503     509     521     523     541

构造素数表
预构造n以内的素数表
令x为2
将2x，3x，4x，直到ax&lt;n的数标记为非素数
令x为下一个没有被标记为非素数的数，重复2；直到所有的数都已经尝试完毕



埃拉托斯特尼筛法（Sieve of Eratosthenes）：构造n以内的素数表你描述的方法是埃拉托斯特尼筛法——高效构造“n以内所有素数”的经典算法，核心思想是“通过标记每个素数的倍数来排除合数”，时间复杂度（$O(n \log \log n)$）远低于“逐个判断素数”的方法（$O(n\sqrt{n})$）。以下是算法逻辑拆解、完整代码实现及关键细节解析。
一、算法核心逻辑（对应你的步骤）你的描述已覆盖筛法本质，补充细节后更便于代码实现：

初始化“筛子”创建长度为n+1的“标记数组”（如is_prime[]），用于标记每个数是否为素数：

初始默认所有数为素数（标记为1或true）；
特殊处理：0和1不是素数，提前标记为非素数（0或false）。


筛选合数（对应你的步骤2）  

从第一个素数x=2开始；
标记x的所有倍数（2x, 3x, 4x, ...）为非素数，但从x*x开始标记更高效（原因：2x~(x-1)x已被更小的素数标记过，无需重复处理）。


迭代筛选（对应你的步骤3）  

让x指向“下一个未被标记为非素数的数”（即下一个素数）；
重复步骤2，直到x*x &gt; n（此时所有合数已被比x小的素数标记，无需继续）。


提取结果遍历标记数组，所有仍标记为1的索引（即数本身），就是n以内的所有素数。


二、完整代码实现（以“构造100以内素数表”为例）用C语言实现筛法，包含“初始化→筛选→输出”全流程，关键步骤添加注释：
#include &lt;stdio.h&gt;#include &lt;string.h&gt;  // 用于memset函数（快速初始化数组）/** * @brief 用埃拉托斯特尼筛法构造max_num以内的素数表并输出 * @param max_num 素数表的上限（即构造“0~max_num”范围内的素数） */void sieve_of_eratosthenes(int max_num) &#123;    // 1. 初始化标记数组：is_prime[i] = 1 表示i是素数，0表示合数    int is_prime[max_num + 1];  // 数组索引覆盖0~max_num（共max_num+1个元素）        // 快速初始化：用memset将所有元素设为1（默认是素数）    // memset按字节赋值，int占4字节时，1的二进制为0x00000001，赋值后每个int元素为1    memset(is_prime, 1, sizeof(is_prime));        // 特殊处理：0和1不是素数，标记为0    is_prime[0] = 0;    is_prime[1] = 0;    // 2. 核心筛选逻辑：x从2开始，直到x*x &gt; max_num（所有合数已被标记）    for (int x = 2; x * x &lt;= max_num; x++) &#123;        // 若x未被标记为合数（即x是素数），则标记其倍数为合数        if (is_prime[x] == 1) &#123;            // 优化：从x*x开始标记（避免重复标记2x~(x-1)x）            for (int multiple = x * x; multiple &lt;= max_num; multiple += x) &#123;                is_prime[multiple] = 0;  // 标记x的倍数为合数            &#125;        &#125;    &#125;    // 3. 输出max_num以内的所有素数（每5个换一行，格式清晰）    printf(&quot;%d以内的素数表：\n&quot;, max_num);    int count = 0;  // 计数，控制每5个素数换行    for (int i = 0; i &lt;= max_num; i++) &#123;        if (is_prime[i] == 1) &#123;  // 若i是素数，输出            printf(&quot;%d\t&quot;, i);            count++;            if (count % 5 == 0) &#123;  // 每5个素数换一行                printf(&quot;\n&quot;);            &#125;        &#125;    &#125;    printf(&quot;\n&quot;);&#125;int main(void) &#123;    int n = 100;  // 目标：构造100以内的素数表（可修改为任意正整数）    sieve_of_eratosthenes(n);  // 调用筛法函数    return 0;&#125;


三、代码关键细节解释1. 标记数组初始化：memset的使用
作用：快速将is_prime数组所有元素设为1，比for循环初始化更高效（memset是C标准库的内存操作函数，直接操作字节，速度更快）。
注意：memset按“字节”赋值，若int占4字节（大部分编译器），1的十六进制为0x00000001，因此赋值后每个int元素恰好为1，符合“默认是素数”的需求。

2. 筛选终止条件：x * x &lt;= max_num
为什么不写x &lt;= max_num？数学原理：若max_num有一个合数m，其最小质因数一定≤$\sqrt{m}$。当x &gt; \sqrt{max_num}时，m的最小质因数已在x ≤ \sqrt{max_num}时被处理，m早已被标记为合数，无需继续遍历。示例：max_num=100，$\sqrt{100}&#x3D;10$，当x=11时，11*11=121&gt;100，直接终止循环即可。

3. 倍数标记起点：x * x（而非2x）
优化逻辑：避免重复标记已处理的合数。示例：x=5时，2x=10（已被x=2标记）、3x=15（已被x=3标记），从x*x=25开始标记，仅需处理25, 30, 35, ..., 100，减少无效操作。

四、运行结果（100以内素数表）编译运行后，输出格式如下（每5个素数一行，便于阅读）：
100以内的素数表：2       3       5       7       1113      17      19      23      2931      37      41      43      4753      59      61      67      7173      79      83      89      97


五、扩展：筛法的适用场景与优化1. 适用场景埃拉托斯特尼筛法适合**“预构造较大范围（如10⁶以内）的素数表”**，例如：

数学题中频繁判断“某数是否为素数”；
密码学、数论相关场景中需要批量素数。

2. 针对超大n的优化（减少内存占用）若需构造10⁸以上的素数表，普通int数组会占用过多内存（如10⁸个int需400MB），可通过以下方式优化：

位数组（bit array）：每个数用1个二进制位标记（而非4字节的int），内存占用仅为原来的1&#x2F;32；
分段筛法（Segmented Sieve）：将大区间（如1~10⁹）分成多个小区间（如1~10⁴、10⁴+1~2×10⁴），逐个筛选，避免一次性占用大量内存。

六、使用说明若需调整素数表的范围，只需修改main函数中n的值（如n=200或n=1000），函数会自动生成对应范围的素数表，灵活性极高。
二维数组
int a[3][5];
通常理解为a是一个3行5列的矩阵
![[Pasted image 20251026171423.png]]

二维数组的遍历for(i=0;i&lt;3;i++)&#123;	for(j=0;j&lt;5;j++)&#123;		a[i][j] = i*j;	&#125;&#125;


a[i][j]是一个int
a[i,j]就等于a[j]
原因在于i,j是一个表达式，取j





二维数组的初始化int a[][5] = &#123;	&#123;0,1,2,3,4&#125;,	&#123;2,3,4,5,6&#125;,&#125;;


列数必须给出
每行一个{}，逗号分隔
最后的逗号可以存在
如果省略，表示补零
也可以用定位

读入矩阵
 3x3 井字棋（ Tic-Tac-Toe ）的获胜检查逻辑

const int size = 3;int board[size][size];int i,j;int numOfX;int numOfO;int result = -1;//-1:没人赢；1:X赢;0:O赢//读入矩阵for(i=0;i&lt;size;i++)&#123;	for(j=0;j&lt;size;j++)&#123;		scanf(&quot;%d&quot;,&amp;board[i][j]);	&#125;&#125;//检查行for(i=0;i&lt;size &amp;&amp; result ==-1;i++)&#123;	numOfO = numOfX = 0;	for(j=0;j&lt;size;j++)&#123;		if(board[i][j] == 1)&#123;			numOfX ++;		&#125;else&#123;			numOfO ++;		&#125;	&#125;	if(numOfO == size)&#123;		result = 0;	&#125;else if(numOfX == size)&#123;		result = 1;	&#125;&#125;//检查列if(result == -1)&#123;	for(j=0;j&lt;size &amp;&amp; result == -1;j++)&#123;		numOfO = numOfX = 0;		for(i=0;i&lt;size;i++)&#123;			if(board[i][j] == 1)&#123;				numOfX ++;			&#125;else&#123;				numOfO ++;			&#125;		&#125;		if(numOfO == size)&#123;			result = 0;		&#125;else if(numOfX == size)&#123;			result = 1;		&#125;	&#125;&#125;// 检查对角线（主对角线 + 副对角线）if(result == -1)&#123; // 仅当之前未检测到获胜者时才检查    // 1. 检查主对角线（左上 → 右下：i == j，如 (0,0)、(1,1)、(2,2)）    numOfO = numOfX = 0; // 重置计数    for(i = 0; i &lt; size; i++)&#123;        if(board[i][i] == 1)&#123; // 当前位置是X（用1表示）            numOfX++;        &#125; else &#123; // 当前位置是O（用非1表示，如0）            numOfO++;        &#125;    &#125;    // 判断主对角线是否获胜    if(numOfO == size)&#123;        result = 0; // O赢    &#125; else if(numOfX == size)&#123;        result = 1; // X赢    &#125;    // 2. 检查副对角线（右上 → 左下：i + j == size-1，如 (0,2)、(1,1)、(2,0)）    if(result == -1)&#123; // 主对角线未分胜负时，再检查副对角线        numOfO = numOfX = 0; // 重置计数        for(i = 0; i &lt; size; i++)&#123;            // 副对角线列号 = size-1 - 行号（如i=0时j=2，i=1时j=1，i=2时j=0）            if(board[i][size - 1 - i] == 1)&#123;                numOfX++;            &#125; else &#123;                numOfO++;            &#125;        &#125;        // 判断副对角线是否获胜        if(numOfO == size)&#123;            result = 0; // O赢        &#125; else if(numOfX == size)&#123;            numOfX = size;            result = 1; // X赢        &#125;    &#125;&#125;// （可选）输出结果，验证逻辑正确性if(result == 1)&#123;    printf(&quot;X赢\n&quot;);&#125; else if(result == 0)&#123;    printf(&quot;O赢\n&quot;);&#125; else &#123;    printf(&quot;没人赢\n&quot;);&#125;

取地址运算
运算符&amp;
scanf(&quot;%d&quot;,&amp;i)里的&amp;
获取变量的地址，它的操作数必须是变量
int i;printf(&quot;0x%x\n&quot;,&amp;i);
这样输出实际上会得到i的地址



#include &lt;stdio.h&gt;int main(void)&#123;	int i = 0;	int p;	p = (int)&amp;i;	printf(&quot;0x%x\n&quot;,p);	printf(&quot;%p\n&quot;,&amp;i);		return 0;&#125;

运行结果如下
0x5ffe7800000000005ffe78


&amp;不能对没有地址的东西取地址&amp;(a+b)

下来试一试数组
#include &lt;stdio.h&gt;int main(void)&#123;	int a[10];	printf(&quot;%p\n&quot;,&amp;a);	printf(&quot;%p\n&quot;,a);	printf(&quot;%p\n&quot;,&amp;a[0]);	printf(&quot;%p\n&quot;,&amp;a[1]);	return 0;&#125;

运行结果如下
00000000005ffe5000000000005ffe5000000000005ffe5000000000005ffe54

指针
就是保存地址的变量int i;int* p = &amp;i;int* p,q;int *p,q;

三四行表示的是一个意思*p是一个指针，而q是一个int


void f(int *p);

在被调用的时候得到了某个变量的地址
int i=0;f(&amp;i);


在函数里面可以通过这个指针访问外面的这个i

*是一个单目运算符，用来访问指针的值所表示的地址上的变量

可以做右值也可以做左值

int k = *p;
*p = k+1;



int i = 6;int *p = &amp;i;printf(&quot;p=%d\n&quot;,p);printf(&quot;*p=%d\n&quot;,*p);

运行结果如下
p=6291060*p=6

那么再看
*p = 26;printf(&quot;%d\n&quot;,i);

结果如下
i=26

传入地址
int i;scanf(&quot;%d&quot;,i)没有报错
原因在于传入地址和传入一个整数是一样大的，这样的话，读进来的数没有被写到i那里，而是一个别的地方

指针应用场景交换两个变量的值#include &lt;stdio.h&gt;void swap(int *pa,int *pb);int main(void)&#123;	int a = 5;	int b = 6;	swap(&amp;a,&amp;b);	printf(&quot;a=%d,b=%d&quot;,a,b);	return 0;&#125;void swap(int *pa,int *pb)&#123;	int t = *pa;	*pa = *pb;	*pb = t;&#125;

#include&lt;stdio.h&gt;void maxmin(int a[],int len,int *max,int *min);int main(void)&#123;    int a[] = 1,2,3,4,5,6,7,8,9,12,13,14,15,16,17,21,23,55,&#125;;    int min,max;    maxmin(a,sizeof(a)/sizeof(a[0]),&amp;max,&amp;min);    printf(&quot;max=%d,min=%d\n&quot;,max,min);    return 0;&#125;void maxmin(int a[],int len,int *max,int *min)&#123;    int i;    *max = *min = a[0];    for(i=0;i&lt;len;i++)&#123;        if(a[i]&lt;*min)&#123;            *min = a[i];        &#125;        if(a[i]&gt;*max)&#123;            *max = a[i];        &#125;    &#125;&#125;


要输出的值不止一个，就用指针变量，让函数把对应的值填入对应的地址

应用场景二
函数返回运算的状态，结果通过指针返回
常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错
-1或0（在文件操作有很多例子）


但是当任何数值都是有效的可能结果是，就得分开返回了
后续的语言（C++，Java）采用了异常机制来解决这个问题



#include&lt;stdio.h&gt;int divide(int a,int b,int *result);int main(void)&#123;    int a = 5;    int b = 2;    int c;    if(divide(a,b,&amp;c))&#123;        printf(&quot;%d/%d=%d\n&quot;,a,b,c);    &#125;    return 0;&#125;int divide(int a,int b,int *result)&#123;    int ret = 1;    if(b == 0)&#123;        ret = 0;    &#125;else&#123;        *result = a/b;    &#125;    return ret;&#125;

没有得到实际地址之前，不可以用指针访问任何数据
指针与数组
函数参数部分的数组实际上传入的是指针
sizeof(a) == sizeof(int*)
但是可以用数组的运算符[]进行运算



数组变量是特殊的指针

数组变量本身表达地址
int a[10];int *p = a;&#x2F;&#x2F;无需用&amp;取地址
但是数组的单元表达的是变量，需要用&amp;取地址
a == &amp;a[0]


[]运算符可以对数组做，也可以对指针做
p[0]&lt;==&gt;a[0]


*运算符可以对指针做，也可以对数组做
*a = 24;


数组变量是const的指针，所以不能被赋值
int b[] --&gt; int * const b;



指针与const指针是const
表示一旦得到了某个变量的地址，不能指向其他变量
int * const q = &amp;i;
*q = 26&#x2F;&#x2F;OK
q++&#x2F;&#x2F;ERROR



所指是const
表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）
const int *p = &amp;i;
*p = 26;&#x2F;&#x2F;ERROR!*p是const



转换
总是可以把一个非const的值转换成const的

void f(const int *x);int a = 15;f(&amp;a);//okconst int b = a;f(&amp;b);//okb = a + 1;//Error

const数组
const int a[] = {1,2,3,3,4,5};
数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int
所以必须通过初始化进行赋值

保护数组值
为了保证数组不被函数破坏，可以设置参数为const
int sum(const int a[],int len);



数组运算 给个例子 #include &lt;stdio.h&gt;int main(void)&#123; char ac[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; char *p = ac; printf(&quot;p=%p\n&quot;,p); printf(&quot;p+1=%p\n&quot;,p+1); int ai[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int *q = ai; printf(&quot;q=%p\n&quot;,q); printf(&quot;q+1=%p\n&quot;,q+1);  return 0;&#125;
运行结果如下
p=00000000005ffe66p+1=00000000005ffe67q=00000000005ffe30q+1=00000000005ffe34


由此可见，给指针加1并不是给地址值加一，而是给地址值加一个sizeof(type),如果指针是char就加一，是int就加4


给指针加一实际上是指向下一个变量
+ += - -= ++ --都可以
两个指针也可以相减



#include &lt;stdio.h&gt;int main(void)&#123; char ac[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; char *p = ac; char *p1 = &amp;ac[5]; printf(&quot;p=%p\n&quot;,p); printf(&quot;p+1=%p\n&quot;,p+1); printf(&quot;p1-p=%d\n&quot;,p1-p); int ai[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int *q = ai; int *q1 = &amp;ai[6]; printf(&quot;q=%p\n&quot;,q); printf(&quot;q+1=%p\n&quot;,q+1); printf(&quot;q1-q=%d\n&quot;,q1-q);  return 0;&#125;

运行结果如下
p=00000000005ffe56p+1=00000000005ffe57p1-p=5q=00000000005ffe20q+1=00000000005ffe24q1-q=6

显然两个指针的差是两个地址值之差除以sizeof得到的结果
*p++
去除p所指的那个数据，完事之后顺便把p移到下一个位置去
*的优先级虽然高，但是没有++高
常用语数组类的连续空间操作
在某些CPU上，这可以直接被翻译成一条汇编指令

指针比较
&lt; &lt;= == &gt; &gt;= !=都可以对指针做
比较它们在内存中的地址
数组中的单元的地址肯定是线性递增的

0地址
内存中有0地址，但通常是不能随便碰的地址
指针不应该具有0值
可以用0地址来表示特殊的事情
返回的指针是无效的
指针没有被真正初始化（先初始化为0）


NULL是一个预定定义的符号，表示0地址

指针的类型转换
void*表示不知道指向什么东西的指针
计算时与char*相同（但不相通）


int *p = &amp;i;void*q = (void*)p;
这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量

动态内存分配输入数据
int *a = (int*)malloc(n*sizeof(int));

#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;	int num;	int *a;	int i;	printf(&quot;请输入数量：&quot;);	scanf(&quot;%d&quot;,&amp;num);	a = (int*)malloc(num*sizeof(int));	for(i=0;i&lt;num;i++)&#123;		scanf(&quot;%d&quot;,&amp;a[i]);	&#125;	for(i=num-1;i&gt;=0;i--)&#123;		printf(&quot;%d&quot;,a[i]);	&#125;	free(a);//要还给malloc这个空间		return 0;&#125;

这样就在C99之前实现了变长数组如果申请失败则返回0，或者NULL试一下
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;	void *p;	int cnt = 0;	while((p=malloc(100*1024*1024)))&#123;		cnt++;	&#125;	printf(&quot;分配了%d00MB的空间\n&quot;,cnt);		return 0;&#125;

分配了44100MB的空间

常见问题

申请了没free –&gt;长时间运行内存逐渐下降
新手：忘了
老手：找不到合适的free时机


free过了再free
地址变过了，直接free

递归
如果函数调用他本身，那么就是递归（recursive）

int fact(int n)&#123;	if(n&lt;=1)&#123;		return 1;	&#125;else&#123;		return n*fact(n-1);	&#125;&#125;


以上程序实现了n的阶乘

快速排序算法给出分治法(divide-and-conquer)的经典示例快速排序算法(quicksort)
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯备赛笔记-第一章 语言基础</title>
    <url>/2025/12/15/lanqiaobei_notes/chapter01/index/</url>
    <content><![CDATA[第一章 语言基础本章是蓝桥杯备赛的基础内容，主要讲解C++语言的核心语法，是后续算法实现的必备知识。
📚 章节子目录


序号
知识点
内容说明



1.1
C++基础格式与版本选择
蓝桥杯比赛中C++的代码格式、编译器版本选择


1.2
输入输出
输入输出方式（cin&#x2F;cout&#x2F;scanf&#x2F;printf）及效率优化


1.3
string的使用
C++ string类的常用操作（定义、拼接、查找、遍历等）


📖 子知识点内容1.1 C++基础格式与版本选择
对应笔记：[C++基础格式与版本选择](.&#x2F;1.1 C++基础格式与版本选择.html)

讲解蓝桥杯比赛中推荐的代码框架、头文件选择（如#include &lt;bits/stdc++.h&gt;），以及比赛支持的C++版本（通常为C++11及以上）。
点击上方链接查看完整内容~
1.2 输入输出
对应笔记：[输入输出](.&#x2F;1.2 输入输出.html)

对比cin&#x2F;cout与scanf&#x2F;printf的使用场景，讲解输入输出的效率优化技巧（如ios::sync_with_stdio(false)），解决大数据量输入的超时问题。
点击上方链接查看完整内容~
1.3 string的使用
对应笔记：[string的使用](.&#x2F;1.3 string的使用.html)

详细介绍C++ string类的常用方法：定义初始化、拼接、截取（substr）、查找（find）、遍历方式等，结合蓝桥杯真题案例讲解实际应用。
点击上方链接查看完整内容~
]]></content>
      <categories>
        <category>编程竞赛</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>C++</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.3 string的使用</title>
    <url>/2025/12/15/lanqiaobei_notes/chapter01/1.3-string%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[1.3.1 string的简介
定位：string是C++标准库的重要组件，用于字符串处理。
使用前提：需在代码中包含头文件#include&lt;string&gt;。
核心特点：与传统的char[]相比，string是高度封装的类型，支持便捷的字符串操作（如拼接、截取、匹配等）。

string的核心特性
字符串管理：封装了字符串的存储与管理，自动处理内存分配&#x2F;释放，无需手动管理内存。
动态大小调整：可根据需求自动调整字符串容量，添加&#x2F;删除字符时会自动扩容，保证存储空间充足。
安全性：提供越界访问检查，避免访问超出字符串范围的字符，降低错误风险。
迭代器支持：支持迭代器，可通过迭代器遍历字符串中的字符，实现字符级别的操作。
兼容性：属于C++标准库组件，在C++中广泛应用，与其他标准库组件、C++语言特性兼容。

1.3.2 string的声明与初始化#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123;    // 声明并初始化一个空字符串    std::string str1;    // 使用字符串字面量初始化字符串    std::string str2 = &quot;Hello, World!&quot;;    // 使用另一个std::string对象来初始化字符串    std::string str3 = str2;    // 使用部分字符串初始化字符串（截取str2的前5个字符）    // substr()是子串，(起始位置，长度)    std::string str4 = str2.substr(0, 5);    // 使用字符数组初始化字符串    const char* charArray = &quot;Hello&quot;;    std::string str5(charArray);    // 使用重复的字符初始化字符串（5个&#x27;A&#x27;）    std::string str6(5, &#x27;A&#x27;);    // 输出字符串内容    std::cout &lt;&lt; &quot;str1: &quot; &lt;&lt; str1 &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;str3: &quot; &lt;&lt; str3 &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;str4: &quot; &lt;&lt; str4 &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;str5: &quot; &lt;&lt; str5 &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;str6: &quot; &lt;&lt; str6 &lt;&lt; std::endl;    return 0;&#125;
输出
str1: str2: Hello, World!str3: Hello, World!str4: Hellostr5: Hellostr6: AAAAA


在1.2 输入输出中还提到过getline(cin,s)的读取方法，用于读取一整行的字符串

1.3.3 基本操作#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    char buf[100];//临时变量，用于输入    scanf(&quot;%s&quot;, buf);//输入buf    string str(buf);//用buf来构造str    printf(&quot;str = %s\n&quot;, str.c_str());//输出str    return 0;&#125;


c_str()的作用：   std::string的成员函数c_str()会返回一个以空字符结尾的C风格字符串指针（const char*类型），用于兼容C语言的函数（如printf、scanf等）。

std::string常用操作（代码+解析）1. 获取字符串长度（length&#x2F;size）std::string str = &quot;Hello, World!&quot;;int length = str.length(); // 或 int length = str.size();std::cout &lt;&lt; &quot;Length: &quot; &lt;&lt; length &lt;&lt; std::endl;

功能：length()与size()作用完全一致，均返回字符串的字符个数（上述示例输出为13）。

2. 拼接字符串（+&#x2F;append）std::string str1 = &quot;Hello&quot;;std::string str2 = &quot;World!&quot;;std::string result1 = str1 + &quot;, &quot; + str2; // 运算符拼接std::string result2 = str1.append(&quot;, &quot;).append(str2); // 成员函数拼接std::cout &lt;&lt; &quot;Result 1: &quot; &lt;&lt; result1 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Result 2: &quot; &lt;&lt; result2 &lt;&lt; std::endl;

功能：两种方式均实现字符串拼接，示例输出均为Hello, World!；
区别：+生成新字符串，append直接修改原字符串（示例中str1会被修改为Hello, World!）。

3. 字符串查找（find）std::string str = &quot;Hello, World!&quot;;size_t pos = str.find(&quot;World&quot;); // 查找子串位置// std::string::npos 用于表示 未找到 或 无效位置if (pos != std::string::npos) &#123;    std::cout &lt;&lt; &quot;Substring found at position: &quot; &lt;&lt; pos &lt;&lt; std::endl;&#125; else &#123;    std::cout &lt;&lt; &quot;Substring not found.&quot; &lt;&lt; std::endl;&#125;

功能：查找子串首次出现的起始索引，找到则返回位置（示例中pos=7），未找到则返回std::string::npos。

4. 字符串替换（replace）std::string str = &quot;Hello, World!&quot;;str.replace(7, 5, &quot;Universe&quot;); // 替换子字符串std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; str &lt;&lt; std::endl;

参数说明：replace(起始索引, 替换长度, 新子串)；
示例输出：将索引7开始的5个字符（World）替换为Universe，最终输出Hello, Universe!

5. 提取子字符串（substr）std::string str = &quot;Hello, World!&quot;;std::string subStr = str.substr(7, 5); // 提取子字符串std::cout &lt;&lt; &quot;Substring: &quot; &lt;&lt; subStr &lt;&lt; std::endl;

功能：substr(起始索引, 长度)从字符串中截取指定长度的子串。
示例结果：从索引7开始截取5个字符，输出为World。
注意：不要越界



6. 字符串比较（compare）std::string str1 = &quot;Hello&quot;;std::string str2 = &quot;World&quot;;int result = str1.compare(str2); // 比较字符串if (result == 0) &#123;    std::cout &lt;&lt; &quot;Strings are equal.&quot; &lt;&lt; std::endl;&#125; else if (result &lt; 0) &#123;    std::cout &lt;&lt; &quot;String 1 is less than String 2.&quot; &lt;&lt; std::endl;&#125; else &#123;    std::cout &lt;&lt; &quot;String 1 is greater than String 2.&quot; &lt;&lt; std::endl;&#125;

返回值规则：
result == 0：两个字符串相等；
result &lt; 0：str1字典序小于str2；
result &gt; 0：str1字典序大于str2；


示例结果：Hello字典序小于World，输出String 1 is less than String 2.。

7. string的字典序比较规则string重载了不等号（如&lt;、&gt;），直接用运算符比较时，遵循字典序规则：

从第一个字符开始逐位比较，遇到第一个不相等的字符时，按该字符的ASCII值大小确定整体顺序；
若前面字符都相等，短字符串更小。

示例：

aaaa &lt; bbbb（首字符a的ASCII小于b）；
azz &lt; baaa（首字符a &lt; b，后续字符无需比较）；
azzzzzzzzz &lt; b（同理，首字符a &lt; b）；
lanqiao == lanqiao（所有字符完全匹配）。


推荐使用不等号直接比较

8.string的两种遍历方法（代码+解析）1. 循环枚举下标string s = &quot;Hello&quot;;// 通过下标访问每个字符for(int i = 0; i &lt; s.length(); ++i) cout &lt;&lt; s[i];cout &lt;&lt; &#x27;\n&#x27;;

功能：通过[i]访问字符串的第i个字符（下标从0开始），支持读写操作；
输出：Hello。

2. auto枚举（范围for循环）auto遍历有两种形式，核心区别是“是否取引用”：
形式1：auto i : s（拷贝遍历）for(auto i : s) &#123;    cout &lt;&lt; i;    i = &#x27;a&#x27;; // 修改无效，i是字符的拷贝&#125;cout &lt;&lt; &#x27;\n&#x27;;// 此时s仍为&quot;Hello&quot;

特点：i是字符串中每个字符的拷贝，修改i不会影响原字符串；
输出：Hello。

形式2：auto &amp;i : s（引用遍历）for(auto &amp;i : s) &#123;    cout &lt;&lt; i;    i = &#x27;a&#x27;; // 修改有效，i是原字符的引用&#125;cout &lt;&lt; &#x27;\n&#x27;;// 此时s变为&quot;aaaaa&quot;cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;

特点：&amp;表示取引用，i直接关联原字符串的字符，修改i会同步修改原字符串；
输出：遍历输出Hello，最终输出s的结果为aaaaa。

最终输出结果三种遍历的输出依次为：
HelloHelloHelloaaaaa

总结
下标遍历是最基础的方式，适合需要明确下标位置的场景；
auto遍历更简洁，若需修改原字符串，必须加&amp;取引用；若仅读取，可省略&amp;（或加const auto &amp;提升效率）。

1.3.4 例题讲解 蓝桥OJ250 反转字符串中的字符题目描述实现一个算法来实现反转字符数组的功能。反转的要求如下：

将字符数组的字符进行反转，例如 $[‘b’, ‘ ‘, ‘a’, ‘r’]$ 变成 $[‘r’, ‘a’, ‘ ‘, ‘b’]$。
将字符数组替换为反转后的数组。

输入描述读入一行字符串，长度不超过 100，字符串可能含有空格。
输出描述输出一行字符串，该字符串为读入字符串的反转字符串。
输入输出样例示例
输入

b ar

输出

ra b
运行限制
最大运行时间：1s
最大运行内存: 256M

#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    getline(cin,s);    reverse(s.begin(),s.end());    cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
或者
#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    getline(cin,s);    for(int i = (int)s.length()-1;i&gt;=0;i--)&#123;	    cout &lt;&lt; s[i];    &#125;    cout &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
]]></content>
  </entry>
  <entry>
    <title>1.1 C++基础格式与版本选择</title>
    <url>/2025/12/15/lanqiaobei_notes/chapter01/1.1-C++%E5%9F%BA%E7%A1%80%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[1.1.1 C++版本区别与选择


C++版本
描述



C++98 (ISO&#x2F;IEC 14882:1998)
C++的第一个版本于1998年10月发布。有一些较老的oj在使用。


C++03 (ISO&#x2F;IEC 14882:2003)
在这个版本的C++中，值初始化是在2003年2月引入的。


C++11（蓝桥杯选用）
它于2011年8月发布。这个C++修订版引入了Lambda表达式、委托构造函数、统一初始化语法、自动类型推导auto、nullptr、decltype、Rvalue References等。


C++14
它于2014年8月发布。此版本中添加的功能包括多态lambda、数字分隔符、通用lambda捕获、变量模板、二进制整数文字、引用字符串等。


C++17
它于2017年12月发布。它引入了折叠表达式、十六进制浮点文字、u8字符文字、带有初始化程序的选择语句、内联变量等。


C++20
它于2020年12月发布。包括的一些新功能包括：测试宏3路比较、运算符&lt;=&gt;和运算符==()=默认值、新属性：[no_unique_address]、[likely]、[太可能]



在蓝桥杯中使用C++11

1.1.2 C++代码风格与语法基础#include &lt;bits/stdc++.h&gt; //使用万能头文件using namespace std;//使用标准命名空间int main()//main函数是C++中内置的启动函数，也就是程序入口&#123;    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;//利用 cout 将字符串输出，字符串用双引号扩起     //&lt;&lt;是流插入运算符，将右侧内容输出到cout    printf(&quot;Hello, World!&quot;);//利用 printf 将字符串输出    return 0;//函数遇到 return 会立刻结束。返回0表示main函数正常结束&#125;
输出结果
Hello, World! Hello, World!

1.1.3 基本数据类型#include &lt;bits/stdc++.h&gt; //使用万能头文件using namespace std;int main()//main函数是C++中内置的启动函数，也就是程序入口&#123;    int x = 3;//整数x    double d = 3.14;//浮点数（小数）d    char ch = &#x27;A&#x27;;//字符ch    char s[] = &quot;Hello&quot;;//字符串s    bool b = true;//布尔值（即真假值）b    cout &lt;&lt; x &lt;&lt; &#x27;\n&#x27;; // &#x27;\n&#x27;是换行符号，比endl更快    cout &lt;&lt; d &lt;&lt; &#x27;\n&#x27;;    cout &lt;&lt; ch &lt;&lt; &#x27;\n&#x27;;//字符是用&#x27;&#x27;    cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;//字符串是用&quot;&quot;    cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;    cout &lt;&lt; b &lt;&lt; &#x27;\n&#x27;;//实际上true是1 false是0    return 0;//函数遇到return会立刻结束。返回0表示main函数正常结束&#125;
输出结果
33.14AHelloHello1

1.1.4 手撕五份代码1.1.4-1 数组#include &lt;bits/stdc++.h&gt;using namespace std;//const表示常量，后续不可被修改const int N = 1e5 + 9;int a[N];//开一个大小为N的全局数组，下标为[0, N - 1]，自动初始化为0int main()&#123;    return 0;&#125;


注意：只有全局数组，会自动初始化为0，如果是局部变量是不会的，而且全局数组的内存空间不受函数栈大小限制，因此可以定义较大的数组（如1e5级别），而局部数组（定义在main内）受栈空间限制，过大可能导致栈溢出。

1.1.4-2 typedef#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;//将long long类型定义为ll（方便后续使用）//const表示常量，后续不可被修改const int N = 1e5 + 9;//开一个大小为N的全局数组（类型为long long），下标为[0, N - 1]，自动初始化为0ll a[N];int main()&#123;    return 0;&#125;

1.1.4-3 字符串#include &lt;bits/stdc++.h&gt; //使用万能头文件using namespace std;int main()//main函数是C++中内置的启动函数，也就是程序入口&#123;    char s[] = &quot;Hello&quot;;//长度为5的数组，下标区间为[0, 4]        for(int i = 0;i &lt;= 4; ++ i)//数组下标从0开始    &#123;        cout &lt;&lt; s[i];//字符串s中下标为i的元素    &#125;    cout &lt;&lt; &#x27;\n&#x27;;//换行    cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;//输出s（遇到\0就停下），并换行        return 0;//函数遇到 return 会立刻结束。返回0表示main函数正常结束&#125;
输出结果
Hello Hello


for( ; ; )循环，第一部分是初始化，第二部分是循环条件，第三部分是循环一遍就执行一次的语句

1.1.4-4 交换变量#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a = 5, b = 3;//初始化变量a，b    int tmp = b;//临时变量tmp    b = a;//将a赋值给b    a = tmp;//将tmp赋值给a    cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27;\n&#x27;;//输出a，b    return 0;&#125;
输出结果
35

1.1.4-5 判断#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    //输出1 ~ n中所有的偶数    int n = 10;    for(int i = 1;i &lt;= n; ++ i)    &#123;        //如果后面不加大括号，则只执行一条语句        //i % 2 == 0表示 i 除以 2 的余数为 0        if(i % 2 == 0)cout &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;
输出结果
246810


在没有{}时，if只执行紧跟的一条语句(以 ; 区分)，实际上，在算法竞赛中，这样写很常见，但是考虑实际可读性，希望养成写每一个{}的习惯

]]></content>
  </entry>
  <entry>
    <title>1.2 输入输出</title>
    <url>/2025/12/15/lanqiaobei_notes/chapter01/1.2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[1.2.1 scanf和printf1.2.1 -1 int类型输入输出int main()&#123;    int a, b;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);//&amp;是取址运算符    printf(&quot;%d, %d\n&quot;, a, b);    return 0;&#125;
输入
2 9
输出
2,9

在读取的时候是在匹配，%d，匹配到2。

1.2.1-2 double 类型输入输出int main()&#123;    double a, b;    scanf(&quot;%lf %lf&quot;, &amp;a, &amp;b);    printf(&quot;%.2lf, %.3lf\n&quot;, a, b);//自动四舍五入    return 0;&#125;
输入
3 5
输出
3.00，5.000

1.2.1-3 char类型输入输出（含分隔符）int main()&#123;    char c1, c2;    scanf(&quot;%c:%c&quot;, &amp;c1, &amp;c2); // 按格式匹配输入中的分隔符&quot;:&quot;    printf(&quot;%c, %c&quot;, c1, c2);    return 0;&#125;
输入
a:b
输出
a, b

1.2.1-4 字符串（char数组）输入输出int main()&#123;    char s[10];    scanf(&quot;%s&quot;, s); // %s读取字符串，自动忽略开头空白，遇空格/回车停止    //s是字符串，本身是指针，就是地址，无需&amp;    printf(&quot;%s&quot;, s);    return 0;&#125;
输入
hello
输出
hello


注意：hello world作为输入，也只有hello的输出，因为scanf()遇到空格会停止

1.2.1-5 利用正则匹配读取含空格的字符串int main()&#123;    char s[15];    // %[^\n] 表示读取所有字符，直到遇到回车为止（包含空格）    //^表示排除 \n表示回车 意为直到读到回车就停止    scanf(&quot;%[^\n]&quot;, s);    printf(&quot;%s&quot;, s);    return 0;&#125;
输入
hello world
输出
hello world


说明：%[^\n]是scanf的格式控制符，属于 “扫描集” 语法，用于读取指定范围外的字符（此处表示 “读取所有非回车字符”），可实现含空格的字符串读取。

1.2.2 cin和cout1.2.2-1 int类型#include &lt;iostream&gt;using namespace std;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;  // 从输入流读取两个int类型数据    cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27;\n&#x27;;  // 输出数据，以空格分隔    return 0;&#125;


说明：cin 会自动忽略输入中的空白字符（空格、回车等），按顺序读取数据。就像是水流一样，流入流出

1.2.2-2 double类型#include &lt;iostream&gt;using namespace std;int main()&#123;    double a, b;    cin &gt;&gt; a &gt;&gt; b;  // 读取double类型数据    cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27;\n&#x27;;  // 输出默认格式的浮点数    return 0;&#125;
输入
2 3
输出
2 3


注：double 类型会自动转换为浮点表示，此处输入整数会以整数形式输出

1.2.2-3 格式化输出浮点数#include &lt;iostream&gt;#include &lt;iomanip&gt;  // 需包含此头文件以使用setprecisionusing namespace std;int main()&#123;    double a, b;    cin &gt;&gt; a &gt;&gt; b;    // fixed + setprecision(3)：固定保留3位小数    cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
输入
2 3
输出
2.000 3.000

1.2.2-4 输入字符串int main()&#123;    char s[10];    cin &gt;&gt; s;   // 输入遇到空格/回车时停止读取    cout &lt;&lt; s;    return 0;&#125;
输入
lan qiao
输出
lan


可以使用getline()读入，可以读取输入中的空格，这个不可以使用正则表达式

#include &lt;string&gt;  // 需包含string头文件using namespace std;int main()&#123;    string s;    getline(cin, s);  // 读取整行输入（包含空格），直到遇到回车终止    cout &lt;&lt; s;    return 0;&#125;

1.2.3 取消同步流C++ 中 cin/cout 的效率优化1. 效率问题说明cin 和 cout 的读写效率默认低于 C 语言的 scanf/printf，原因是：

cin/cout 会自动同步 C 标准输入输出流（以兼容 C 代码）；
内部需自动判断变量类型，增加了额外开销。当数据量较大（如处理上万条输入）时，可能导致程序运行超时。

2. 优化方法：取消同步流通过以下代码可关闭同步并解除绑定，大幅提升 cin/cout 的效率（优化后与 scanf/printf 效率接近）：
int main()&#123;    // 取消同步流 + 解除cin/cout的绑定    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    // 后续操作不变（示例）    int x;    cin &gt;&gt; x;    cout &lt;&lt; x &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;
3. 代码功能解析
ios::sync_with_stdio(0)：关闭 cin/cout 与 C 标准输入输出流（stdio）的同步，减少冗余操作；
cin.tie(0)：解除 cin 与 cout 的绑定（默认 cin 会先刷新 cout 缓冲区）；
cout.tie(0)：解除 cout 与其他流的绑定，进一步减少开销。

4. 注意事项
优化后，不能混合使用 cin/cout 和 scanf/printf（同步已关闭，会导致输出顺序混乱）；
该优化仅在数据量较大时才有明显效果，小规模数据可无需使用。

1.2.4 分析四份代码，一道例题1.2.4-1#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 150;int a[N]; // 定义大小为N的数组（全局）int main()&#123;    // 优化cin/cout效率（关闭同步流+解除绑定）    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);        int n;    cin &gt;&gt; n; // 输入数组长度    for(int i = 1;i &lt;= n; ++i) cin &gt;&gt; a[i]; // 输入数组元素（下标从1开始）    for(int i = n;i &gt;= 1; --i) cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; // 逆序输出数组    return 0;&#125;

1.2.4-2#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 150;char s[N]; // 定义大小为N的字符数组（存储字符串）int main()&#123;    // 优化cin/cout效率    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);        cin &gt;&gt; s + 1; // 从s[1]开始存储输入的字符串    // 遍历字符串并输出（s[i]非空字符时继续）    //直接cout &lt;&lt; s+1;也可以    for(int i = 1; s[i]; ++i) cout &lt;&lt; s[i];//s[i] 等价于s[i] != &#x27;\0&#x27;    return 0;&#125;
1.2.4-3#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 150;char s[N]; // 字符数组存储字符串int main()&#123;    scanf(&quot;%s&quot;, s); // C语言的scanf读取字符串（存入s[0]开始的数组）    // 遍历字符串，每个字符后换行输出    for(int i = 0; s[i]; ++i) cout &lt;&lt; s[i] &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;


注意：输入输出混合的风险，代码中混合使用了 C 的scanf和 C++ 的cout，默认情况下两者的缓冲区是同步的，但在大规模数据处理时可能出现输出顺序混乱的问题（建议尽量统一使用 C 或 C++ 的输入输出函数）；

1.2.4-4#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int N = 150;double a[N];// double a[N]; 这里重复定义了a数组，原代码中第5、6行重复了int main()&#123;    int n; scanf(&quot;%d&quot;, &amp;n);    for(int i = 1;i &lt;= n; ++ i) scanf(&quot;%lf&quot;, &amp;a[i]);    double sum = 0;    for(int i = 1;i &lt;= n; ++ i) sum += a[i];    printf(&quot;%.2lf\n&quot;, sum);//保留2位小数，自动进行四舍五入    return 0;&#125;
输入
5 1.0 2.313 6.22 5.47 9.299
输出
24.30

1.2.4-蓝桥OJ254A+B 问题【OJ 示例题目】
题目描述欢迎开启算法 OJ 题的大门，本题为经典的 A+BA+B 入门题，我们会以此题为示例介绍蓝桥云课 OJ 系统的正确使用方法。
问题描述
输入两个正整数 A,BA,B，请你计算 A+BA+B，并输出。
根据题目描述，你需要做以下事情：
编写一个程序，使用标准输入来输入两个整数 AA 和 BB，然后把 A+BA+B 的结果使用标准输出来输出。你可以滚动到本页面下方查看题目的示例输入和输出，这将极大地帮助你理解和完成题目。
那么，什么是标准输入和输出呢？

C 语言中的标准输入输出方法为 scanf() 和 printf()；
C++ 中的标准输入输出方法为 cin 和 cout，或者使用 scanf() 和 printf()；
Java 中的标准输入输出流为 System.in 和 System.out；
Python 中的标准输入输出方法为 input()和 print()；

#include &lt;iostream&gt;using namespace std;int main()&#123;	int a,b;	cin &gt;&gt; a &gt;&gt; b;	cout &lt;&lt; a+b &lt;&lt; &#x27;\n&#x27;;	return 0;&#125;
]]></content>
  </entry>
</search>
