<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/11/05/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
  <entry>
    <title>三大微分中值定理</title>
    <url>/2025/11/30/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[三大中值定理总结（含考研真题示例，每题1道例题）一、罗尔定理（Rolle’s Theorem）1. 核心定义若函数 $f(x)$ 满足 3个条件：

闭区间连续：$f(x) \in C[a,b]$（在$[a,b]$上连续）；
开区间可导：$f(x) \in D(a,b)$（在$(a,b)$内可导）；
端点值相等：$f(a) &#x3D; f(b)$；则存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; 0$。

几何意义：连续可导曲线在区间端点函数值相等时，曲线上至少有一点的切线与x轴平行（水平切线）。
2. 考研真题示例（2017年数学一&#x2F;二&#x2F;三）设函数 $f(x)$ 在$[0,1]$上连续，在$(0,1)$内可导，且 $f(1) &#x3D; 0$。证明：存在 $\xi \in (0,1)$，使得 $f’(\xi) &#x3D; -\frac{f(\xi)}{\xi}$。
证明步骤（可直接用于笔记&#x2F;答题）：

构造辅助函数：将待证式变形为 $\xi f’(\xi) + f(\xi) &#x3D; 0$，观察到左边是 $[x f(x)]’$ 的形式，故令 $F(x) &#x3D; x f(x)$。
验证罗尔定理条件：
连续性：$f(x)$ 连续、$x$ 连续，乘积 $F(x) \in C[0,1]$；
可导性：乘积求导得 $F’(x) &#x3D; f(x) + x f’(x)$，故 $F(x) \in D(0,1)$；
端点相等：$F(0) &#x3D; 0 \cdot f(0) &#x3D; 0$，$F(1) &#x3D; 1 \cdot f(1) &#x3D; 0$，即 $F(0) &#x3D; F(1)$。


应用定理：由罗尔定理，存在 $\xi \in (0,1)$ 使得 $F’(\xi) &#x3D; 0$，即 $f(\xi) + \xi f’(\xi) &#x3D; 0$，整理得 $f’(\xi) &#x3D; -\frac{f(\xi)}{\xi}$。

二、拉格朗日中值定理（Lagrange’s Mean Value Theorem）1. 核心定义若函数 $f(x)$ 满足 2个条件：

闭区间连续：$f(x) \in C[a,b]$；
开区间可导：$f(x) \in D(a,b)$；则存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; \frac{f(b) - f(a)}{b - a}$。

几何意义：连续可导曲线在区间上至少有一点的切线与区间端点连线（割线）平行。
常用等价形式：$f(b) - f(a) &#x3D; f’(\xi)(b - a)$（增量公式，可直接用于不等式证明、函数单调性判断）。
2. 考研真题示例（2019年数学一）设函数 $f(x)$ 在$[0,1]$上具有二阶导数，且 $f(1) &#x3D; 0$。记 $g(x) &#x3D; x f(x)$，证明：存在 $\xi \in (0,1)$，使得 $g’’(\xi) &#x3D; 0$。
证明步骤（可直接用于笔记&#x2F;答题）：

第一步：对 $g(x)$ 用罗尔定理找 $g’(x)$ 的零点：
$g(x) &#x3D; x f(x)$，则 $g(0) &#x3D; 0 \cdot f(0) &#x3D; 0$，$g(1) &#x3D; 1 \cdot f(1) &#x3D; 0$；
由罗尔定理，存在 $\eta \in (0,1)$ 使得 $g’(\eta) &#x3D; 0$。


第二步：分析 $g’(x)$ 的表达式：
求导得 $g’(x) &#x3D; f(x) + x f’(x)$，因 $f(x)$ 二阶可导，故 $g’(x) \in C[0,\eta]$ 且 $g’(x) \in D(0,\eta)$（可导必连续）。


第三步：对 $g’(x)$ 用罗尔定理：
代入 $x&#x3D;0$ 得 $g’(0) &#x3D; f(0) + 0 \cdot f’(0) &#x3D; f(0)$，结合 $g’(\eta) &#x3D; 0$，且 $g’(x)$ 可导，故存在 $\xi \in (0,\eta) \subset (0,1)$ 使得 $g’’(\xi) &#x3D; 0$。



简化记忆：二阶导数为零的证明，常通过“对一阶导数用罗尔定理”，核心是找到一阶导数的两个零点。
三、柯西中值定理（Cauchy’s Mean Value Theorem）1. 核心定义若函数 $f(x)$ 和 $g(x)$ 满足 4个条件：

闭区间连续：$f(x), g(x) \in C[a,b]$；
开区间可导：$f(x), g(x) \in D(a,b)$；
导数不同时为零：对任意 $x \in (a,b)$，$f’(x)^2 + g’(x)^2 \neq 0$；
端点函数值不等：$g(a) \neq g(b)$；则存在 $\xi \in (a,b)$，使得 $\frac{f(b) - f(a)}{g(b) - g(a)} &#x3D; \frac{f’(\xi)}{g’(\xi)}$。

几何意义：以 $x$ 为参数的曲线 $\begin{cases} X &#x3D; g(x) \ Y &#x3D; f(x) \end{cases}$ 上，至少有一点的切线与区间端点连线（割线）平行。
特殊情况：当 $g(x) &#x3D; x$ 时，柯西中值定理退化为拉格朗日中值定理（故拉格朗日是柯西的特例）。
2. 考研真题示例（2018年数学二）设函数 $f(x)$ 在$[a,b]$上连续，在$(a,b)$内可导，且 $f(a) &#x3D; f(b) &#x3D; 0$。证明：存在 $\xi \in (a,b)$，使得 $f’(\xi) &#x3D; f(\xi) \cdot \frac{g’(\xi)}{g(\xi)}$（其中 $g(x)$ 在$[a,b]$上连续且不为零，$g’(x)$ 存在）。
证明步骤（可直接用于笔记&#x2F;答题）：

构造辅助函数：将待证式变形为 $f’(\xi) g(\xi) - f(\xi) g’(\xi) &#x3D; 0$，观察到左边是 $\left[ \frac{f(x)}{g(x)} \right]’$ 的分子（商的求导法则：$\left( \frac{f}{g} \right)’ &#x3D; \frac{f’g - fg’}{g^2}$），故令 $F(x) &#x3D; \frac{f(x)}{g(x)}$。
验证柯西中值定理条件：
连续性：$f(x)$ 连续、$g(x)$ 连续且不为零，故 $F(x) \in C[a,b]$；
可导性：商的求导法则，$F’(x) &#x3D; \frac{f’(x) g(x) - f(x) g’(x)}{g^2(x)}$，故 $F(x) \in D(a,b)$；
端点相等：$F(a) &#x3D; \frac{f(a)}{g(a)} &#x3D; 0$，$F(b) &#x3D; \frac{f(b)}{g(b)} &#x3D; 0$，即 $F(a) &#x3D; F(b)$。


应用定理：由罗尔定理（或柯西中值定理，因 $g(x)$ 满足条件），存在 $\xi \in (a,b)$ 使得 $F’(\xi) &#x3D; 0$，即 $f’(\xi) g(\xi) - f(\xi) g’(\xi) &#x3D; 0$，整理得 $f’(\xi) &#x3D; f(\xi) \cdot \frac{g’(\xi)}{g(\xi)}$。

关键技巧：柯西中值定理的核心是“构造商式辅助函数”，本质是解决“两个函数的增量比与导数比”的关系问题。
总结（便于笔记记忆）


定理
核心条件
核心结论
考研常用技巧



罗尔定理
连续、可导、端点值相等
$f’(\xi) &#x3D; 0$
构造辅助函数（乘积、加减）


拉格朗日定理
连续、可导
$f’(\xi) &#x3D; \frac{f(b)-f(a)}{b-a}$
增量公式、不等式证明


柯西定理
两函数连续、可导、$g(a) \neq g(b)$
$\frac{f(b)-f(a)}{g(b)-g(a)} &#x3D; \frac{f’(\xi)}{g’(\xi)}$
构造商式辅助函数


共性：三大中值定理均是“连续+可导”的核心条件，本质是建立函数增量与导数的联系，考研重点在于“辅助函数构造”和“定理嵌套使用”（如拉格朗日定理嵌套罗尔定理）。
泰勒公式和中值定理的联系泰勒公式与三大中值定理（罗尔、拉格朗日、柯西）本质是 “局部近似”与“区间中值”的递进关系——泰勒公式是中值定理的“高阶推广”，中值定理是泰勒公式的“低阶特例”，核心联系如下：
1. 拉格朗日中值定理是泰勒公式的1阶特例泰勒公式（带拉格朗日余项）的一般形式：$f(x) &#x3D; f(x_0) + f’(x_0)(x - x_0) + \frac{f’’(x_0)}{2!}(x - x_0)^2 + \dots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n(x)$其中拉格朗日余项 $R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - x_0)^{n+1}$（$\xi$ 在 $x_0$ 与 $x$ 之间）。
当取 $n&#x3D;0$ 时（0阶泰勒公式）：$f(x) &#x3D; f(x_0) + f’(\xi)(x - x_0)$令 $x &#x3D; b$、$x_0 &#x3D; a$，即得拉格朗日中值定理：$f(b) - f(a) &#x3D; f’(\xi)(b - a)$。
2. 罗尔定理是泰勒公式的“特殊推论”对1阶泰勒公式，若 $f(a) &#x3D; f(b)$，则：$f(b) &#x3D; f(a) + f’(a)(b - a) + \frac{f’’(\xi)}{2!}(b - a)^2$因 $f(a) &#x3D; f(b)$，整理得 $f’(a) + \frac{f’’(\xi)}{2!}(b - a) &#x3D; 0$——但更直接的逻辑是：罗尔定理是证明泰勒公式余项的“基础工具”（证明泰勒余项时，常构造辅助函数，对其应用罗尔定理推导余项形式）。
3. 柯西中值定理与泰勒公式的“互补关系”
柯西中值定理聚焦 “两个函数的增量比与导数比”（解决比值型问题）；
泰勒公式聚焦 “单个函数的高阶近似”（解决精度要求高的问题，如极限计算、不等式证明、高阶导数相关问题）。

但二者本质一致：均依赖“函数连续可导”的条件，均通过“中值 $\xi$”建立函数与导数的联系，且柯西中值定理可作为证明泰勒公式的辅助工具（如推导柯西型余项时会用到）。
4. 核心共性：“中值思想”的统一无论是中值定理还是泰勒公式，核心都是 “在区间内存在一点 $\xi$，将函数的整体增量（或近似误差）用某阶导数表示”——中值定理是“1阶导数的整体关联”，泰勒公式是“多阶导数的局部近似”，前者是后者的简化，后者是前者的深化。
]]></content>
  </entry>
  <entry>
    <title>C语言历年期末真题(上半部分)</title>
    <url>/2025/12/24/C%E8%AF%AD%E8%A8%80%E5%8E%86%E5%B9%B4%E6%9C%9F%E6%9C%AB%E7%9C%9F%E9%A2%98(%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86)/</url>
    <content><![CDATA[1: 最小的数描述给定0-9数字各若干个，以任意顺序排列这些数字，使得最后得到的数尽可能小（0 不能做首位）。
输入在一行中给出 10 个非负整数，顺序表示数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。
输出在一行中输出能够组成的最小的数。
样例输入
2 2 0 0 0 3 0 0 1 0
输出
10015558

代码#include&lt;stdio.h&gt;int main(void)&#123;    int digits[10];    for(int i = 0;i&lt;10;i++)&#123;        scanf(&quot;%d&quot;,&amp;digits[i]);    &#125;    for(int i = 1;i&lt;10;i++)&#123;        if(digits[i] &gt; 0)&#123;            printf(&quot;%d&quot;,i);            digits[i]--;            break;        &#125;    &#125;    for(int i = 0;i&lt;10;i++)&#123;        while(digits[i]&gt;0)&#123;            printf(&quot;%d&quot;,i);            digits[i]--;        &#125;    &#125;    printf(&quot;\n&quot;);    return 0;&#125;

2: 不同的元素描述给定一个整型数组，统计不同的元素的个数。
输入每组输入占一行，每先给出正整数 $n (n≤30)$，随后是 n 个整数 $a_i​ (−100≤a_i​≤100)$，以空格分隔。
输出输出占一行，以回车结束。输出不同的元素的个数。
样例1输入
4 3 -5 2 8
输出
4
样例2输入
8 -5 8 8 8 8 8 8 -5
输出
2

代码#include&lt;stdio.h&gt;int main(void)&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    int existed[30];    int cnt = 0;    for(int i = 0;i&lt;n;i++)&#123;        if(i == 0)&#123;            scanf(&quot;%d&quot;,&amp;existed[i]);            cnt++;        &#125;else&#123;            int num;            scanf(&quot;%d&quot;,&amp;num);            int found = 0;            for(int j = i;j&gt;=0;j--)&#123;                if(existed[j] == num)&#123;                    found = 1;                &#125;            &#125;            if(!found)&#123;                existed[i] = num;                cnt++;            &#125;else&#123;                existed[i] = 101;            &#125;        &#125;    &#125;    printf(&quot;%d&quot;,cnt);    return 0;&#125;

3: 矩阵的幂描述给你一个$n∗n$的矩阵$A$，计算矩阵$A$的$k$次方，即计算
$$\underbrace{A * A * \dots * A}_{k\text{个}}$$
矩阵乘法的定义为：若$A,B,C$都是矩阵，$A∗B&#x3D;C$，那么有$$C_{i,j} &#x3D; \sum_{k&#x3D;0}^{n-1} \left(A_{i,k} * B_{k,j}\right)$$
输入第一行为矩阵的阶数$n$，以及$k$次方。接下来$n$行，每行有$n$个数，分别用空格分开。代表矩阵$A$。其中$1≤n,k≤7$，且矩阵AA中每个元素满足 $1≤A_i,_j≤7$。
输出输出一个$n∗n$的矩阵，代表计算结果
样例输入
3 22 1 52 5 77 3 3

输出
41 22 3263 48 6641 31 65

代码#include&lt;stdio.h&gt;int main(void)&#123;    int n,k;    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    long long matrix[7][7],res[7][7];    for(int i = 0;i&lt;n;i++)&#123;        for(int j = 0;j&lt;n;j++)&#123;            scanf(&quot;%d&quot;,&amp;matrix[i][j]);            res[i][j] = matrix[i][j];        &#125;    &#125;    long long temp[7][7];    if(k == 1)&#123;        for(int i = 0;i&lt;n;i++)&#123;            for(int j = 0;j&lt;n;j++)&#123;                printf(&quot;%lld &quot;,res[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;        return 0;    &#125;    for(int step = 0;step&lt;k-1;step++)&#123;        for(int i = 0;i&lt;n;i++)&#123;            for(int j = 0;j&lt;n;j++)&#123;                temp[i][j] = 0;            &#125;        &#125;        for(int row = 0;row&lt;n;row++)&#123;            for(int col = 0;col&lt;n;col++)&#123;                long long sum = 0;                for(int t=0;t&lt;n;t++)&#123;                    sum += res[row][t]*matrix[t][col];                &#125;                temp[row][col] = sum;            &#125;        &#125;        for(int i = 0;i&lt;n;i++)&#123;            for(int j = 0;j&lt;n;j++)&#123;                res[i][j] = temp[i][j];            &#125;        &#125;    &#125;    for(int i = 0;i&lt;n;i++)&#123;        for(int j = 0;j&lt;n;j++)&#123;            printf(&quot;%lld &quot;,res[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;

4: 日期距离描述众所周知，日期有两种表示方法:MM&#x2F;DD&#x2F;YY或者YY&#x2F;MM&#x2F;DD.我们假设本题讨论的年份的格式都是20YY。
给你一个字符串，如果它只能代表一个合法的日期，满足MM&#x2F;DD&#x2F;YY的格式或者是YY&#x2F;MM&#x2F;DD的格式，那么输出 “month date,year”的格式（见第二个样例），否则输出在这两种表示法下的日期差（见第一个样例）。

提示1：一年有12个月，分别是January, February, March, April, May, June, July, August, September, October, November 和 December。

提示2：注意闰年2月份有29天。闰年需要满足以下两个条件之一:

年份是400的倍数。
年份是4的倍数但年份不是100的倍数。



输入一个时间字符串，格式为AA&#x2F;BB&#x2F;CC。保证AA&#x2F;BB&#x2F;CC至少满足两种表示法其中之一。
输出见描述。
样例输入
02/07/1919/02/07

输出
6047February 7, 2019

提示样例1：02/07/19可能是2019.2.7(采用MM&#x2F;DD&#x2F;YY表示法)或者是2002.7.19(采用YY&#x2F;MM&#x2F;DD表示法)。这两个日期相差6047天。
样例2：19/02/07只能是2019.2.7(YY&#x2F;MM&#x2F;DD表示法)。也就是只能代表这一个日期，按照要求输出即可。
代码#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 判定闰年int is_leap(int y) &#123;    return (y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0));&#125;// 获取每月天数int get_month_days(int y, int m) &#123;    int ds[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;    if (m == 2 &amp;&amp; is_leap(y)) return 29;    if (m &gt;= 1 &amp;&amp; m &lt;= 12) return ds[m];    return 0;&#125;// 验证日期合法性int is_valid(int y, int m, int d) &#123;    if (m &lt; 1 || m &gt; 12) return 0;    if (d &lt; 1 || d &gt; get_month_days(y, m)) return 0;    return 1;&#125;// 计算绝对天数long long to_abs_days(int y, int m, int d) &#123;    long long total = 0;    for (int i = 2000; i &lt; y; i++) &#123;        total += is_leap(i) ? 366 : 365;    &#125;    for (int i = 1; i &lt; m; i++) &#123;        total += get_month_days(y, i);    &#125;    total += d;    return total;&#125;char* months[] = &#123;&quot;&quot;, &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;,                   &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;&#125;;int main() &#123;    int a, b, c;    // 使用 scanf 处理前导零    if (scanf(&quot;%d/%d/%d&quot;, &amp;a, &amp;b, &amp;c) != 3) return 0;    // 格式1: MM/DD/YY -&gt; 20CC/A/B    int y1 = 2000 + c, m1 = a, d1 = b;    int v1 = is_valid(y1, m1, d1);    // 格式2: YY/MM/DD -&gt; 20A/B/C    int y2 = 2000 + a, m2 = b, d2 = c;    int v2 = is_valid(y2, m2, d2);    if (v1 &amp;&amp; v2) &#123;        // 如果两个日期其实是同一天        if (y1 == y2 &amp;&amp; m1 == m2 &amp;&amp; d1 == d2) &#123;            printf(&quot;%s %d, %d\n&quot;, months[m1], d1, y1);        &#125; else &#123;            // 计算差值            long long diff = to_abs_days(y1, m1, d1) - to_abs_days(y2, m2, d2);            if (diff &lt; 0) diff = -diff;            printf(&quot;%lld\n&quot;, diff);        &#125;    &#125; else if (v1) &#123;        // 只有 MM/DD/YY 合法        printf(&quot;%s %d, %d\n&quot;, months[m1], d1, y1);    &#125; else if (v2) &#123;        // 只有 YY/MM/DD 合法        printf(&quot;%s %d, %d\n&quot;, months[m2], d2, y2);    &#125;    return 0;&#125;

5: 中值滤波描述中值滤波是对一个滑动窗口内的值进行排序，用其中值代替窗口中心点的原来值的滤波方法，它在抑制随机噪声的同时能有效保护原有信息。以一维信号的中值滤波举例。
对序列80 120 90 200 100 110 150，假设滤波窗口宽度为5,那么有



滤波窗口的子序列
子序列排序
待替换的值
序列中值



80 120 90 200 100
80 90 100 120 200
90
100


120 90 200 100 110
90 100 110 120 200
200
110


90 200 100 110 150
90 100 110 150 200
100
110


滤波窗口的值如果不够5个值那么不改变对应点的值， 比如左侧的80， 以它为中心的5个长度的窗口内没有5个数，所以这个点仍然是80不变。
所以最后滤波结果是80 120 100 110 110 110 150。
如果滤波窗口宽度为3，那么滤波结果是80 90 120 100 110 110 150。
输入只包含一组数据。每组数据包括2行。第一行为2个整数w、n，w为滤波窗口宽度（必须是奇数），n表示后面有n个整数。第二行为待滤波的n个整数，各数之间用一个空格来间隔。
输出输出滤波后的序列，各数之间用一个空格分隔，输出需占一行，结尾需换行。如果输入w不是奇数那么输出ERROR。
样例输入
3 51 3 9 2 85 51 3 9 2 84 51 3 9 2 8

输出
1 3 3 8 81 3 3 2 8ERROR

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    int w,n;    cin &gt;&gt; w &gt;&gt; n;    //w是窗口宽度,n是数据量    if(w % 2 == 0)&#123;        cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; &#x27;\n&#x27;;        return 0;    &#125;    vector&lt;int&gt; nums(n);    for(int i = 0;i&lt;n;i++)&#123;        cin &gt;&gt; nums[i];    &#125;    vector&lt;int&gt; res = nums;    int half = w/2;    for(int i = 0;i&lt;n;i++)&#123;        int left = i - half;        int right = i + half;        if(left &lt; 0 ||  right &gt;= n)&#123;            continue;        &#125;        vector&lt;int&gt; window;        for(int j = left;j&lt;=right;j++)&#123;            window.push_back(nums[j]);        &#125;        sort(window.begin(),window.end());        int midnum = window[half];        res[i] = midnum;    &#125;    for(int i = 0;i&lt;n;i++)&#123;        cout &lt;&lt; res[i] &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;

6: 判断直角三角形描述输入三角形的3条边长， 判断三角形是否是直角三角形。
输入第1行是一个整数n，表示随后有n组数据。每组数据占一行，包含3个整数代表3条边长(每个整数的平方能够用32位整数表示)，用空格分隔。
输出每组输出占一行，如果是直角三角形输出Yes，不是则输出No。
样例输入
23 4 5   3 5 7

输出
YesNo

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    int n;    cin &gt;&gt; n;    for(int i = 0;i&lt;n;i++)&#123;        int a,b,c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        if(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)&#123;            if(a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a)&#123;                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &#x27;\n&#x27;;            &#125;else&#123;                cout &lt;&lt; &quot;No&quot; &lt;&lt; &#x27;\n&#x27;;            &#125;        &#125;else&#123;            cout &lt;&lt; &quot;No&quot; &lt;&lt; &#x27;\n&#x27;;        &#125;    &#125;    return 0;&#125;

7: 求绝对值最大的数描述求一组数据中绝对值最大的数输出。
输入每行输入包含一个测试用例，第一个整数$m(1≤m≤20)$，表示随后有m个整数(能够用32位整数表示)，各数之间用空格分隔。
输出每组输出占一行，输出绝对值最大的数。(不考虑最大值对应多个输入的情况)
样例输入
3 0 -2 1
输出
-2

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    int m;    cin &gt;&gt; m;    vector&lt;int&gt; nums(m);    for(int i = 0;i&lt;m;i++)&#123;        cin &gt;&gt; nums[i];    &#125;    int max = nums[0];    for(int i = 0;i&lt;m;i++)&#123;        if(abs(nums[i]) &gt; abs(max))&#123;            max = nums[i];        &#125;    &#125;    cout &lt;&lt; max &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;

8: 分解偶数描述任何大于 6 的偶数都可以分解成两个奇质数的和。输入 n，输出所有解，按小的在前，大的在后输出，不要重复。
输入每行输入包含一个测试用例，输入一个整数 $n (n≤10000000)$。
输出对符合要求的输入数据，依次输出所有解，每个解占一行，两个数用空格分隔。对输入不符合要求的数，则输出ERROR。
样例输入
10

输出
3 75 5

代码#include&lt;bits/stdc++.h&gt;using namespace std;int is_odd_prime(int num)&#123;    if(num &lt; 3) return 0;    if(num == 3) return 1;    if(num % 2 == 0) return 0;    for(int i = 3;i*i&lt;=num;i+=2)&#123;        if(num % i == 0)&#123;            return 0;        &#125;    &#125;    return 1;&#125;int main(void)&#123;    int n;    cin &gt;&gt; n;    if(n &lt;= 6 || n % 2 != 0)&#123;        cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; &#x27;\n&#x27;;    &#125;else&#123;        for(int i = 3;i&lt;=n/2;i+=2)&#123;            int j = n - i;            if(is_odd_prime(i) &amp;&amp; is_odd_prime(j))&#123;                cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &#x27;\n&#x27;;            &#125;        &#125;    &#125;    return 0;&#125;

9: 显示柱状图描述根据输入的数字和符号生成相应的柱状图显示。
输入每个输入包含一个测试用例，第一个整数$m (1≤m≤20)$，表示随后有$m$组数据，每组数据由一个数字$n(−15≤n≤15)$和一个字符组成，每组数据之间用空格分隔。数字代表柱状图的高度，字母代表该柱使用的画图符号。如果数字后没有字母，默认该柱的画图符号使用加号+。
输出每个柱之间用1个空格间隔，图的空白处用空格填充。用减号-表示x轴。正数柱状向上，负数柱状向下。
样例输入
6 1a 3 4b 2 -2 1

输出
    b        + b        + b +    a + b +   +-----------        +          +  

代码#include&lt;bits/stdc++.h&gt;using namespace std;struct Column &#123;    int h;    char s;&#125;;int main(void)&#123;    int m;    cin &gt;&gt; m;    vector&lt;Column&gt; cols(m);    int max_h = 0,min_h = 0;    for(int i = 0;i&lt;m;i++)&#123;        cin &gt;&gt; cols[i].h;        char next = cin.peek();        while(next == &#x27; &#x27;)&#123;            cin.ignore();            next = cin.peek();        &#125;        if(next != EOF &amp;&amp; !isdigit(next) &amp;&amp; next != &#x27;-&#x27; &amp;&amp; next != &#x27;\n&#x27;)&#123;            cin &gt;&gt; cols[i].s;        &#125;else&#123;            cols[i].s = &#x27;+&#x27;;        &#125;        max_h = max(max_h,cols[i].h);        min_h = min(min_h,cols[i].h);    &#125;    //中间是空格    int width = 2*m - 1;    for(int k = max_h;k&gt;=1;k--)&#123;        string line = &quot;&quot;;        for(int i = 0;i&lt;m;i++)&#123;            if(cols[i].h &gt;= k) line += cols[i].s;            else line += &#x27; &#x27;;            if(i &lt; m-1) line += &#x27; &#x27;;        &#125;        while(!line.empty() &amp;&amp; line.back() == &#x27; &#x27;) line.pop_back();        if(!line.empty()) cout &lt;&lt; line &lt;&lt; &#x27;\n&#x27;;    &#125;    for(int i = 0;i&lt;width;i++)&#123;        cout &lt;&lt; &#x27;-&#x27;;    &#125;    cout &lt;&lt; &#x27;\n&#x27;;    for(int k = -1;k &gt;= min_h;k--)&#123;        string line = &quot;&quot;;        for(int i = 0;i&lt;m;i++)&#123;            if(cols[i].h &lt;= k) line += cols[i].s;            else line += &#x27; &#x27;;            if(i &lt; m-1) line += &#x27; &#x27;;        &#125;        while(!line.empty() &amp;&amp; line.back() == &#x27; &#x27;) line.pop_back();        if(!line.empty()) cout &lt;&lt; line &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;

10: 统计回文数描述输入一段文本，统计中间出现次数最多的回文数。回文数是类似12321，1221这样，顺序和逆序相同的十进制无符号整数，不考虑符号，长度至少为2，不能以0开始。另外，不考虑数的一部分，即abc1232abc中的232不是一个单独的数。(数据可能超过32位)
输入输入数据为一段文本，可能包含若干行，直到文件末尾为止。即只有一组测试用例。
输出对于每一组输入数据，输出出现次数最多的回文数和它出现的次数。如果有多个，按数字从小到大输出，每个数占一行。如果没有， 输出None。
样例输入
Thin34543king 121 is8 interesting121.I like121 thinking23.

输出
121 3

提示本题虽然是找整数，但最好的方法是全部按字符串来处理。
代码#include&lt;bits/stdc++.h&gt;using namespace std;int is_palindrome(const string &amp;s)&#123;    if(s.length() &lt; 2 || s[0] == &#x27;0&#x27;) return 0;    int i = 0,j = s.length() - 1;    while(i &lt; j)&#123;        if(s[i++] != s[j--]) return 0;    &#125;    return 1;&#125;int cmp_num(const string &amp;a,const string &amp;b)&#123;    if(a.length() != b.length()) return a.length() &lt; b.length();    return a&lt;b;&#125;int main(void)&#123;    string line;    map&lt;string,int&gt; cnts;    while(getline(cin,line))&#123;        string curr_digit = &quot;&quot;;        for(int i = 0;i&lt;=line.length();i++)&#123;            if(i&lt;line.length() &amp;&amp; isdigit(line[i]))&#123;                curr_digit += line[i];            &#125;else&#123;                if(!curr_digit.empty())&#123;                    if(is_palindrome(curr_digit))&#123;                        cnts[curr_digit] ++;                    &#125;                    curr_digit = &quot;&quot;;                &#125;            &#125;        &#125;    &#125;    if(cnts.empty())&#123;        cout &lt;&lt; &quot;None&quot; &lt;&lt; &#x27;\n&#x27;;        return 0;    &#125;    int max_freq = 0;    for(auto const&amp; [num,freq] : cnts)&#123;        if(freq &gt; max_freq) max_freq = freq;    &#125;    vector&lt;string&gt; result;    for(auto const&amp;[num,freq]: cnts)&#123;        if(freq == max_freq)&#123;            result.push_back(num);        &#125;    &#125;    sort(result.begin(),result.end(),cmp_num);    for(const string&amp; s : result)&#123;        cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; max_freq &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;

11: 计算平方和描述输入 4 个十进制整数，计算它们的平方和并输出。
输入输入 4 个十进制整数，范围是−10000~10000。
输出输出它们的平方和。
样例输入
1 2 3 4

输出
30

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    long long a,b,c,d;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;    cout &lt;&lt; a*a + b*b + c*c + d*d &lt;&lt; &#x27;\n&#x27;;    return 0;&#125;

12: 数的表示描述任何一个正整数都可以用 22 的幂次方表示。例如 138&#x3D;27+23+21。
请编程输出给定正整数的幂次表达式。
输入输入 1 个十进制正整数，范围是1~100000。
输出输出它的幂次表达式，按幂次降序排列。
样例输入
2

输出
2=2^1

输入
9

输出
9=2^3+2^0

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    int num;    cin &gt;&gt; num;    int temp = num;    int res[32] = &#123;0&#125;;    int cnt = 0;    while(temp &gt; 0)&#123;        res[cnt++] = temp % 2;        temp &gt;&gt;= 1;    &#125;    int need_plus = 0;    cout &lt;&lt; num &lt;&lt; &#x27;=&#x27;;    for(int i = cnt-1;i&gt;=0;i--)&#123;        if(res[i] == 1)&#123;            if(need_plus)&#123;                cout &lt;&lt; &#x27;+&#x27;;            &#125;            cout &lt;&lt; 2 &lt;&lt; &#x27;^&#x27; &lt;&lt; i;            need_plus = 1;        &#125;    &#125;    return 0;&#125;

13: 对称子串描述有两个字符串S1,S2，请编程检测S2是否在S1中对称出现(S2正串一定要在S2反串前面)，并输出最大对称间隔。
例如：
S1 &#x3D; fabcdhba, S2 &#x3D; ab，其中，ab...ba称为S2在S1中对称出现了1次，S2正串为ab，S2反串为ba，对称间隔为3。S1 &#x3D; abcdhbaghba, S2&#x3D;ab，其中，ab...ba..ba称为S2在S1中对称出现了2次，对称间隔为3和7。
如果S2对称出现多次，则输出最大间隔。
注意：如果S2和S2的反串有部分重叠，那么间隔是负数。
输入输入两个字符串S1,S2，以空格分开，字符串内部没有空格。
S1长度不超过300，S2的长度不超过10。
输出输出S2最大对称间隔。
如果没有对称出现的S2出现，则输出no。
样例输入
abcdhba abcd

输出
no

输入
abcdhbaghba ab

输出
7

代码#include&lt;bits/stdc++.h&gt;using namespace std;int main(void)&#123;    string s1,s2;    cin &gt;&gt; s1 &gt;&gt; s2;    string s2_rev = s2;    reverse(s2_rev.begin(),s2_rev.end());    vector&lt;int&gt; pos1;//正串出现的位置    vector&lt;int&gt; pos2;//反串    int found = (int)s1.find(s2);    while(found != string::npos)&#123;        pos1.push_back(found);        found = (int)s1.find(s2,found+1);    &#125;    found = (int)s1.find(s2_rev);    while(found != string::npos)&#123;        pos2.push_back(found);        found = (int)s1.find(s2_rev,found+1);    &#125;    int found_pair = 0;    int max_dist = -10000;//初始化为极小值    int len2 = s2.length();    for(int i : pos1)&#123;        for(int j : pos2)&#123;            if(j &gt; i)&#123;                found_pair = 1;                int curr_dist = j - (i + len2);                if(curr_dist &gt; max_dist)&#123;                    max_dist = curr_dist;                &#125;            &#125;        &#125;    &#125;    if(!found_pair)&#123;        cout &lt;&lt; &quot;no\n&quot;;    &#125;else&#123;        cout &lt;&lt; max_dist &lt;&lt; &#x27;\n&#x27;;    &#125;    return 0;&#125;

14: 走迷宫描述给一个 $N×M$ 的字符矩阵 $S，S_i,_j∈{U,D,L,R}$。
设当前位置为 $(x,y)$，定义一次移动为：

若  $S_x,_y​&#x3D;U$，则向上移动到 $(x−1,y)$ ，若  $x&#x3D;1$，则移动到 $(N,y)$。
若  $S_x,_y​&#x3D;D$，则向下移动到 $(x+1,y)$，若  $x&#x3D;N$，则移动到 $(1,y)$。
若  $S_x,_y​&#x3D;L$，则向左移动到 $(x,y−1)$，若 $y&#x3D;1$，则移动到 $(x,M)$。
若  $S_x,_y​&#x3D;R$，则向右移动到 $(x,y+1)$，若 $y&#x3D;M$，则移动到 $(x,1)$。

有 Q 次询问。
每次询问给出一个初始坐标 $(x_0​,y_0​)$，和移动次数 step，回答经过 step 次移动后到达的坐标。
限制时间限制 $1s$，空间限制 $256M$
$1≤N,M,Q≤50$$Si,j∈{U,D,L,R}(1≤i≤N,1≤j≤M)$$1≤x_0≤N$$1≤y_0≤M$$1≤step≤3000$
输入第一行输入 $N,M$。接下来有 $N$ 行，每行有 $M$ 个字符，字符取值范围为 $U,D,L,R$。接下来一行输入 $Q$。接下来有 $Q$ 行，每行输入 $x_0,y_0,step$。
输出对于每个询问，输出答案，每行输出两个整数，表示坐标。
样例输入
5 5UDRRULRDDLDLUUDRULLRUDURU51 1 12 1 23 3 104 2 993 5 3000

输出
5 12 43 34 13 2

解释对于第 11 次询问，(1,1)(1,1) 向上移动一次到达 (5,1)(5,1)对于第 22 次询问，(2,1)(2,1) 向左移动一次到达 (2,5)(2,5)，向左移动一次到达 (2,4)(2,4)对于第 33 次询问，路径为 (3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3)(3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3),(2,3),(3,3)
代码#include&lt;stdio.h&gt;#include&lt;string.h&gt;char op[50][50];int main(void)&#123;    int N,M;    scanf(&quot;%d %d&quot;,&amp;N,&amp;M);    for(int i = 0;i&lt;N;i++)&#123;        scanf(&quot;%s&quot;,op[i]);    &#125;    int Q;    scanf(&quot;%d&quot;,&amp;Q);    for(int k = 0;k&lt;Q;k++)&#123;        int x,y,step;        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;step);        //1-base转0-base        x -= 1;        y -= 1;        for(int s = 0;s &lt; step;s++)&#123;            if(op[x][y] == &#x27;U&#x27;)&#123;                if(x == 0)&#123;                    x = N - 1;                &#125;else&#123;                    x -= 1;                &#125;            &#125;else if(op[x][y] == &#x27;D&#x27;)&#123;                if(x == N-1)&#123;                    x = 0;                &#125;else&#123;                    x += 1;                &#125;            &#125;else if(op[x][y] == &#x27;L&#x27;)&#123;                if(y == 0)&#123;                    y = M - 1;                &#125;else&#123;                    y -= 1;                &#125;            &#125;else if(op[x][y] == &#x27;R&#x27;)&#123;                if(y == M-1)&#123;                    y = 0;                &#125;else&#123;                    y += 1;                &#125;            &#125;else&#123;                continue;            &#125;        &#125;        printf(&quot;%d %d\n&quot;,x+1,y+1);    &#125;    return 0;&#125;

15: 排名计算描述ICPC竞赛需要依据参赛选手的代码提交来进行排名，参赛选手的代码提交后，有以下几种状态：AC、WA、PE、RE、TE、ME、OE、CE，其中只有 AC代表题目顺利通过。对于每一次提交，如果你是第一次通过该题（状态为 AC），那么你通过的题目数加1，并且将你通过的时间（距离竞赛开始经过了多长时间，注：这里为了简化以分钟数计算）计入罚时。除此之外罚时还会加上你第一次通过之前的尝试次数×20。对于某一时刻t，所有参赛队伍在该时刻t之前(包括时刻t)的提交会被统计为通过题目数和罚时。
比较A、B两只队伍的排名，优先比较通过题目数（通过题目数越多排名越前），通过题目数相同时比较罚时（罚时越低排名越前），前两者都相同则比较队伍的id（id小的排名越前）。
现在总共有q次询问，每次询问想要在t时刻根据队伍id或队伍名字查询队伍的排名信息（队伍名字不唯一，但队伍id唯一，若查询队伍名字则需将名字相同的所有队伍信息由排名从高至低依次输出）。
注意：

状态为 CE 的提交是不会被计算进尝试次数。
只有当一个队伍 AC 一道题时，该题的罚时才会被计算。如果该题最终也未 AC，那么该题的罚时是不会被计算。
如果有人在 AC 后又提交了错误代码，这种罚时也是不会被计算。
该题中，比赛题目总数量为10。
比赛的时间范围是09:00 ~ 14:00

举个例子：小明在 10:00 时首次通过了题目B，且它在此之前提交了3次 (WA、CE、RE), 那么该题的罚时为 60+2×20&#x3D;100。
但在 09:59 时，该题没有通过，所以也没有罚时。
输入第一行是三个整数$1≤n≤500,1≤m≤50,1≤q≤200$ 分别代表提交次数、队伍总数和询问次数。
接下来m行每行1个整数tid和一个字符串name，$1≤tid≤m,∣name∣≤20$分别表示队伍的id和该队伍的名字（每只队伍的id均不相同，名字均由小写字母组成且长度小于20）。
接下来n行由tid,pid,s,t组成, tid代表提交的队伍id (1≤tid≤m), pid代表提交的题目id (1≤pid≤10), s代表评测状态(s ∈{ AC、WA、PE、RE、TE、ME、OE、CE}), t 代表提交时间，格式为 xx:xx 。
输入保证每条提交记录是按照时间顺序给出，且不会有队伍在相同时间有超过一次的提交记录。
接下来q行，每行包含3个字段，前两个数type,t分别表示查询的类型type∈{0,1}和查询的时刻t，格式 xx:xx (09:00 ~ 14:00)。

当 type&#x3D;0时，按队伍id查询，输入的第三个数为要查询的队伍号。
当 type&#x3D;1时，按队伍名查询，输入的第三个字符串为要查询的队伍名字。

输出对每次查询，输出查询结果，每支队伍的信息占一行，包括队伍的排名、队伍的tid、队伍的name、队伍通过题目数量和队伍的总罚时。如果有多支队伍符合条件，按照排名顺序依次输出。
样例输入
5 3 31 yyds2 yyds3 ysqd1 1 WA 09:542 1 AC 10:131 1 AC 10:141 3 AC 11:112 2 CE 12:001 09:01 yyds0 10:14 11 12:00 yyds

输出
1 1 yyds 0 02 2 yyds 0 02 1 yyds 1 941 1 yyds 2 2252 2 yyds 1 73

提示共有三个查询：
第一个查询在09:01查询队伍名称为yyds的队伍的排名情况，队伍1与队伍2名字均为yyds且此时均未通过任何题目，所以依次输出两队信息。
第二个查询在10:14查询队伍id&#x3D;1的排名信息，此时队伍id&#x3D;1通过题目数1，罚时74+20&#x3D;94。队伍id&#x3D;2通过题目数1，罚时73。故队伍id&#x3D;1此时排名为2。
第三个查询同理可知队伍id&#x3D;1通过题目数2,罚时74+20+131&#x3D;225。队伍id&#x3D;2通过题目数1，罚时73，按照排名依次输出即可。
代码#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;// 时间转换函数：将 hh:mm 转为相对于 09:00 的分钟数int toMin(string s) &#123;    int h = stoi(s.substr(0, 2));    int m = stoi(s.substr(3, 2));    return (h - 9) * 60 + m;&#125;struct Team &#123;    int id;    string name;    int solved = 0;    int penalty = 0;    int rank = 0;&#125;;struct Submission &#123;    int tid, pid, time;    string status;&#125;;struct Node &#123;    bool is_ac = false;    int fail_count = 0;    int ac_time = 0;&#125;;int main() &#123;    int n, m, q;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;    vector&lt;Team&gt; teams(m + 1);    for (int i = 0; i &lt; m; ++i) &#123;        int tid;        string name;        cin &gt;&gt; tid &gt;&gt; name;        teams[tid].id = tid;        teams[tid].name = name;    &#125;    vector&lt;Submission&gt; subs(n);    for (int i = 0; i &lt; n; ++i) &#123;        string t_str;        cin &gt;&gt; subs[i].tid &gt;&gt; subs[i].pid &gt;&gt; subs[i].status &gt;&gt; t_str;        subs[i].time = toMin(t_str);    &#125;    while (q--) &#123;        int type;        string query_t_str;        cin &gt;&gt; type &gt;&gt; query_t_str;        int query_t = toMin(query_t_str);        // 统计 query_t 时刻前所有队伍的状态        vector&lt;vector&lt;Node&gt;&gt; stat(m + 1, vector&lt;Node&gt;(11));        for (int i = 0; i &lt; n; ++i) &#123;            if (subs[i].time &gt; query_t) continue;            int tid = subs[i].tid;            int pid = subs[i].pid;            if (stat[tid][pid].is_ac) continue; // AC后不再统计            if (subs[i].status == &quot;AC&quot;) &#123;                stat[tid][pid].is_ac = true;                stat[tid][pid].ac_time = subs[i].time;            &#125; else if (subs[i].status != &quot;CE&quot;) &#123;                stat[tid][pid].fail_count++;            &#125;        &#125;        // 计算罚时和解题数        vector&lt;Team&gt; rank_list;        for (int i = 1; i &lt;= m; ++i) &#123;            Team t = teams[i];            t.solved = 0;            t.penalty = 0;            for (int p = 1; p &lt;= 10; ++p) &#123;                if (stat[i][p].is_ac) &#123;                    t.solved++;                    t.penalty += stat[i][p].ac_time + stat[i][p].fail_count * 20;                &#125;            &#125;            rank_list.push_back(t);        &#125;        // 排序规则        sort(rank_list.begin(), rank_list.end(), [](const Team&amp; a, const Team&amp; b) &#123;            if (a.solved != b.solved) return a.solved &gt; b.solved;            if (a.penalty != b.penalty) return a.penalty &lt; b.penalty;            return a.id &lt; b.id;        &#125;);        // 标记排名        for (int i = 0; i &lt; m; ++i) &#123;            rank_list[i].rank = i + 1;        &#125;        // 处理查询        if (type == 0) &#123;            int q_tid;            cin &gt;&gt; q_tid;            for (auto&amp; t : rank_list) &#123;                if (t.id == q_tid) &#123;                    cout &lt;&lt; t.rank &lt;&lt; &quot; &quot; &lt;&lt; t.id &lt;&lt; &quot; &quot; &lt;&lt; t.name &lt;&lt; &quot; &quot; &lt;&lt; t.solved &lt;&lt; &quot; &quot; &lt;&lt; t.penalty &lt;&lt; endl;                    break;                &#125;            &#125;        &#125; else &#123;            string q_name;            cin &gt;&gt; q_name;            for (auto&amp; t : rank_list) &#123;                if (t.name == q_name) &#123;                    cout &lt;&lt; t.rank &lt;&lt; &quot; &quot; &lt;&lt; t.id &lt;&lt; &quot; &quot; &lt;&lt; t.name &lt;&lt; &quot; &quot; &lt;&lt; t.solved &lt;&lt; &quot; &quot; &lt;&lt; t.penalty &lt;&lt; endl;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;]]></content>
  </entry>
  <entry>
    <title>蓝桥杯备赛笔记（全章节整理）</title>
    <url>/2025/12/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[蓝桥杯备赛笔记（全章节整理）Hello 大家好！这是我的蓝桥杯算法竞赛备赛笔记，主要基于C&#x2F;C++语言，涵盖蓝桥杯省赛、国赛的核心考点，章节与实际学习文件夹一一对应，持续更新中~
如果觉得笔记对你有帮助，欢迎点赞、收藏~ 😜
📚 笔记目录


章节编号
章节名称
核心内容



01
第一章-语言基础
C++基础语法、数据类型、输入输出优化


02
第二章-算法基础
枚举、模拟、贪心等基础算法


03
第三章-搜索
深度优先搜索（DFS）、广度优先搜索（BFS）


04
第四章-动态规划
线性DP、背包问题、状态转移等


05
第五章-字符串
string操作、字符串匹配、哈希等


06
第六章-数学
数论、组合数学、高精度计算


07
第七章-数据结构
数组、栈、队列、链表、二叉树


08
第八章-图论
图的存储、最短路、最小生成树


09
第九章-计算几何
点、线、多边形相关计算


10
OJ部分习题及解答
经典真题、模拟题解析与代码实现



📖 章节内容01. 第一章-语言基础
对应笔记：第一章-语言基础

本章涵盖蓝桥杯备赛的核心语言基础：C++变量定义、数据类型（int&#x2F;long long&#x2F;string）、输入输出优化、循环与分支语句等，是后续算法实现的必备知识。
点击上方链接查看完整内容~
02. 第二章-算法基础
对应笔记：第二章-算法基础

本章讲解蓝桥杯高频基础算法：暴力枚举（如统计方形问题）、模拟法（日期&#x2F;字符串模拟）、贪心策略，附带真题案例与代码实现。
点击上方链接查看完整内容~
03. 第三章-搜索
对应笔记：第三章-搜索

本章覆盖DFS（深度优先搜索）、BFS（广度优先搜索）的基本框架、剪枝技巧，以及蓝桥杯常见的搜索类真题（如迷宫问题、全排列）。
点击上方链接查看完整内容~
04. 第四章-动态规划
对应笔记：第四章-动态规划

本章讲解动态规划的核心思想，包括线性DP（最长上升子序列）、背包问题（01背包、完全背包）、状态转移方程的推导，附带真题解析。
点击上方链接查看完整内容~
05. 第五章-字符串
对应笔记：第五章-字符串

本章涵盖C++ string类的常用操作（substr&#x2F;find&#x2F;compare）、字符串匹配（KMP算法）、哈希字符串等蓝桥杯高频考点。
点击上方链接查看完整内容~
06. 第六章-数学
对应笔记：第六章-数学

本章讲解数论（质数、约数、模运算）、组合数学（排列组合）、高精度计算（大整数加减乘除）等蓝桥杯数学类考点。
点击上方链接查看完整内容~
07. 第七章-数据结构
对应笔记：第七章-数据结构

本章覆盖数组、栈、队列、链表、二叉树的基本操作，以及蓝桥杯常考的数据结构应用（如栈的括号匹配、队列的广度优先搜索）。
点击上方链接查看完整内容~
08. 第八章-图论
对应笔记：第八章-图论

本章讲解图的存储方式（邻接矩阵&#x2F;邻接表）、最短路算法（Dijkstra、Floyd）、最小生成树（Kruskal、Prim）等图论核心考点。
点击上方链接查看完整内容~
09. 第九章-计算几何
对应笔记：第九章-计算几何

本章涵盖计算几何的基础问题：点与线的距离、线段相交判断、多边形面积计算等，是蓝桥杯进阶考点。
点击上方链接查看完整内容~
10. OJ部分习题及解答
对应笔记：OJ部分习题及解答

本章整理蓝桥杯历年真题、模拟题的详细解答，包含题目分析、代码实现、优化思路，帮助巩固知识点。
点击上方链接查看完整内容~
]]></content>
      <categories>
        <category>编程竞赛</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>备赛笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>翁恺C语言学习笔记</title>
    <url>/2026/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%EF%BC%88%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[一、数据表达与计算模块1.1 存储单位换算这是最基础的送分题，但容易在“位”和“字节”上翻车。

核心换算： 
进率： 计算机中通常使用  () 作为进率。


$1\text{KB} &#x3D; 1024\text{B}$
$1\text{MB} &#x3D; 1024\text{KB}$
$1\text{GB} &#x3D; 1024\text{MB}$
$1\text{TB} &#x3D; 1024\text{GB}$


注意： 考试时看清是 bit（位&#x2F;比特）还是 Byte（字节）。


1.2 数制转换与对应关系需要掌握如何在二进制 (B)、八进制 (O)、十进制 (D) 和十六进制 (H) 之间快速切换。

十六进制与二进制（重点）： 记住“4位合1”原则。

例： 前四位 1010 是 A，后四位 1100 是 C，结果为 ACH。

十进制与十六进制对应：

0-9 对应 0-9

10-15 对应 A, B, C, D, E, F（必记：A=10, F=15）



详细讲讲十进制转二进制

整数部分：除 2 取余法 (Divide by 2)这是最熟悉的，核心逻辑是：倒序排列。

步骤： 将十进制整数除以 2，记录余数（0 或 1），得到的商继续除以 2，直到商为 0 为止。
结果： 将所有余数从后往前（从最后一次余数到第一次余数）排列。

例题：将十进制 $(13)_{10}$ 转换为二进制

$13 \div 2 &#x3D; 6 \dots \dots$余 1 (LSB，最低位)
$6 \div 2 &#x3D; 3 \dots \dots$余 0
$3 \div 2 &#x3D; 1 \dots \dots$余 1
$1 \div 2 &#x3D; 0 \dots \dots$余 1 (MSB，最高位)


结果： $(1101)_2$


小数部分：乘 2 取整法 (Multiply by 2)这是容易记混的地方，核心逻辑是：顺序排列。

步骤： 用十进制小数乘以 2，将乘积的整数部分（0 或 1）记录下来，再用剩余的小数部分继续乘以 2，直到小数部分为 0（或达到题目要求的精度）。
结果： 将记录的整数部分从前往后（从第一次到最后一次）排列。

例题：将十进制 $(0.625)_{10}$ 转换为二进制

$0.625 \times 2 &#x3D; 1.25 \dots \dots$取整 1
$0.25 \times 2 &#x3D; 0.5 \dots \dots$取整 0
$0.5 \times 2 &#x3D; 1.0 \dots \dots$取整 1 (小数部分变0，结束)


结果： $(0.101)_2$


进阶考点：无法精确转换的情况这是一个非常高频的考点： 并不是所有十进制小数都能转换成有限长度的二进制小数。

例子： 将 $0.2$ 转换为二进制。


$0.2 \times 2 &#x3D; 0.4 \dots 0$
$0.4 \times 2 &#x3D; 0.8 \dots 0$
$0.8 \times 2 &#x3D; 1.6 \dots 1$
$0.6 \times 2 &#x3D; 1.2 \dots 1$
$0.2 \times 2 &#x3D; 0.4 \dots 0$（开始循环了！）


结论：  在二进制下是 ****$0.0011\ 0011\dots$无限循环**。
考试坑点： 题目可能会问“为什么 $0.1 + 0.2$ 在计算机中不等于$0.3$ ？” 答案就是：因为部分十进制小数在转换为二进制时会产生精度丢失。


快速转换技巧（凑数法）对于比较小的数，考试时为了省时间，可以用“权值相加”的方法。记住 2 的幂次方：128, 64, 32, 16, 8, 4, 2, 1 | 0.5, 0.25, 0.125, 0.0625

例子： $10.75$
$10 &#x3D; 8 + 2 \rightarrow (1010)_2$
$0.75 &#x3D; 0.5 + 0.25 \rightarrow (0.11)_2$
合并： $(1010.11)_2$


1.3 详解：原码、反码、补码这部分是重灾区，记住一个铁律：正数的原、反、补三码合一（完全一样）；只有负数才需要复杂的转换。
1. 定义与转换流程（以8位字长为例）
原码： 最高位为符号位（0正1负），其余位表示数值。
反码： 符号位不变，数值位按位取反（0变1, 1变0）。
补码： 反码的基础上，在最低位 +1。

2. 经典例子对比


十进制数
原码 (符号+数值)
反码 (符号不变，数值取反)
补码 (反码+1)



+5
0000 0101
0000 0101
0000 0101 (三码合一)


-5
1000 0101
1111 1010
1111 1011


+0
0000 0000
0000 0000
0000 0000


-0
1000 0000
1111 1111
0000 0000 (唯一性!)


3. 补码求和运算公式： $[A+B]_补 &#x3D; [A]_补 + [B]_补$例题： 计算 $10 - 5$（即 $10 + (-5)$）

$[+10]_补 &#x3D; 0000\ 1010$
$[-5]_补 &#x3D; 1111\ 1011$
相加：

  0000 1010 (+10补)+ 1111 1011 (-5补)------------------ 10000 0101 (最高位进位舍弃) -&gt; 结果为 0000 0101 (即 +5)


1.4 汉字编码（国标码、机内码、字形码）考试常考这几种码之间的换算关系。
1. 汉字的“三码”关系
区位码： 国家标准局定义的坐标，由“区码”和“位码”组成。为了方便看，通常是十进制。
国标码 (交换码)： 汉字信息交换的标准。
机内码 (内码)： 计算机内部存储汉字的代码。特点： 两个字节的最高位都是 1（为了区别于 ASCII 码）。

2. 核心换算公式（必记！）
区位码 $\rightarrow$ 国标码：


(区码, 位码) 分别转换成十六进制，再加上 2020H。


国标码 $\rightarrow$ 机内码：


国标码直接加上 8080H。


区位码 $\rightarrow$ 机内码（终极公式）：


机内码 &#x3D; 区位码(十六进制) + A0A0H。

3. 例子假设某汉字区位码是 1601：

十六进制换算：16 是 10H，01 是 01H  1001H。
国标码： 1001H + 2020H = 3021H。
机内码： 3021H + 8080H = B0A1H。

4. 字形码（字库码）
作用： 用于显示和打印，由点阵组成（如 $16 \times 16$, $24 \times 24$）。
计算存储空间：
例：$16 \times 16$ 点阵汉字占用多少字节？
$16 \times 16 &#x3D; 256$个点（bit）。
换算成字节：$256 \div 8 &#x3D; 32$ 字节。


1.5 浮点数的“阶码”与“尾数”
阶码 (Exponent)： 指数部分。决定了浮点数的范围大小。如果阶码位数增加，能表示的数值范围就更大。
尾数 (Mantissa)： 有效数字部分。决定了浮点数的精度。如果尾数位数增加，计算结果就更精确。
溢出：
上溢：计算结果绝对值太大，超过阶码能表示的最大范围。
下溢：计算结果太接近 0（太小），通常当作 0 处理。


1.6 字符编码大小比较考试如果考排序，直接背这个顺序：空格 (32) &lt; 数字 (0-9) &lt; 大写字母 (A-Z) &lt; 小写字母 (a-z)

&#39;A&#39; 是 65 (十六进制 41H)
&#39;a&#39; 是 97 (十六进制 61H)
注意： 汉字的机内码最高位是 1，所以汉字内码 &gt; ASCII 码。


二、计算机体系结构2.1 存储层次结构（Memory Hierarchy）计算机并不是只用一种内存，而是采用“金字塔”式的层次结构。![[Pasted image 20260117160646.png]]

层次逻辑： 每一层都充当其下一层的 Cache（缓存）。例如，L1 缓存 L2 的内容，L2 缓存 L3 的内容，而主存（DRAM）缓存磁盘（Disk）的内容。
金字塔规律： 越往上，速度越快、成本越高、容量越小；越往下，速度越慢、成本越低、容量越大。
介质差异： 注意图中的标注，L1-L3 Cache 使用的是 SRAM（静态随机存储器），而主内存使用的是 DRAM（动态随机存储器）。SRAM 比 DRAM 快得多，但也贵得多。


1. 存储层次的目标
核心目标： 解决主存速度慢、容量小与 CPU 高速度之间的矛盾。
最终效果： 使得整个存储系统看起来既有 Cache 的高速度，又有硬盘的大容量，且成本可控。

2. Cache（高速缓冲存储器）(1) 高速缓存（Cache）的分类高速缓存是CPU与内存之间的“高速临时存储区”，按与CPU的距离分为三级：

L1 Cache（一级缓存）：距离CPU最近，速度最快、容量最小（通常几KB到几十KB），直接集成在CPU核心内；
L2 Cache（二级缓存）：速度、容量介于L1与L3之间（通常几十KB到几MB），部分CPU将其集成在核心内；
L3 Cache（三级缓存）：距离CPU最远，容量最大（通常几MB到几十MB），多为CPU核心共享的缓存。

(2) CPU、Cache、内存、外存的层级关系这四者构成了“速度从快到慢、容量从小到大”的存储层级，数据访问遵循“就近原则”：

CPU优先读取Cache中的数据（速度最快）；
若Cache中无所需数据，再读取内存（速度次之）；
若内存中也无数据，最后读取外存（如硬盘、U盘，速度最慢但容量最大）。

(3) 核心作用Cache的存在是为了缓解CPU与内存之间的速度差：CPU运算速度远快于内存读取速度，通过将CPU近期常用的数据暂存到Cache中，可减少CPU等待内存数据的时间，提升整体运行效率。

三级结构（L1&#x2F;L2&#x2F;L3）的目的： 进一步缓冲。L1 最快、容量最小且紧挨着核心；L3 相对慢一些但容量大，通常由多个核心共享。
速度对比： 寄存器 &gt; Cache &gt; 内存 (RAM) &gt; 硬盘。
Cache 的存取速度比内存快 10 到 100 倍。


工作原理： 基于程序局部性原理（时间局部性和空间局部性）。CPU 访问数据时先找 Cache，找不到再去内存。


2.2 CPU 组成与功能CPU 是大脑，主要由运算器、控制器和寄存器组成。
1. 运算器（Arithmetic Logic Unit, ALU）
核心部件： ALU（算术逻辑单元）。
ALU 的作用： 负责执行所有的算术运算（加减乘除）和逻辑运算（与、或、非、异或）。
辅助部件： 累加器 (AC)、状态寄存器 (PSW) 等。
考点提示： ALU 的输入通常来自寄存器（GPRs），输出结果要么写回寄存器，要么作为地址去访问内存。

2. 控制器
负责“发号施令”，决定什么时候取指令，什么时候分析指令。

3. CPU 直接读写的存储介质
重点考点： CPU 只能直接访问寄存器、Cache 和主存储器（内存）。
注意： CPU 不能直接访问外存（如硬盘、U 盘、光盘）。外存的数据必须先加载到内存，才能被 CPU 处理。


2.3 指令执行（Instruction Execution）1. 计算机直接执行的代码类型
机器语言： 只有二进制代码（0 和 1）是计算机唯一能直接识别并执行的语言。
注意：汇编语言和高级语言（C++, Python）都必须翻译成机器语言才能运行。

2. 指令周期顺序（必考步骤）一个指令的完整执行过程通常分为以下阶段：

取指令 (Fetch)： 从内存中取出指令送入指令寄存器。
分析指令&#x2F;译码 (Decode)： 翻译这行代码要做什么（是加法还是存数）。
执行指令 (Execute)： 发出控制信号，操作 ALU 或访问数据。
写回 (Write Back)： 将结果存回寄存器或内存。


下面给出示例![[Pasted image 20260117161016.png]]

这张图展示了高级语言（如 C 语言）变成计算机可执行代码的 四个必经阶段：

预处理 (Pre-processor)： 处理 #include 和宏定义，生成 .i 文件。
编译 (Compiler)： 将修改后的源码翻译成 汇编程序 (.s)。这是最核心的一步。
汇编 (Assembler)： 将汇编指令翻译成机器能够识别的 二进制目标程序 (.o)。此时它已经是二进制了，但还不能直接运行。
链接 (Linker)： 将你的 .o 文件和系统库文件（如 printf.o）合并，生成最终的 可执行目标文件。

3. 指令流水线技术 (Pipelining)
定义： 像工厂流水线一样，让多个指令的不同阶段重叠执行。
目的： 为了提高 CPU 的执行效率&#x2F;吞吐量，而不是缩短单个指令的执行时间。
例子： 取第 2 条指令的同时，CPU 正在分析第 1 条指令。![[Pasted image 20260117161210.png]]
并行原理： 它并不增加计算资源，而是通过“重叠执行”来提高利用率。
五级流水线（经典）：
Fetch (取指)：从指令存储器拿代码。
Decode (译码)：分析这行代码要干嘛，读取寄存器。
Execute (执行)：调用 ALU 进行计算。
Memory (访存)：如果需要，去数据内存读写数据。
Write-back (写回)：把结果写回寄存器。


性能提升：
超流水线 (Super-pipelining)： 将流水线分得更细（如 Pentium 4 的 20 段）。段数越多，时钟频率就能跑得越高。
超标量 (Superscalar)： 在硬件上提供多条流水线（如图 2 提到的 U 流水线和 V 流水线）。这意味着在同一个时刻，CPU 可以 同时执行两条或多条指令，前提是它们之间没有数据依赖。




⚠️ 总结避坑：
问： 流水线技术能缩短单条指令的执行时间吗？
答： 不能。 实际上，由于增加了流水线寄存器，单条指令的延迟反而可能略微增加。但它大幅提高了单位时间内完成指令的数量（即 吞吐量）。


Cache 的单位： Cache 空间很小，通常以 KB 或 MB 为单位，而内存是以 GB 为单位。
运算器 vs 控制器： 考试常问“ALU 属于什么？”，记得它是运算器的核心。
直接访问： 记住这句话——“CPU 和硬盘不熟，它们中间隔着内存”。


三、操作系统模块3.1 进程与线程（Process vs. Thread）这是操作系统最核心的概念，考试常考两者的区别与联系。
1. 进程（Process）
定义：进程是程序的一次执行过程，是系统进行资源分配和保护的基本单位。
特点：每个进程都有自己独立的地址空间（内存）、数据栈和资源句柄。

2. 线程（Thread）
定义：线程是进程内的一个执行单元，是系统独立调度和分派的基本单位（核心调度单位）。
线程的特点：
轻量级：线程的创建和销毁开销比进程小得多。
共享性：同一进程下的多个线程共享该进程的资源（如内存地址空间、全局变量、打开的文件），但拥有自己独立的栈和程序计数器。

3. 区别与联系（高频考点）
调度：线程是独立调度的基本单位，进程是拥有资源的基本单位。
并发性：进程间并发执行，同一进程内的多个线程也可以并发执行。
拥有资源：进程拥有完整的资源；线程基本上不拥有系统资源，但可以访问所属进程的资源。
系统开销：进程切换涉及整个 CPU 环境的保存和恢复（开销大）；线程切换只需保存和恢复少量寄存器内容（开销小）。
健壮性：一个进程崩溃不会影响其他进程；但一个线程崩溃，整个进程（及其所有线程）通常都会死掉。


3.2 资源管理操作系统本质上是一个资源管理者。
1. 操作系统核心功能操作系统主要负责四大管理任务：

处理器管理（进程调度）。
存储器管理（内存分配、回收、虚拟内存）。
设备管理（I&#x2F;O 设备驱动、分配）。
文件管理（数据的组织、存储、访问控制）。

2. 设备管理目标
主要目标：提高设备的利用率（让设备尽可能忙起来）和方便用户使用（用户不需要了解硬件底层细节，只需调用统一接口）。

3. 时间片（Time Slice）定义
定义：在分时操作系统中，系统分配给每个进程轮流使用 CPU 的一段固定时间长度。
意义：通过快速切换，给用户的感觉是多个程序在“同时”运行。


三、 进程调度与上下文切换1. 上下文切换（Context Switch）的定义当操作系统决定让正在运行的进程 A 暂停，转而运行进程 B 时，必须完成以下动作：

保存：将进程 A 的当前状态（包括 CPU 寄存器、程序计数器、内存管理信息等，即“上下文”）保存到内存的 PCB（进程控制块）中。
恢复：从内存中读取进程 B 之前保存的“上下文”，加载到 CPU 寄存器中，使 B 恢复运行。
考点：上下文切换是有开销的，切换过于频繁会降低系统有效工作时间。

2. 进程的三种基本状态（补充考点）考试常画图考这三者的转换：

就绪态 (Ready)：具备运行条件，等待分配 CPU。
运行态 (Running)：正在占用 CPU 运行。
等待&#x2F;阻塞态 (Blocked&#x2F;Waiting)：因等待某事件（如 I&#x2F;O 操作、等待信号量）而暂停运行。


💡 避坑小贴士：
易错题：问“计算机中资源分配的最小单位是什么？” 选 进程。
易错题：问“CPU 调度的基本单位是什么？” 选 线程。
逻辑题：线程之间共享内存，所以它们通信很快，但需要注意“同步”问题（防止大家同时改同一个变量）。


四、数据库模块4.1 关系模型（Relational Model）数据库的核心是“表”，而在学术上我们称之为“关系”。

元组的唯一性要求：

在关系模型中，表中的每一行被称为一个元组（Tuple）。

核心要求： 关系中的元组必须是唯一的，不允许出现完全重复的行。

实现方式： 通过定义**主键（Primary Key）**来保证唯一性，主键的值不能为空且不能重复。

属性（Attribute）： 表中的列。

域（Domain）： 属性的取值范围（例如“性别”属性的域是 {男, 女}）。



4.2 SQL 语言基础SQL 是结构化查询语言，是操作数据库的标准。
1. 查询语句类型（DQL&#x2F;DML&#x2F;DDL&#x2F;DCL）考试常考这几类操作的区别：

数据查询 (DQL)： SELECT（最常用）。
数据操纵 (DML)： INSERT (插入), UPDATE (更新), DELETE (删除)。—— 针对数据本身。
数据定义 (DDL)： CREATE (创建表), DROP (删除表), ALTER (修改表结构)。—— 针对表的结构。
数据控制 (DCL)： GRANT (授权), REVOKE (撤销权限)。—— 针对安全权限。

2. SELECT * 的作用
含义： * 是通配符，代表“所有列”。
作用： 从指定的表中检索出所有字段的数据。
例句： SELECT * FROM Students; 会列出学生表里所有学生的所有信息（姓名、学号、年龄等）。

3. SQL 的定义与约束
主码 (Primary Key)：唯一标识元组。如 PRIMARY KEY (Sno, Cno) 表示两个属性共同构成主键（复合主键）。
外码 (Foreign Key)：表之间的逻辑连接。如 FOREIGN KEY (Sno) REFERENCES S(Sno)。
唯一索引 (Unique Index)：通过 CREATE UNIQUE INDEX 提高查询效率并保证数据不重复。


4.3 DBMS 功能（数据库管理系统）DBMS 是位于用户和操作系统之间的支撑软件（如 MySQL, Oracle, SQL Server）。
1. 数据库系统的构成
DB (Database)：数据的集合。
DBMS (Database Management System)：管理数据库的系统软件（处于核心地位，连接硬件、操作系统和应用）。
DBA (Database Administrator)：数据库管理员（负责设计、安全和维护的人）。

2. DBMS 的主要功能
数据定义功能 (DDL)： 定义数据库的结构。
数据操纵功能 (DML)： 对数据进行增、删、改、查。
数据库的事务管理和运行管理： 保证数据的安全性、完整性以及多用户并发时的正确性。
数据库的建立和维护： 数据的导入导出、恢复和备份。

3. 数据操纵 vs 数据控制（易混淆点）


功能名称
英文
核心关注点
典型操作



数据操纵
DML
内容：对表里的数据进行处理
增加、修改、删除记录


数据控制
DCL
安全：谁能看，谁能改
权限授予、用户登录管理



4.4 补充考点：关系运算但“关系代数”经常伴随数据库出现，简单记一下：

投影 (Projection)： 选出特定的列（比如只要姓名）。
选择 (Selection)： 选出满足条件的行（比如只要年龄 &gt; 20 的）。
连接 (Join)： 把两张表拼在一起。


4.5 数据库模块综合大题题目背景： 某大学需要管理学生选课信息，现有三张表：

学生表 S (学号 Sno, 姓名 Sname, 性别 Sex)
课程表 C (课程号 Cno, 课程名 Cname, 学分 Credit)
选课表 SC (学号 Sno, 课程号 Cno, 成绩 Grade)


任务 1：数据定义 (DDL)请写出创建“选课表 SC”的 SQL 语句，要求：Sno 和 Cno 共同作为主码，且分别作为外码引用 S 表和 C 表。
CREATE TABLE SC (    Sno CHAR(5),    Cno CHAR(3),    Grade INT,    PRIMARY KEY (Sno, Cno),    FOREIGN KEY (Sno) REFERENCES S(Sno),    FOREIGN KEY (Cno) REFERENCES C(Cno));

任务 2：索引创建为了加快查询速度，请为学生表 S 的学号 Sno 创建一个唯一的升序索引，索引名为 Stusno。
CREATE UNIQUE INDEX Stusno ON S(Sno ASC);
任务 3：数据查询 (DQL - 核心)查询选修了课程名为“计算机导论”且成绩大于 90 分的学生学号和姓名。
SELECT S.Sno, S.SnameFROM S, C, SCWHERE C.Cname = &#x27;计算机导论&#x27;   AND S.Sno = SC.Sno   AND C.Cno = SC.Cno   AND SC.Grade &gt; 90;


注意：这里涉及了三表连接查询，必须在 WHERE 中写清连接条件 S.Sno = SC.Sno 等，否则会出现笛卡尔积错误。

任务 4：数据修改与删除 (DML)
将学号为 ‘001’ 的学生的“计算机导论”（课程号 ‘C01’）成绩修改为 100 分。

UPDATE SC SET Grade = 100 WHERE Sno = &#x27;001&#x27; AND Cno = &#x27;C01&#x27;;


删除所有成绩小于 60 分的选课记录。

DELETE FROM SC WHERE Grade &lt; 60;

💡 避坑小贴士：
区分 DROP 和 DELETE： DROP TABLE 是把整个表（包括结构和数据）都扔了；DELETE 只是把表里的数据删了，表的“壳子”还在。
元组顺序： 在关系模型中，元组的顺序并不重要，交换两行的位置不影响关系的本质。


SELECT * 的风险：虽然 SELECT * 方便，但在实际开发和大型考试中，明确列名（投影）更高效，也更安全。
主键唯一性：记住 PRIMARY KEY。只要主键确定了，这一行（元组）就必须是唯一的。
连接条件：看到复杂的 $\Pi$ 和 $\sigma$ 嵌套，转换成 SQL 时，别忘了把所有表都写在 FROM 里，把所有匹配条件写在 WHERE 里。


五、计算机编程模块5.1 语言类型与翻译方式1. 语言类型识别
机器语言：二进制代码，计算机唯一能直接识别的语言。
汇编语言：用助记符代替机器指令，需要汇编器 (Assembler) 翻译。
高级语言：接近自然语言和数学表达式。
面向对象 (Object-Oriented)：Java, C++, Python, C#。
过程化 (Procedural)：C, Pascal, Fortran。

2. 高级语言的翻译方式（必考区别）高级语言编写的源码必须经过“翻译”才能运行：

编译 (Compilation)：将源程序一次性全部翻译成目标程序（机器代码文件，如 .exe 或 .o），之后可直接运行。代表语言：C, C++。
解释 (Interpretation)：将源程序逐句翻译并立即执行，不产生独立的目标程序文件。代表语言：Python, JavaScript。

3. 三种编程范式
过程化范式 (Procedural Paradigm)：

核心：计算机按照程序员编写的指令顺序执行任务。
典型语言：C、Pascal、Fortran、机器语言和汇编语言。


面向对象范式 (Object-Oriented Paradigm)：

核心：计算机处理的是对象以及对象之间的关系，执行过程不一定按照顺序步骤进行。
关键概念：
类 (Class)：对象的模板。如定义的 Ppizza 类，它规定了披萨具有“形状”和“价格”等属性。
封装 (Encapsulation)：将数据和处理数据的方法（如 getSquareInchPrice()）包装在类中。
继承 (Inheritance)：子类自动获得父类的属性和方法。RectanglePizza 是 Pizza 类的子类，它继承了基础属性，并增加了长、宽等特有属性。


典型语言：Java、C++、Python、JavaScript。


声明性范式 (Declarative Paradigm)：

核心：程序员描述事实和规则，而不是具体的解决步骤。
代表：SQL、Prolog。




5.2 算法 (Algorithm)1. 算法的定义算法是解决特定问题的具体步骤和方法。它必须具备：有穷性（步骤有限）、确定性（无歧义）、可行性、输入（0个或多个）和输出（至少1个）。
2. 算法的表达形式
自然语言：用中文&#x2F;英文描述，易懂但易产生歧义。
流程图：用几何图形表示逻辑（如矩形表示处理，菱形表示判断）。
伪代码：介于自然语言和编程语言之间，侧重逻辑。

3. 算法的基本结构任何复杂的算法都可以由这三种基本结构组合而成：

顺序结构：按先后顺序执行。
分支结构（选择结构）：根据条件判断走不同的路径（if-else）。
循环结构：重复执行某段代码直到满足退出条件（for, while）。


5.3 编程范式：过程化 vs 面向对象这是理解现代软件开发的重点。



特性
过程化范式 (Procedural)
面向对象范式 (Object-Oriented)



核心思想
自顶向下，以“步骤”为中心（做什么？）
自底向上，以“事物”为中心（谁来做？）


基本单元
函数 &#x2F; 过程 (Function)
对象 &#x2F; 类 (Object &#x2F; Class)


优点
结构清晰，性能高，适合底层开发
易维护、易复用、适合大型复杂系统


缺点
数据与操作分离，大型项目维护难
运行开销相对较大，学习曲线较陡



5.4 程序错误 (Program Errors)程序出错不可怕，关键要分清类别，考试常考选择题。

语法错误 (Syntax Error)：


现象：不符合编程语言的规则（如少了个分号，括号不匹配）。
发现时机：编译阶段就会报错，程序无法运行。


逻辑错误 (Logic Error &#x2F; Semantic Error)：


现象：程序能跑，但结果不对（如算加法写成了减法）。
发现时机：运行后发现输出不符合预期，是最难查的错误。


运行时错误 (Runtime Error)：


现象：程序运行过程中突然崩溃（如除以0、内存溢出）。
发现时机：执行阶段。


5.5 补充1. UML 图（统一建模语言）
类图 (Class Diagram)：最常用。用矩形表示类，分为三层：类名、属性（变量）、方法（函数）。
关系表达：在 UML 中，继承关系通常用带空心三角形的实线表示（从子类指向父类）。

例题：定义一个至少具有四个属性的名为People的类，并创建两个名为Students和Instructors的People的子类，用代码或UML图表示即可。
classDiagram    class People &#123;        +String name        +int age        +String gender        +String idNumber        +eat()        +sleep()    &#125;    class Students &#123;        +String studentID        +float GPA        +study()        +takeExam()    &#125;    class Instructors &#123;        +String employeeID        +String department        +teach()        +assignHomework()    &#125;    People &lt;|-- Students : 继承 (Inheritance)    People &lt;|-- Instructors : 继承 (Inheritance)

类结构 (Class Structure)：
每个矩形代表一个类 (Class)。
顶部是类名，中间是属性 (Attributes&#x2F;Fields)，底部是方法 (Methods&#x2F;Functions)。


继承与多态 (Inheritance)：
Students 和 Instructors 自动拥有了 People 的四个基础属性（姓名、年龄、性别、身份证号），这就是继承的威力。
子类可以在继承的基础上增加自己特有的属性（如学生的 GPA，教师的 department）。


封装 (Encapsulation)：
属性名前的 + 号代表 public（公开），这体现了将数据和操作包装在一起的封装思想。


范式识别：
这种以“类”和“对象”为核心的设计属于面向对象范式 (Object-Oriented Paradigm)。



2. Prolog 逻辑编程Prolog 是一种独特的声明性语言，主要用于人工智能和逻辑推理。

事实 (Fact)：提供解决问题的基本信息。
语法规范：
事实以小写字母开头，以句点结尾。
参数放在圆括号中，用逗号分隔。
例子：shapeof(pizza,round). 表示“披萨的形状是圆的”这一事实。




💡 考前避坑：
注意区分：汇编语言不是高级语言，它属于低级语言，虽然它用了英文单词。
算法 vs 程序：算法是解决问题的逻辑，程序是算法在计算机上的具体实现。一个算法可以用多种语言写成程序。
OOP 特性：如果题目提到“封装、继承、多态”，指的一定是面向对象。


六、计算机网络模块6.1 网络架构模式：C&#x2F;S vs B&#x2F;S这是关于“软件长在哪”的问题。

C&#x2F;S (Client&#x2F;Server，客户端&#x2F;服务器)

定义：用户必须安装专门的客户端软件才能使用（如：微信电脑版、英雄联盟、大型数据库客户端）。

优点：响应速度快（本地处理一部分逻辑）、图形表现力强、安全性较高。

缺点：安装麻烦、更新代价大（每个客户端都要升级）。

B&#x2F;S (Browser&#x2F;Server，浏览器&#x2F;服务器)

定义：用户只需通过浏览器（Chrome, Edge）访问特定的网址即可使用（如：网页版微博、在线教务系统）。

优点：无需安装、维护简单（只用更新服务器）、跨平台性强。

缺点：受限于浏览器性能、安全性控制相对较难。



6.2 核心网络模型：OSI 七层 vs TCP&#x2F;IP 四层这是考试最喜欢考的对应关系图。OSI 是理论标准，TCP&#x2F;IP 是事实上的工业标准。



OSI 七层参考模型
TCP&#x2F;IP 四层模型
功能简述
协议&#x2F;设备举例



应用层 (Application)
应用层
用户接口，直接面向程序
HTTP, FTP, DNS, SMTP


表示层 (Presentation)
(合并到应用层)
格式转换、加密解密
-


会话层 (Session)
(合并到应用层)
建立、管理、终止会话
-


传输层 (Transport)
传输层
提供端到端的数据传输
TCP, UDP


网络层 (Network)
网络层 (或网际层)
寻址和路由选择（主机到主机）
IP, ICMP, 路由器


数据链路层 (Data Link)
网络接口层
物理地址寻址（MAC）、成帧
以太网协议, 交换机


物理层 (Physical)
网络接口层
透明传输比特流（0和1）
网线, 集线器



6.3 传输层协议：TCP 与 UDP 的区别这是必考的对比选择题。

TCP (Transmission Control Protocol, 传输控制协议)

特性：面向连接、可靠、有序。

机制：三次握手（建立连接）、确认应答、超时重传。

适用场景：对准确性要求极高的场景，如文件传输（FTP）、网页浏览（HTTP）、邮件（SMTP）。

UDP (User Datagram Protocol, 用户数据报协议)

特性：无连接、不可靠、尽力而为。

优点：开销小、速度极快、延迟低。

适用场景：对实时性要求极高、丢一点包没关系的场景，如视频会议、在线直播、网络电话、多人在线游戏。



6.4 网络地址与寻址(1) IP 地址：IPv4 vs IPv6
IPv4：32 位二进制，通常用“点分十进制”表示（如 192.168.1.1）。地址空间已耗尽。
IPv6：128 位二进制，用“冒号十六进制”表示。它解决了地址枯竭问题，可以给地球上每一粒沙子分配一个 IP。

(2) URL (统一资源定位符) 的组成URL 是我们在浏览器输入的完整地址，格式如下：协议名://域名:端口号/路径/文件名
例子：https://www.example.com:8080/news/index.html

https：协议（Protocol）。
www.example.com：域名（Host），通过 DNS 翻译成 IP。
8080：端口号（Port），默认为 80（HTTP）或 443（HTTPS）时常省略。
/news/：路径。
index.html：文件名。


6.5 补充1. 计算机网络的类型（按覆盖范围划分）这是最基础的分类方式，主要考察覆盖距离。

个人区域网 (PAN, Personal Area Network)：如手机与蓝牙耳机连接，范围几米。
局域网 (LAN, Local Area Network)：覆盖一栋大楼或一个校园，传输速率高，延迟低。
城域网 (MAN, Metropolitan Area Network)：覆盖一个城市。
广域网 (WAN, Wide Area Network)：覆盖国家、洲甚至全球。因特网 (Internet) 是世界上最大的广域网。


2. 网络拓扑结构 (Topology)指的是网络中节点（电脑、路由器）的物理或逻辑连接布局。

星型拓扑 (Star)：所有节点连接到中心节点（如交换机）。

特点：易于管理，中心节点坏了全网瘫痪。

总线型拓扑 (Bus)：所有节点共享一根主传输线（总线）。

特点：结构简单，但总线忙时效率低。

环型拓扑 (Ring)：节点连成一个闭合环。

特点：信号单向传输，一个节点断开全网中断。

网状拓扑 (Mesh)：节点间有多条路径相连。

特点：可靠性最高（冗余强），常用于广域网核心，但成本高。



3. IP 地址的划分（重点计算题型）IPv4 地址（32 位）最初是按“类”来划分的，你需要记住每一类的第一个字节范围。
(1) 有类地址划分


类别
首字节范围 (十进制)
网络号&#x2F;主机号长度
适用规模



A 类
1 ~ 126
8位 &#x2F; 24位
超大型网络（如跨国巨头）


B 类
128 ~ 191
16位 &#x2F; 16位
中型网络（如大学、大企业）


C 类
192 ~ 223
24位 &#x2F; 8位
小型网络（如小公司、实验室）


D 类
224 ~ 239
多播地址
组播使用


E 类
240 ~ 255
保留地址
科学研究



注意： 127.x.x.x 是回环地址（Loopback），用于测试本机网络协议栈是否正常。

(2) 子网掩码 (Subnet Mask)
作用：用来区分 IP 地址中哪部分是“网络号”，哪部分是“主机号”。
标准掩码：
A 类：255.0.0.0
B 类：255.255.0.0
C 类：255.255.255.0


4. 特殊 IP 与保留地址
私有地址 (Private IP)：
这类地址在因特网上是不路由的，仅限内部局域网使用，通过 NAT (网络地址转换) 访问外网。
常见：192.168.x.x, 10.x.x.x, 172.16.x.x。
广播地址：主机号全为 1 的地址（如 192.168.1.255）。
网络地址：主机号全为 0 的地址（如 192.168.1.0）。


✍️ 考前针对性练习题 1： 当你在观看世界杯决赛直播时，如果网络偶尔卡顿，画面出现短暂的马赛克但随后恢复正常，这通常是由于底层使用了什么协议？

答案：UDP。因为它不重传丢掉的包，所以画面会花，但保证了直播的实时性。

题 2： 在 OSI 模型中，负责“路径选择”和“逻辑寻址”的是哪一层？

答案：网络层（记住：路由器的地盘就在网络层）。

题 3： 判断：在 B&#x2F;S 架构中，用户端的所有计算逻辑都必须在浏览器中完成。

答案：错。绝大部分核心业务逻辑是在后端的服务器上运行的。

题 2： 某公司分配到的 IP 地址是 172.16.10.5，请问它属于哪一类地址？其默认子网掩码是什么？

答案：属于 B 类（172 在 128~191 之间）。默认掩码为 255.255.0.0。

题 2： 如果你家里的几台设备通过同一个路由器上网，每台设备都有一个 192.168.x.x 的地址，这个地址属于？

答案：C 类地址，且属于私有地址。


]]></content>
  </entry>
  <entry>
    <title>C语言程序设计基础(2025秋)</title>
    <url>/2025/11/29/SCU_C_Programming_2025_fall/</url>
    <content><![CDATA[我的课程笔记 - C语言程序设计（2025秋）🌟 SCU程序设计基础-软件(2025秋)总览这里汇总了 SCU程序设计基础-软件(2025秋) 的历次作业题目和我的个人解答，点击标题可进入对应内容页面：
必做
必做07 
必做08
必做09

选做
选做01
选做09



📌 说明：所有笔记持续更新，点击链接直接跳转到对应页面，返回总览可点击顶部导航栏的“SCU程序设计基础-软件(2025秋)总览”。

]]></content>
  </entry>
  <entry>
    <title>翁恺C语言学习笔记</title>
    <url>/2026/01/24/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[变量和简单数据类型变量message = &quot;hello world!&quot;print(message)

字符串字符串(string)就是一串字符。在Python中用引号引起的都是字符串（单、双引号都可以）
&quot;This is a string.&quot;&#x27;This is a string.&#x27;
使用方法修改字符串的大小写name = &quot;ada lovelace&quot;print(name.title())print(name.upper())print(name.lower())
在字符串中使用变量first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;print(full_name)
结果如下
ada lovelace

要在字符串中插入变量的值，可先在左引号前加上字母f，要将要插入的变量放在花括号内，这样py在显示字符串时，会把每个变量替换成其值，这成为f字符串，f是format简写

可以用f字符串实现很多任务
01first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;print(f&quot;hello, &#123;full_name.title()&#125;!&quot;)

这串代码实现了一个格式良好的问候语

hello, Ada Lovelace!

02创建消息first_name = &quot;ada&quot;last_name = &quot;lovelace&quot;full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;message = f&quot;hello, &#123;full_name.title()&#125;!&quot;print(message)

使用制表符或换行符来添加空白print(&quot;languages:\n\tPython\n\tC\n\tJavaScript&quot;)
结果
languages:        Python        C        JavaScript

删除空白&#39;python&#39;和&#39;python &#39;是不一样的字符串，有时删除这样的空白意义重大下来的实验应该在终端完成
&gt;&gt;&gt; favorite_language = &#x27; python &#x27;&gt;&gt;&gt; favorite_language&#x27; python &#x27;&gt;&gt;&gt; favorite_language.rstrip()&#x27; python&#x27;&gt;&gt;&gt; favorite_language&#x27; python &#x27;&gt;&gt;&gt; favorite_language = favorite_language.lstrip()&gt;&gt;&gt; favorite_language&#x27;python &#x27;&gt;&gt;&gt; favorite_language = favorite_language.strip()&gt;&gt;&gt; favorite_language&#x27;python&#x27;
删除前缀、后缀使用removeprefix()和removesuffix()
&gt;&gt;&gt; url = &#x27;https://text.org&#x27;&gt;&gt;&gt; simple_url = url.removeprefix(&#x27;https://&#x27;)&gt;&gt;&gt; simple_url&#x27;text.org&#x27;

&gt;&gt;&gt; filename = &#x27;python_notes.md&#x27;&gt;&gt;&gt; simple_filename = filename.removesuffix(&#x27;.md&#x27;)&gt;&gt;&gt; simple_filename&#x27;python_notes&#x27;

数整数print(2+3)print(3-2)print(2*3)print(3/2)  #带小数print(3**2) #乘方运算print(2 + 3*4)print((2+3)*4)
结果
5161.591420

浮点数一般来说，py会按照期望的方式处理
&gt;&gt;&gt; 0.1 + 0.10.2&gt;&gt;&gt; 2*0.10.2&gt;&gt;&gt; 0.2 + 0.10.30000000000000004&gt;&gt;&gt; 3*0.10.30000000000000004

由于浮点数的表示方式，某些小数是不精确的

整数和浮点数只要有操作数是浮点数，结果就是浮点数，任意两个整数相除，结果也总是浮点数
&gt;&gt;&gt; 4/22.0&gt;&gt;&gt; 1 + 2.03.0

数中的下划线在书写很大的数时可以用_分组，但是py不会打印这些下划线
universe_age = 14_000_000_000print(universe_age)

14000000000

同时给多个变量赋值x,y,z = 0,1,2

常量py没有内置的常量类型通常用全大写字母来指出其值应始终不变
MAX_NUM = 5000

注释在py中用#标识注释
#一个小注释print(&quot;hello&quot;)

Python之禅在终端打出import this
&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those!

列表简介列表(list)指由一系列按特定顺序排列的元素组成在py中用[]来表示列表，用逗号来分隔其中的元素
bicycles = [&#x27;trek&#x27;,&#x27;cannondale&#x27;,&#x27;redline&#x27;]print(bicycles)

[&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;]

打印会打印列表的全部

访问列表元素这与数组有相似之处，列表名称[索引]。(索引从0开始)
print(bicycles[0])
那么因为bicycles[0]是字符串，所有对字符串的操作都可以直接用
print(bicycles[0].title())

python提供了负数索引
print(bicycles[-1]) #这回打印最后一个元素print(bicycles[-2]) #这会打印倒数第二个元素

使用列表中的各个值可以像变量一样使用列表中的各个值
message = f&quot;My bicycle is a &#123;bicycles[0]&#125;.&quot;print(message)

修改、添加和删除元素修改motocycles = [&#x27;honda&#x27;,&#x27;yamaha&#x27;,&#x27;suzuki&#x27;]print(motocycles)motocycles[0] = &#x27;ducati&#x27;print(motocycles)

[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;][&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]

添加在末尾添加使用append()添加
motocycles.append(&#x27;ducati&#x27;)print(motocycles)

[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]

可以使用append()动态创建一个列表
motocycles = []motocycles.append(&#x27;honda&#x27;)motocycles.append(&#x27;yamaha&#x27;)motocycles.append(&#x27;suzuki&#x27;)print(motocycles)

在列表中插入元素使用insert()在任意位置添加新元素
motocycles.insert(0,&#x27;ducati&#x27;)

这个操作将&#39;ducati&#39;插入到索引0的位置，每个既有元素位置都后移一位

删除使用del语句删除元素motocycles = [&#x27;honda&#x27;,&#x27;yamaha&#x27;,&#x27;suzuki&#x27;]del motocycles[0]print(motocycles)

[&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]

使用pop()方法删除元素删除列表末尾，并可以接着使用它，列表就像一个栈，删除末尾元素就像弹出栈顶元素
motocycles = [&#x27;honda&#x27;,&#x27;yamaha&#x27;,&#x27;suzuki&#x27;]print(motocycles)poped_motocycle = motocycles.pop()print(motocycles)print(poped_motocycle)

[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;][&#x27;honda&#x27;, &#x27;yamaha&#x27;]suzuki
实际上，pop()也可以删除别的位置的元素，只需加上索引
motocycles = [&#x27;honda&#x27;,&#x27;yamaha&#x27;,&#x27;suzuki&#x27;]print(motocycles)poped_motocycle = motocycles.pop(1)print(motocycles)print(poped_motocycle)

[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;][&#x27;honda&#x27;, &#x27;suzuki&#x27;]yamaha

根据值删除元素索引未知的情况下，使用remove()方法删除
motocycles = [&#x27;honda&#x27;,&#x27;yamaha&#x27;,&#x27;suzuki&#x27;,&#x27;ducati&#x27;]print(motocycles)motocycles.remove(&#x27;ducati&#x27;)print(motocycles)

[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;][&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]

remove()只能删除第一个指定的值，若列表中多次出现，需要使用循环来确保每个值都删除

管理列表使用sort()方法对列表进行永久排序cars = [&#x27;bmw&#x27;,&#x27;audi&#x27;,&#x27;toyota&#x27;,&#x27;subaru&#x27;]cars.sort()print(cars)

[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]

现在汽车是按字母顺序排序的，还可以按相反顺序排序

cars.sort(reverse=True)

[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]

使用sorted()函数对列表进行临时排序保留原来的顺序，并以特定的顺序来呈现它们
cars = [&#x27;bmw&#x27;,&#x27;audi&#x27;,&#x27;toyota&#x27;,&#x27;subaru&#x27;]print(&quot;Original list:&quot;)print(cars)print(&quot;\nSorted list:&quot;)print(sorted(cars))print(&quot;\nOriginal list again:&quot;)print(cars)

Original list:[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]Sorted list:[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]Original list again:[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]

在并非所有字母都是小写的情况下时，稍复杂一点，要指定准确的排列顺序

反向打印列表使用reverse()方法反转列表
cars = [&#x27;bmw&#x27;,&#x27;audi&#x27;,&#x27;toyota&#x27;,&#x27;subaru&#x27;]print(cars)cars.reverse()print(cars)

[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;][&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]

确定列表的长度使用len()函数可以快速获得列表长度
&gt;&gt;&gt; cars = [&#x27;bmw&#x27;,&#x27;audi&#x27;,&#x27;toyota&#x27;,&#x27;subaru&#x27;]&gt;&gt;&gt; len(cars)4

操作列表遍历整个列表magicians = [&#x27;alice&#x27;,&#x27;david&#x27;,&#x27;carolina&#x27;]for magician in magicians: #magician 是临时变量，通常建议使用与列表相关联的命名    print(magician)

alicedavidcarolina

在for循环中执行更多操作在for循环后面的每一行缩进都是循环的一部分
magicians = [&#x27;alice&#x27;,&#x27;david&#x27;,&#x27;carolina&#x27;]for magician in magicians:  #magician 是临时变量，通常建议使用与列表相关联的命名    print(f&quot;&#123;magician.title()&#125;, that is a great trick!&quot;)    print(&quot;I can&#x27;t wait to see your next trick&quot;)

Alice, that is a great trick!I can&#x27;t wait to see your next trickDavid, that is a great trick!I can&#x27;t wait to see your next trickCarolina, that is a great trick!I can&#x27;t wait to see your next trick


python 根据缩进来判断代码行与其他部分的关系，必须注意！！！

创建数值列表使用range()函数for val in range(1,5):    print(val)

1234

注意：不会打印5，到达指定的第二个数是就会停止

使用range()函数创建数值列表可使用list()函数将range()函数的结果直接转化为列表
nums = list(range(1,6))print(nums)

[1, 2, 3, 4, 5]

使用range()函数时还可以指定步长
even_nums = list(range(2,11,2))print(even_nums)

[2, 4, 6, 8, 10]

还可以创建别的数值列表
square_nums = []for val in range(1,11):    square_nums.append(val**2)print(square_nums)

[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

对数值列表执行简单的统计计算有几个函数可以快速处理
&gt;&gt;&gt; nums = [1,2,3,7,8,9,12,23,4,5,6]&gt;&gt;&gt; min(nums)1&gt;&gt;&gt; max(nums)23&gt;&gt;&gt; sum(nums)80

列表推导式列表推导式将for循环和创建新元素的代码合并到一行，并自动追加新元素
squares = [val**2 for val in range(1,11)]print(squares)

[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

使用列表的一部分切片(slice)players = [&#x27;charles&#x27;,&#x27;martina&#x27;,&#x27;michael&#x27;,&#x27;florence&#x27;,&#x27;eli&#x27;]print(players[0:3])# 没有指定第一个索引，将自动从头开始print(players[:4])# 同理print(players[2:])# 倒数后三个print(players[-3:])# 还可以改变步长print(players[0:8:2])

[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;][&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;][&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;][&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;][&#x27;charles&#x27;, &#x27;michael&#x27;, &#x27;eli&#x27;]

遍历切片players = [&#x27;charles&#x27;,&#x27;martina&#x27;,&#x27;michael&#x27;,&#x27;florence&#x27;,&#x27;eli&#x27;]for player in players[:3]:    print(player.title())

CharlesMartinaMichael

复制列表my_foods = [&#x27;pizza&#x27;,&#x27;falafel&#x27;,&#x27;carrot cake&#x27;]friend_foods = my_foods[:]print(&quot;My favorite foods are:&quot;)print(my_foods)print(&quot;\nMy friend&#x27;s favorite are:&quot;)print(friend_foods)

My favorite foods are:[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]My friend&#x27;s favorite are:[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]
核心是使用切片来复制列表而不是
friend_foods = my_foods

这是将新变量friend_foods关联到my_foods，这两个将始终相同

元组不可变的列表称为元组(tuple)
定义元组使用()来标识
dimensions = (200,50)print(dimensions[0])print(dimensions[1])

20050

假如修改元组的值
dimensions[0] = 250

Traceback (most recent call last):  File &quot;e:\learn\Python_learning\dimensions.py&quot;, line 4, in &lt;module&gt;    dimensions[0] = 250    ~~~~~~~~~~^^^TypeError: &#x27;tuple&#x27; object does not support item assignment


注意：严格来说，元组是由,标识的，如果只定义一个只包含一个元素的元组，必须在这个元素后面加上逗号

遍历元组中的所有值for dimension in dimensions:    print(dimension)

修改元组变量可以给元组整个重新赋值
dimensions = (200,50)print(&quot;Original tuple:&quot;)for dimension in dimensions:    print(dimension)dimensions = (400,100)print(&quot;\nModified tuple:&quot;)for dimension in dimensions:    print(dimension)

Original tuple:20050Modified tuple:400100

设置代码格式(PEP8)PEP8 是 Python Enhancement Proposal 8 的缩写，它是 Python 官方推荐的代码风格指南，核心目的是让所有Python开发者的代码风格保持一致，提升代码的可读性和维护性。
1. 缩进（最基础也最重要）
必须使用 4个空格 作为一个缩进级别，禁止使用Tab（如果编辑器混用了Tab和空格，会报语法错误）；
换行后的续行，缩进要比上一行多4个空格，或对齐到括号&#x2F;等号的位置：# 正确total = (first_num         + second_num         - third_num)# 正确（续行缩进4个空格）def calculate(a, b, c):    return a * b + \        c / 2

2. 行长度
一行代码的字符数不超过79个（注释行不超过72个），过长时拆分成多行，提升可读性；
例外：URL、长字符串常量、命令行指令等可适当放宽，但尽量遵循。

3. 空行
函数&#x2F;类之间用 2个空行 分隔；
函数内部的逻辑块之间用 1个空行 分隔，区分不同功能：def func1():    passdef func2():    # 逻辑块1    a = 1    b = 2        # 逻辑块2（空行分隔）    c = a + b    return c

4. 空格使用规范
运算符（+、=、* 等）两侧加1个空格，括号内侧不加空格：# 正确x = 10 + 20 * (30 - 5)if (x &gt; 0) and (y &lt; 10):    pass# 错误x=10+20*(30-5)  # 运算符无空格if ( x &gt; 0 ) and ( y &lt; 10 ):  # 括号内侧加了空格    pass
逗号、分号后加1个空格，前面不加：# 正确fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]for i in range(1, 10):    pass

5. 命名规范这是新手最容易混乱的点，PEP8明确了不同对象的命名规则：



类型
命名方式
示例



变量&#x2F;函数
小写+下划线
user_name、get_score()


常量
大写+下划线
MAX_SIZE、PI = 3.14159


类
大驼峰（首字母大写）
Student、UserInfo


6. 导入规范
导入语句放在文件顶部，按“标准库→第三方库→自定义模块”的顺序，每组之间用空行分隔；
禁止一行导入多个模块，优先使用绝对导入：# 正确import osimport sysimport requestsimport pandas as pdfrom my_project import utils

7. 注释
单行注释用 #，且 # 后加1个空格；
注释要简洁、准确，只注释“为什么这么做”，而非“做了什么”（代码本身能看懂的逻辑无需注释）：# 错误（废话注释）# 给x赋值10x = 10# 正确（解释原因）# 初始值设为10，兼容老版本接口的默认参数x = 10

if语句条件测试检查是否相等使用相等运算符==
&gt;&gt;&gt; car = &#x27;bmw&#x27;&gt;&gt;&gt; car == &#x27;bmw&#x27;True&gt;&gt;&gt; car == &#x27;audi&#x27;False
在检查相等时，忽略大小写
&gt;&gt;&gt; car = &#x27;Audi&#x27;&gt;&gt;&gt; car == &#x27;audi&#x27;False&gt;&gt;&gt; car.lower() == &#x27;audi&#x27;True
检查是否不等使用!=
requested_topping = &#x27;mushrooms&#x27;if requested_topping != &#x27;anchovies&#x27;:    print(&quot;Hold the anchovies!&quot;)

Hold the anchovies!

数值比较&gt;&gt;&gt; age = 19&gt;&gt;&gt; age == 19True&gt;&gt;&gt; age != 9True&gt;&gt;&gt; age &gt; 8True&gt;&gt;&gt; age &gt;= 20False&gt;&gt;&gt; age &lt;= 19True

检查多个条件1.使用and检查多个条件&gt;&gt;&gt; age_0 &gt;= 21 and age_1 &gt;= 21False&gt;&gt;&gt; age_1 = 22&gt;&gt;&gt; age_0 &gt;= 21 and age_1 &gt;= 21True
2.使用or检查多个条件&gt;&gt;&gt; age_0 = 22&gt;&gt;&gt; age_1 = 18&gt;&gt;&gt; age_0 &gt;= 21 or age_1 &gt;= 21True&gt;&gt;&gt; age_0 = 18&gt;&gt;&gt; age_0 &gt;= 21 or age_1 &gt;= 21False

检查特定的值是否在列表中使用in
&gt;&gt;&gt; requested_topping = [&#x27;mushrooms&#x27;,&#x27;onions&#x27;,&#x27;pineapple&#x27;]&gt;&gt;&gt; &#x27;mushrooms&#x27; in requested_toppingTrue&gt;&gt;&gt; &#x27;pepperoni&#x27; in requested_toppingFalse
那么是否不在就使用not in
banned_users = [&#x27;andrew&#x27;,&#x27;carolina&#x27;,&#x27;david&#x27;]user = &#x27;marie&#x27;if user not in banned_users:    print(f&quot;&#123;user.title()&#125;,you can post a response if you wish.&quot;)

Marie,you can post a response if you wish.

布尔表达式在跟踪程序状态或程序中重要的条件方面，布尔值提供了一种高效的方式
game_active = Truecan_edit = False

首字母大写哦

if语句if语句和if-else语句都是很简单的，skip
if-elif-elseage = 12if age &lt; 4:    print(&quot;Your admission cost is $0.&quot;)elif age &lt; 18:    print(&quot;Your admission cost is $25.&quot;)else:    print(&quot;Your admission cost is $40.&quot;)

为了让程序更简洁,可以统一出口
age = 12if age &lt; 4:    price = 0elif age &lt; 18:    price = 25else:    price = 40print(f&quot;Your admission cost is $&#123;price&#125;&quot;)
可以使用多个elif，也可以省略else
测试多个条件这需要多个独立的if语句。而不是使用if-elif-else语句（这会导致，只要有一个成立，余下的不会执行）
requested_topping = [&#x27;mushrooms&#x27;,&#x27;onions&#x27;,&#x27;pineapple&#x27;]if &#x27;mushrooms&#x27; in requested_topping:    print(&quot;Adding mushrooms&quot;)if &#x27;pepperoni&#x27; in requested_topping:    print(&quot;Adding pepperoni&quot;)print(&quot;\nFinished making your pizza.&quot;)

使用if语句处理列表检查特殊元素requested_topping = [&#x27;mushrooms&#x27;,&#x27;onions&#x27;,&#x27;pineapple&#x27;]if &#x27;mushrooms&#x27; in requested_topping:    print(&quot;Adding mushrooms&quot;)if &#x27;pepperoni&#x27; in requested_topping:    print(&quot;Adding pepperoni&quot;)  print(&quot;\nFinished making your pizza.&quot;)

Adding mushroomsAdding onionsAdding pineappleSorry, we are out of green peppers.Finished making your pizza!
确定列表非空requested_toppings = []if requested_toppings:    for topping in requested_toppings:        if topping == &#x27;green peppers&#x27;:            print(&quot;Sorry, we are out of green peppers.&quot;)        else:            print(f&quot;Adding &#123;topping&#125;&quot;)    print(&quot;\nFinished making your pizza!&quot;)else:    print(&quot;Are you sure you want a plain pizza?&quot;)

Are you sure you want a plain pizza?

使用多个列表available_toppings = [&#x27;mushrooms&#x27;,&#x27;onions&#x27;,&#x27;pineapple&#x27;,                      &#x27;pepperoni&#x27;,&#x27;olives&#x27;,&#x27;extra cheese&#x27;]requested_toppings = [&#x27;mushrooms&#x27;,&#x27;french fries&#x27;,&#x27;extra cheese&#x27;]for requested_topping in requested_toppings:    if requested_topping in available_toppings:        print(f&quot;Adding &#123;requested_topping&#125;&quot;)    else:        print(f&quot;Sorry, we don&#x27;t have &#123;requested_topping&#125;&quot;)print(&quot;\nFinished making your pizza.&quot;)

Adding mushroomsSorry, we don&#x27;t have french friesAdding extra cheeseFinished making your pizza.

字典一个简单的字典alien_0 = &#123;&#x27;color&#x27;: &#x27;green&#x27;,&#x27;points&#x27;: 5&#125;print(alien_0[&#x27;color&#x27;])print(alien_0[&#x27;points&#x27;])

green5

使用字典字典是一系列的键值对，每个键与一个值相关联
访问字典中的值想上面那样
new_points = alien_0[&#x27;points&#x27;]
添加键值对alien_0[&#x27;x_pos&#x27;] = 0alien_0[&#x27;y_pos&#x27;] = 25print(alien_0)

&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_pos&#x27;: 0, &#x27;y_pos&#x27;: 25&#125;

从创建一个空字典开始存储大量数据或编写自动生成键值对的代码通常需要定义一个空字典
修改字典中的值alien_0 = &#123;&#x27;x_pos&#x27;: 0,&#x27;y_pos&#x27;: 25,&#x27;speed&#x27;: &#x27;medium&#x27;&#125;print(f&quot;Original pos: &#123;alien_0[&#x27;x_pos&#x27;]&#125;&quot;)if alien_0[&#x27;speed&#x27;] == &#x27;slow&#x27;:    x_increment = 1elif alien_0[&#x27;speed&#x27;] == &#x27;medium&#x27;:    x_increment = 2else:    # 移动速度非常快    x_increment = 3alien_0[&#x27;x_pos&#x27;] = alien_0[&#x27;x_pos&#x27;] + x_incrementprint(f&quot;Now pos: &#123;alien_0[&#x27;x_pos&#x27;]&#125;&quot;)

Original pos: 0Now pos: 2
删除键值对使用del删除
del alien_0[&#x27;color&#x27;]print(alien_0)

&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_pos&#x27;: 0, &#x27;y_pos&#x27;: 25&#125;&#123;&#x27;points&#x27;: 5, &#x27;x_pos&#x27;: 0, &#x27;y_pos&#x27;: 25&#125;

由类似的对象组成的字典favorite_language = &#123;    &#x27;jen&#x27;: &#x27;Python&#x27;,    &#x27;sarah&#x27;: &#x27;C&#x27;,    &#x27;edward&#x27;: &#x27;Java&#x27;,    &#x27;phil&#x27;: &#x27;Rust&#x27;&#125;print(f&quot;Sarah&#x27;s favorite language is &#123;favorite_language[&#x27;sarah&#x27;]&#125;&quot;)

Sarah&#x27;s favorite language is C

使用get()来访问值使用方括号有时会产生问题，如果指定的key不存在，就会出错
point_val = alien_0.get(&#x27;points&#x27;,&#x27;No point val assigned.&#x27;)print(point_val)

get(查询的key，指定的key不存在时返回的值)

如果没有指定第二个参数，默认返回None

遍历字典遍历所有键值对items()方法user_0 = &#123;    &#x27;username&#x27;: &#x27;efe&#x27;,    &#x27;first&#x27;: &#x27;enrico&#x27;,    &#x27;last&#x27;: &#x27;fermi&#x27;&#125;for key,val in user_0.items():    print(f&quot;\nKey: &#123;key&#125;&quot;)    print(f&quot;\nVal: &#123;val&#125;&quot;)

Key: usernameVal: efeKey: firstVal: enricoKey: lastVal: fermi
遍历所有键keys()方法for name in favorite_language.keys():    print(name.title())

JenSarahEdwardPhil

按特定顺序遍历字典中的所有键for name in sorted(favorite_language.keys()):    print(name.title())

EdwardJenPhilSarah

遍历字典中所有值values()方法for language in favorite_language.values():    print(language)

PythonCJavaRust

这种方法应对数据量较小时没有问题，但是有大量重复元素时，需剔除重复项

可以使用set()集合来处理
favorite_language = &#123;    &#x27;jen&#x27;: &#x27;Python&#x27;,    &#x27;sarah&#x27;: &#x27;C&#x27;,    &#x27;edward&#x27;: &#x27;Java&#x27;,    &#x27;phil&#x27;: &#x27;Python&#x27;&#125;for language in set(favorite_language.values()):    print(language)

JavaPythonC

集合是无序的，每次顺序可能不一样，但是元素一定唯一。可以直接用{}定义一个集合

languages = &#123;&#x27;python&#x27;,&#x27;java&#x27;,&#x27;rust&#x27;&#125;

嵌套字典列表# 创建一个用于存储外星人的空列表aliens = []for alien_num in range(30):    new_alien = &#123;&#x27;color&#x27;: &#x27;green&#x27;,&#x27;points&#x27;: 5&#125;    aliens.append(new_alien)for alien in aliens[:5]:    print(alien)print(&quot;...&quot;)print(f&quot;Total num of aliens: &#123;len(aliens)&#125;&quot;)

&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;...Total num of aliens: 30

在字典中存储列表pizza = &#123;    &#x27;crust&#x27;: &#x27;thick&#x27;,    &#x27;toppings&#x27;: [&#x27;mushrooms&#x27;,&#x27;extra cheese&#x27;],&#125;print(f&quot;You ordered a &#123;pizza[&#x27;crust&#x27;]&#125;-crust pizza&quot;      &quot;with the following toppings:&quot;)for topping in pizza[&#x27;toppings&#x27;]:    print(f&quot;\t&#123;topping&#125;&quot;)

You ordered a thick-crust pizzawith the following toppings:        mushrooms        extra cheese

favorite_languages = &#123;    &#x27;jen&#x27;: [&#x27;Python&#x27;,&#x27;Rust&#x27;],    &#x27;sarah&#x27;: [&#x27;C&#x27;],    &#x27;edward&#x27;: [&#x27;Java&#x27;,&#x27;Go&#x27;],    &#x27;phil&#x27;: [&#x27;Python&#x27;,&#x27;haskell&#x27;],&#125;for name,languages in favorite_languages.items():    print(f&quot;\n&#123;name.title()&#125;&#x27;s favorite languages are:&quot;)    for language in languages:        print(f&quot;\t&#123;language&#125;&quot;)

Jen&#x27;s favorite languages are:        Python        RustSarah&#x27;s favorite languages are:        CEdward&#x27;s favorite languages are:        Java        GoPhil&#x27;s favorite languages are:        Python        haskell

在字典中存储字典users = &#123;    &#x27;aeinstein&#x27;: &#123;        &#x27;first&#x27;: &#x27;albert&#x27;,        &#x27;last&#x27;: &#x27;einstein&#x27;,        &#x27;location&#x27;: &#x27;princeton&#x27;,    &#125;,    &#x27;mcurie&#x27;: &#123;        &#x27;first&#x27;: &#x27;marie&#x27;,        &#x27;last&#x27;: &#x27;curie&#x27;,        &#x27;location&#x27;: &#x27;paris&#x27;,    &#125;,&#125;for username,user_info in users.items():    print(f&quot;\nUsername: &#123;username&#125;&quot;)    full_name = f&quot;&#123;user_info[&#x27;first&#x27;]&#125; &#123;user_info[&#x27;last&#x27;]&#125;&quot;    location = user_info[&#x27;location&#x27;]        print(f&quot;\tFull name: &#123;full_name.title()&#125;&quot;)    print(f&quot;\tLocation: &#123;location.title()&#125;&quot;)

Username: aeinstein        Full name: Albert Einstein        Location: PrincetonUsername: mcurie        Full name: Marie Curie        Location: Paris

用户输入和while循环input()函数的工作原理message = input(&quot;Tell me someing, and I will repeat it back to you:&quot;)print(message)

Tell me someing, and I will repeat it back to you:hellohello

input()函数接受一个参数，是向用户显示的提示，用户的输入会赋给变量

编写清晰的提示有时提示会超过一行，可以先将prompt赋给变量，再用变量传参
prompt = &quot;If you share your name, we can personalize the message you see&quot;prompt += &quot;\nWhat is your first name?&quot;name = input(prompt)print(f&quot;\nHello &#123;name&#125;&quot;)

If you share your name, we can personalize the message you seeWhat is your first name?JackHello Jack

使用int()来获取数值输入使用input()函数获取数值时，解释器会将其解释为字符(串)。
height = input(&quot;How tall are you, in inches?&quot;)height = int(height)if height &gt;= 48:    print(&quot;\nYou are tall enough to ride!&quot;)else:    print(&quot;\nYou&#x27;ll be able to ride when you&#x27;re a little older.&quot;)

How tall are you, in inches?71You are tall enough to ride!

求模运算符这与其他语言中的%并无不同
&gt;&gt;&gt; 4 % 31&gt;&gt;&gt; 5 % 32&gt;&gt;&gt; 6 % 30

while循环简介使用while循环curr_num = 1while curr_num &lt;= 5:    print(curr_num)    curr_num += 1

12345

使用标志来退出程序prompt = &quot;\nTell me someing, and I will repeat it back to you:&quot;prompt += &quot;\nEnter &#x27;quit&#x27; to end the program.&quot;active = Truewhile active:    message = input(prompt)    if message == &#x27;quit&#x27;:        active = False    else:        print(message)

Tell me someing, and I will repeat it back to you: Enter &#x27;quit&#x27; to end the program.JackJackTell me someing, and I will repeat it back to you: Enter &#x27;quit&#x27; to end the program.HellHellTell me someing, and I will repeat it back to you: Enter &#x27;quit&#x27; to end the program.quit

循环控制语句像其他语言一样，也有break和continue两种控制语句
使用while循环处理列表和字典在列表之间移动元素unconfirmed_users = [&#x27;alice&#x27;,&#x27;brian&#x27;,&#x27;candace&#x27;]confirmed_users = []while unconfirmed_users:    curr_user = unconfirmed_users.pop()    print(f&quot;Verifying user: &#123;curr_user.title()&#125;&quot;)    confirmed_users.append(curr_user)print(&quot;\nThe following users have been confirmed:&quot;)for confirmed_user in confirmed_users:    print(confirmed_user.title())

Verifying user: CandaceVerifying user: BrianVerifying user: AliceThe following users have been confirmed:CandaceBrianAlice

删除列表中特定值的所有元素pets = [&#x27;dog&#x27;,&#x27;cat&#x27;,&#x27;dog&#x27;,&#x27;goldfish&#x27;,&#x27;cat&#x27;,&#x27;rabbit&#x27;,&#x27;cat&#x27;]while &#x27;cat&#x27; in pets:    pets.remove(&#x27;cat&#x27;)print(pets)

[&#x27;dog&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;rabbit&#x27;]

使用用户输入填充字典responses = &#123;&#125;polling_active = Truewhile polling_active:    name = input(&quot;\nWhat is your name?&quot;)    response = input(&quot;Which mountain would you like to climb someday?&quot;)    responses[name] = response    repeat = input(&quot;Would you like to let another person respond? (yes/no)&quot;)    if repeat == &#x27;no&#x27;:        polling_active = Falseprint(&quot;\n--- Poll Result ---&quot;)for name,response in responses.items():    print(f&quot;&#123;name&#125; would like to climb &#123;response&#125;&quot;)

What is your name?JackWhich mountain would you like to climb someday?QueWould you like to let another person respond? (yes/no)yesWhat is your name?LyWhich mountain would you like to climb someday?MuWould you like to let another person respond? (yes/no)no--- Poll Result ---Jack would like to climb QueLy would like to climb Mu

第八章 函数8.1 定义函数def greet_user():    &quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;    print(&quot;Hello!&quot;)    greet_user()

第二行文本是被称为文档字符串的注释，这些字符串通常用&quot;&quot;&quot; &quot;&quot;&quot;引起，能够包含多行

向函数传递信息def greet_user(username):    &quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;    print(f&quot;Hello, &#123;username.title()&#125;!&quot;)    greet_user(&#x27;jesse&#x27;)

Hello, Jesse!

稍作修改即可传递参数，与其他语言并无区别，username是一个形参，&#39;jesse&#39;是一个实参
8.2 传递实参8.2.1 位置实参基于实参的顺序进行关联
def describe_pet(animal_type, pet_name):    &quot;&quot;&quot;显示宠物信息&quot;&quot;&quot;    print(f&quot;\nI have a &#123;animal_type&#125;&quot;)    print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)    describe_pet(&#x27;hamster&#x27;,&#x27;harry&#x27;)

I have a hamsterMy hamster&#x27;s name is Harry.


可以多次调用函数，实际上函数就是因为会多次调用，写成函数更方便点，注意实参的顺序

8.2.2 关键字实参是传递给函数名值对(name-value pair)
describe_pet(pet_name = &#x27;harry&#x27;, animal_type = &#x27;hamster&#x27;)
顺序不重要
8.2.3 默认值def describe_pet(pet_name, animal_type = &#x27;dog&#x27;):    &quot;&quot;&quot;显示宠物信息&quot;&quot;&quot;    print(f&quot;\nI have a &#123;animal_type&#125;&quot;)    print(f&quot;My &#123;animal_type&#125;&#x27;s name is &#123;pet_name.title()&#125;.&quot;)describe_pet(&#x27;whllie&#x27;)

注意：使用默认值时，必须在形参列表先列出没有默认值的形参，再列出有默认值的形参

实际上，这三种是混合使用的，只要合法等效均可
8.3 返回值通过return语句返回值有时可以实现实参为空的情况
def get_formatted_name(first_name, last_name, middle_name = &#x27;&#x27;):    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;    if middle_name:        full_name = f&quot;&#123;first_name&#125; &#123;middle_name&#125; &#123;last_name&#125;&quot;    else:        full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;    return full_name.title()cook = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)print(cook)cook = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, &#x27;lee&#x27;)print(cook)

Jimi HendrixJimi Lee Hendrix
实际上可以返回任何值，数据结构，比如字典，列表
def build_person(first_name, last_name, age = None):    &quot;&quot;&quot;返回一个字典，其中包含一个的信息&quot;&quot;&quot;    person = &#123;&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name&#125;    if age:        person[&#x27;age&#x27;] = age;    return personcook = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, 27)print(cook)

&#123;&#x27;first&#x27;: &#x27;jimi&#x27;, &#x27;last&#x27;: &#x27;hendrix&#x27;, &#x27;age&#x27;: 27&#125;

结合使用whiledef get_formatted_name(first_name, last_name, middle_name = &#x27;&#x27;):    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;    if middle_name:        full_name = f&quot;&#123;first_name&#125; &#123;middle_name&#125; &#123;last_name&#125;&quot;    else:        full_name = f&quot;&#123;first_name&#125; &#123;last_name&#125;&quot;    return full_name.title()while True:    print(&quot;\nPlease tell me your name:&quot;)    print(&quot;(enter &#x27;q&#x27; at any time to quit)&quot;)    f_name = input(&quot;First name:&quot;)    if f_name == &#x27;q&#x27;:        break    l_name = input(&quot;Last name:&quot;)    if l_name == &#x27;q&#x27;:        break    formatted_name = get_formatted_name(f_name,l_name)    print(f&quot;\nHello &#123;formatted_name&#125;!&quot;)

Please tell me your name:(enter &#x27;q&#x27; at any time to quit)First name:jimiLast name:hedHello Jimi Hed!Please tell me your name:(enter &#x27;q&#x27; at any time to quit)First name:q

8.4 传递列表我们可以实现在函数中修改列表
def print_models(unprinted_designs, completed_models):    &quot;&quot;&quot;    模拟打印每个设计，    打印每个设计后，将其移动到列表completed_models    &quot;&quot;&quot;    while unprinted_designs:        curr_design = unprinted_designs.pop()        print(f&quot;Printing model: &#123;curr_design&#125;&quot;)        completed_models.append(curr_design)        def show_completed_models(completed_models):    &quot;&quot;&quot;显示打印好的模型&quot;&quot;&quot;    print(&quot;\nThe following models have been printed:&quot;)    for completed_model in completed_models:        print(completed_model)        unprinted_designs = [&#x27;phone&#x27;, &#x27;robot&#x27;, &#x27;dog&#x27;]completed_models = []print_models(unprinted_designs, completed_models)show_completed_models(completed_models)

Printing model: dogPrinting model: robotPrinting model: phoneThe following models have been printed:dogrobotphone

可以通过向函数传递列表副本来防止函数修改列表
function_name(list_name[:])

传递任意数量的实参def make_pizza(*toppings):    &quot;&quot;&quot;概述要制作的披萨&quot;&quot;&quot;    print(&quot;\nMaking a pizza with the following toppings:&quot;)    for topping in toppings:        print(f&quot;- &#123;topping&#125;&quot;)        make_pizza(&#x27;mushroom&#x27;)make_pizza(&#x27;pep&#x27;,&#x27;mushroom&#x27;,&#x27;cheese&#x27;)

Making a pizza with the following toppings:- mushroomMaking a pizza with the following toppings:- pep- mushroom- cheese

*是让py创建一个名为toppings的元组，如果直接打印，会以元组形式出现

使用任意数量的关键字实参def build_profile(first, last, **user_info):    &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;    user_info[&#x27;first_name&#x27;] = first    user_info[&#x27;last_name&#x27;] = last    return user_infouser_profile = build_profile(&#x27;albert&#x27;,&#x27;einstein&#x27;,                             location = &#x27;princeton&#x27;,                             field = &#x27;physics&#x27;)print(user_profile)

&#123;&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;, &#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;&#125;

****是让py创建一个名为user_info的字典，传参是传入键值对

8.6 将函数存储在模块中导入整个模块模块是扩展名为.py的文件
import pizza03pizza03.make_pizza(&#x27;mushroom&#x27;)

Making a pizza with the following toppings:- mushroom

导入特定的函数from module_name import function_0,function_1

使用as给模块指定别名import pizza03 as p p.make_pizza(&#x27;mushroom&#x27;)

也可以给函数指定别名
from module_name import function_name as fn

导入模块中的所有函数from pizza import *

注意：这是让Python将模块中的所有函数都复制到这个程序文件中，这样无须使用点号来调用程序，但是不建议这样做，在编写大型程序师可能会产生一些问题

编写指南
在给形参指定默认值时，等号两边不要有空格
函数调用中的关键字实参也应该循序这种约定

第九章 类OOP是最有效的软件编写方法之一
9.1 创建和使用类class Dog:    &quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;    def __init__(self, name, age):        &quot;&quot;&quot;初始化属性 name 和 age&quot;&quot;&quot;        self.name = name        self.age = age        def sit(self):        &quot;&quot;&quot;模拟小狗收到命令时坐下&quot;&quot;&quot;        print(f&quot;&#123;self.name&#125; is now sitting.&quot;)            def roll_over(self):        &quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;        print(f&quot;&#123;self.name&#125; rolled over!&quot;)

根据约定，在Python中首字母大写的名称指的是类（此处是全新的类，定义时不加括号）
__init__()方法类中的函数称为方法

self必不可少，Python会自动传入这个实参
以self为前缀的变量可以供类中的所有方法使用，可以通过类的所有实例访问（这种叫做属性(attribute))

根据类创建实例class Dog:	--snip--my_dog = Dog(&#x27;Willie&#x27;, 6)print(f&quot;My dog&#x27;s name is &#123;my_dog.name&#125;.&quot;)print(f&quot;My dog is &#123;my_dog.age&#125; years old.&quot;)

1.访问属性访问实例的属性可使用.
2.调用方法class Dog:	--snip--my_dog = Dog(&#x27;Willie&#x27;, 6)my_dog.sit()my_dog.roll_over()

3.创建多个实例可以根据需求创建多个实例
9.2 使用类和实例Car类class Car:    &quot;&quot;&quot;一次模拟汽车的尝试&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;初始化汽车属性&quot;&quot;&quot;        self.make = make        self.model = model        self.year = year    def get_descriptive_name(self):        &quot;&quot;&quot;返回规范化的描述性信息&quot;&quot;&quot;        long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;        return long_name.title()my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)print(my_new_car.get_descriptive_name())
给属性指定默认值有些属性可以直接在__init__()中指定默认值
class Car:    &quot;&quot;&quot;一次模拟汽车的尝试&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;初始化汽车属性&quot;&quot;&quot;        self.make = make        self.model = model        self.year = year        self.odometer_reading = 0    def get_descriptive_name(self):        &quot;&quot;&quot;返回规范化的描述性信息&quot;&quot;&quot;        long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;        return long_name.title()    def read_odometer(self):        &quot;&quot;&quot;打印一条指出汽车行驶里程的消息&quot;&quot;&quot;        print(f&quot;This car has &#123;self.odometer_reading&#125; miles on it&quot;)        my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)print(my_new_car.get_descriptive_name())my_new_car.read_odometer()

2024 Audi A4This car has 0 miles on it

修改属性的值1.直接修改通过实例访问它修改
class Car:	--snip--my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)print(my_new_car.get_descriptive_name())my_new_car.odometer_reading = 23my_new_car.read_odometer()

2.通过方法修改属性的值class Car:	--snip--	def update_odometer(self,mileage):        &quot;&quot;&quot;将里程表读数更新为指定的值&quot;&quot;&quot;        self.odometer_reading = mileage        my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)print(my_new_car.get_descriptive_name())my_new_car.update_odometer(23)my_new_car.read_odometer()

3.通过方法让属性的值递增实际上，很多情况下，是让属性的值增加一个特定的值，而不是更新为一个新的值
class Car	--snip--	def increment_odometer(self,miles):        &quot;&quot;&quot;让里程表增加特定的值&quot;&quot;&quot;        self.odometer_reading += miles

9.3 继承编写类时，并非总是从头开始，如果要编写的类是一个既有类的特殊版本，可使用继承，原有类称为父类，新类称为子类。
class Car:    &quot;&quot;&quot;一次模拟汽车的尝试&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;初始化汽车属性&quot;&quot;&quot;        self.make = make        self.model = model        self.year = year        self.odometer_reading = 0    def get_descriptive_name(self):        &quot;&quot;&quot;返回规范化的描述性信息&quot;&quot;&quot;        long_name = f&quot;&#123;self.year&#125; &#123;self.make&#125; &#123;self.model&#125;&quot;        return long_name.title()    def read_odometer(self):        &quot;&quot;&quot;打印一条指出汽车行驶里程的消息&quot;&quot;&quot;        print(f&quot;This car has &#123;self.odometer_reading&#125; miles on it&quot;)    def update_odometer(self,mileage):        &quot;&quot;&quot;将里程表读数更新为指定的值&quot;&quot;&quot;        if mileage &gt;= self.odometer_reading:            self.odometer_reading = mileage        else:            print(&quot;You can&#x27;t roll back an odometer!&quot;)    def increment_odometer(self,miles):        &quot;&quot;&quot;让里程表增加特定的值&quot;&quot;&quot;        self.odometer_reading += milesclass ElectricCar(Car):    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;        super().__init__(make, model, year)my_model_y = ElectricCar(&#x27;Tesla&#x27;, &#x27;model_y&#x27;, 2024)print(my_model_y.get_descriptive_name())


super()是一个特殊的函数，让我们可以调用父类的方法
父类也称为超类(superclass)，super()因此得名

给子类定义属性和方法class Car	--snip--class ElectricCar(Car):    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;        先初始化父类的属性，        再初始化特有属性        &quot;&quot;&quot;        super().__init__(make, model, year)        self.battery_size = 40    def describe_battery(self):        &quot;&quot;&quot;打印一条电池容量信息&quot;&quot;&quot;        print(f&quot;This car has a &#123;self.battery_size&#125;-kWh battery.&quot;)my_model_y = ElectricCar(&#x27;Tesla&#x27;, &#x27;model_y&#x27;, 2024)print(my_model_y.get_descriptive_name())my_model_y.describe_battery()

2024 Tesla Model_YThis car has a 40-kWh battery.

重写父类中的方法class ElectricCar(Car):	-- snip --	def fill_gas_tank(self):        &quot;&quot;&quot;电动汽车没油油箱&quot;&quot;&quot;        print(&quot;This car doesn&#x27;t have a gas tank.&quot;)

假设Car类中有fill_gas_tank()这个方法，现在Python将忽略父类中的这个方法，转而运行上述代码
将实例用作属性将大型类拆分成多个协同工作的小类，这种方法称为组合
class Car	--snip--class Battery:    &quot;&quot;&quot;一次模拟电动汽车电池的简单尝试&quot;&quot;&quot;    def __init__(self, battery_size=40):        &quot;&quot;&quot;初始化电池属性&quot;&quot;&quot;        self.battery_size = battery_size    def describe_battery(self):        &quot;&quot;&quot;打印一条电池容量信息&quot;&quot;&quot;        print(f&quot;This car has a &#123;self.battery_size&#125;-kWh battery.&quot;)class ElectricCar(Car):    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;    def __init__(self, make, model, year):        &quot;&quot;&quot;        先初始化父类的属性，        再初始化特有属性        &quot;&quot;&quot;        super().__init__(make, model, year)        self.battery = Battery()    def fill_gas_tank(self):        &quot;&quot;&quot;电动汽车没油油箱&quot;&quot;&quot;        print(&quot;This car doesn&#x27;t have a gas tank.&quot;)my_model_y = ElectricCar(&#x27;Tesla&#x27;, &#x27;model_y&#x27;, 2024)print(my_model_y.get_descriptive_name())my_model_y.battery.describe_battery()

9.4 导入类导入单个类，在一个模块中存储多个类from car import Car, ElectricCarmy_mustang = Car(&#x27;ford&#x27;, &#x27;mustang&#x27;, 2024)print(my_mustang.get_descriptive_name())my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)print(my_leaf.get_descriptive_name())

2024 Ford Mustang2024 Nissan Leaf

导入整个模块
这与函数相同，导入整个模块后，需要使用.
当然，也可以在一个模块中导入另一个模块

导入模块的所有类from module_name import *

依然不推荐这种方法

使用别名可以给模块中的类，或者模块指定别名
9.5 Python 标准库下面示范一个
&gt;&gt;&gt; from random import randint&gt;&gt;&gt; randint(1, 6)1

&gt;&gt;&gt; from random import choice&gt;&gt;&gt; players = [&#x27;cah&#x27;, &#x27;jie&#x27;, &#x27;loo&#x27;]&gt;&gt;&gt; first_up = choice(players)&gt;&gt;&gt; first_up&#x27;cah&#x27;


在创建与安全有关的项目时，不要使用random模块，此外，还可以导入很多外部模块

9.6 类的编程风格
类名应采用大驼峰式命名法
ElectricCar


每个类，都应在类定义后面紧跟一个文档字符串
先写标准库模块中的import语句，再写自己的模块

第十章 文件和异常10.1 读取文件10.1.1 读取文件的全部内容from pathlib import Pathpath = Path(&#x27;pi_digits.txt&#x27;)contents = path.read_text()print(contents)

3.1415926535   8979323846   2643383279   


理论上，结尾会出现一个空行，read_text()在到达文件末尾时会返回一个空字符串，此时可以使用rstrip()

10.1.2 文件的相对路径和绝对路径
最简单的做法就是把文件和程序文件放在同一个文件夹中（且不在子文件夹中）
当然最稳妥的做法是使用绝对路径


在显示文件路径时，win会使用\而不是/，但在代码中应该始终使用/，pathlib库会自动使用正确的路径表示方法

10.1.3 访问文件中的各行
可以使用splitlines()方法将冗长的字符串转换成一系列的行，再使用for循环每次一行来检查

from pathlib import Pathpath = Path(&#x27;pi_digits.txt&#x27;)contents = path.read_text().rstrip()lines = contents.splitlines()for line in lines:    print(line)

splitlines()返回一个列表，包含文件中的所有行

10.1.4 使用文件的内容from pathlib import Pathpath = Path(&#x27;pi_digits.txt&#x27;)contents = path.read_text().rstrip()lines = contents.splitlines()pi_string = &#x27;&#x27;for line in lines:    pi_string += line    print(pi_string)print(len(pi_string))

3.1415926535   8979323846   264338327938

for line in lines:    pi_string += line.lstrip()

3.14159265358979323846264338327932

注意：读取文件时，所有内容都是字符串，如要以数值形式理解，需使用int()，float()转换

10.1.5 包含100万位的大型文件from pathlib import Pathpath = Path(&#x27;pi_million_digits.txt&#x27;)contents = path.read_text().rstrip()lines = contents.splitlines()pi_string = &#x27;&#x27;for line in lines:    pi_string += line.lstrip()    print(f&quot;&#123;pi_string[:52]&#125;...&quot;)print(len(pi_string))

3.14159265358979323846264338327950288419716939937510...1000002

from pathlib import Pathpath = Path(&#x27;pi_million_digits.txt&#x27;)contents = path.read_text().rstrip()lines = contents.splitlines()pi_string = &#x27;&#x27;for line in lines:    pi_string += line.lstrip() birthday = input(&quot;Enter your birthday, in the form mmddyy: &quot;)if birthday in pi_string:    print(&quot;Your birthday appears in the first million digits of pi!&quot;)else:    print(&quot;Your birthday does not appear in the first million digits of pi.&quot;)

Enter your birthday, in the form mmddyy: 051407Your birthday does not appear in the first million digits of pi.

10.2 写入文件10.2.1 写入一行from pathlib import Pathpath = Path(&#x27;programming.txt&#x27;)path.write_text(&quot;Python is fun!&quot;)


**Python只能将字符串写入文本文件，数值数据需先使用str()转换

10.2.2 写入多行from pathlib import Pathcontents = &quot;hello.\n&quot;contents += &quot;greetings.\n&quot;contents += &quot;superise.\n&quot;path = Path(&#x27;programming.txt&#x27;)path.write_text(contents)

使用write_text()时，需要谨慎，如果指定文件已经存在，它会先删除其内容，并将指定内容写入其中

10.3 异常
Python使用称为异常(exception)的特殊对象来管理程序执行期间的错误
每当发生错误，都会创建一个异常对象
如果编写了处理该异常的代码，程序就会继续运行
如果没有处理，程序将停止，并显示一个traceback

10.3.1 ZeroDivisionError异常（除0错误）&gt;&gt;&gt; print(5/0)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ZeroDivisionError: division by zero

10.3.2 使用try-except代码块try:    print(5/0)except ZeroDivisionError:    print(&quot;You can&#x27;t divide by zero!&quot;)

You can&#x27;t divide by zero!

10.3.3 使用异常避免崩溃和else代码块print(&quot;Give you two numbers, and I&#x27;ll divide them.&quot;)print(&quot;Enter &#x27;q&#x27; to quit.&quot;)while True:    first_num = input(&quot;\nFirst number: &quot;)    if first_num == &#x27;q&#x27;:        break    second_num = input(&quot;Second number: &quot;)    if second_num == &#x27;q&#x27;:        break    try:        answer = int(first_num) / int(second_num)    except ZeroDivisionError:        print(&quot;You can&#x27;t divide by zero!&quot;)    else:        print(answer)

Give you two numbers, and I&#x27;ll divide them.Enter &#x27;q&#x27; to quit.First number: 8Second number: 42.0First number: 9Second number: 0You can&#x27;t divide by zero!First number: q

成功执行try代码块的运算后，就会执行else代码块中的代码

10.3.4 处理FileNotFoundError异常from pathlib import Pathpath = Path(&#x27;alice.txt&#x27;)contents = path.read_text(encoding=&#x27;utf-8&#x27;)

***注意：如果系统默认编码与要读取的文件的编码不一致，参数encoding必不可少

Traceback (most recent call last):  File &quot;e:\learn\Python_learning\CCF_ComputerDesign\yuhaolin\file_io\alice.py&quot;, line 4, in &lt;module&gt;    contents = path.read_text(encoding=&#x27;utf-8&#x27;)  File &quot;C:\Users\36259\AppData\Local\Programs\Python\Python313\Lib\pathlib\_local.py&quot;, line 546, in read_text    return PathBase.read_text(self, encoding, errors, newline)                ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       File &quot;C:\Users\36259\AppData\Local\Programs\Python\Python313\Lib\pathlib\_abc.py&quot;, line 632, in read_text    with self.open(mode=&#x27;r&#x27;, encoding=encoding, errors=errors, newline=newline) as f:         ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  File &quot;C:\Users\36259\AppData\Local\Programs\Python\Python313\Lib\pathlib\_local.py&quot;, line 537, in open    return io.open(self, mode, buffering, encoding, errors, newline)           ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^FileNotFoundError: [Errno 2] No such file or directory: &#x27;alice.txt&#x27;

重点关注最后一行，和第一处line 4，要将错误代码行放入try中，并编写对应的except

from pathlib import Pathpath = Path(&#x27;alice.txt&#x27;)try:    contents = path.read_text(encoding=&#x27;utf-8&#x27;)except FileNotFoundError:    print(&quot;The file &#x27;alice.txt&#x27; was not found.&quot;)

The file &#x27;alice.txt&#x27; was not found.

10.3.5 分析文本from pathlib import Pathpath = Path(&#x27;alice.txt&#x27;)try:    contents = path.read_text(encoding=&#x27;utf-8&#x27;)except FileNotFoundError:    print(&quot;The file &#x27;alice.txt&#x27; was not found.&quot;)else:    words = contents.split()    num_words = len(words)    print(f&quot;The file &#x27;alice.txt&#x27; has about &#123;num_words&#125; words.&quot;)

The file &#x27;alice.txt&#x27; has about 29594 words.


使用split()方法，以空白为分隔符将字符串分拆为多个部分

10.3.6 静默失败def count_words(path):    &quot;&quot;&quot;计算一个文件大致的单词数&quot;&quot;&quot;    try:        contents = path.read_text(encoding=&#x27;utf-8&#x27;)    except FileNotFoundError:        pass    else:        words = contents.split()        num_words = len(words)        print(f&quot;The file has about &#123;num_words&#125; words.&quot;)

在except代码块中写pass语句，出现异常时，什么都不会发生，既没有traceback也没有提示

10.4 存储数据
使用json模块存储数据

10.4.1 使用json.dumps()和json.loads()from pathlib import Pathimport jsonnums = [1,2,3,4,5,6]path = Path(&#x27;numbers.json&#x27;)contents = json.dumps(nums)path.write_text(contents)

**json.dumps()接受一个实参，将其转换为json格式的数据，返回一个字符串，这样就可以将其写入数据文件了

from pathlib import Pathimport jsonpath = Path(&#x27;numbers.json&#x27;)contents = path.read_text()numbers = json.loads(contents)print(numbers)


这样实现了在程序之间共享数据

10.4.2 保存和读取用户生成的数据from pathlib import Pathimport jsonpath = Path(&#x27;username.json&#x27;)if path.exists():    contents = path.read_text()    username = json.loads(contents)    print(f&quot;Welcome back, &#123;username&#125;!&quot;)else:    username = input(&quot;what is your name?&quot;)    contents = json.dumps(username)    path.write_text(contents)    print(f&quot;We&#x27;ll remember you when you come back, &#123;username&#125;!&quot;)

当然，此处也可以使用try-except代码块，不过path.exists()函数也可以实现

10.4.3 重构
虽然代码能够运行，但还可以将其划分为一系列完成具体工作的函数来进行改进

from pathlib import Pathimport jsondef get_stored_username(path):    &quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;    if path.exists():        contents = path.read_text()        username = json.loads(contents)        return username    else:        return None    def get_new_username(path):    &quot;&quot;&quot;提示用户输入用户名，并将其存储&quot;&quot;&quot;    username = input(&quot;What is your name? &quot;)    contents = json.dumps(username)    path.write_text(contents)    return usernamedef greet_user():    &quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;    path = Path(&#x27;username.json&#x27;)    username = get_stored_username(path)    if username:        print(f&quot;Welcome back, &#123;username&#125;!&quot;)    else:        username = get_new_username(path)        print(f&quot;We&#x27;ll remember you when you come back, &#123;username&#125;!&quot;)        greet_user()

第十一章 测试代码11.1 使用pip安装pytest11.1.1 更新pippy -m pip install --upgrade pip-- snip --Successfully installed pip-25.3
11.1.2 安装pytestpy -m pip install --user pytest

11.2 测试函数from name_function import get_formatted_nameprint(&quot;Enter &#x27;q&#x27; at any time to quit.&quot;)while True:    first = input(&quot;\nPlease give me a first name: &quot;)    if first == &#x27;q&#x27;:        break    last = input(&quot;Please give me a last name: &quot;)    if last == &#x27;q&#x27;:        break    formatted_name = get_formatted_name(first, last)    print(f&quot;\tNeatly formatted name: &#123;formatted_name&#125;.&quot;)

11.2.1 单元测试和测试用例
一种最简单的测试时单元测试
全覆盖测试用例包含一整套单元测试

11.2.2 可通过的测试from name_function import get_formatted_namedef test_name_function():    &quot;&quot;&quot;能正确处理像 &#x27;janis joplin&#x27; 这样的姓名吗？&quot;&quot;&quot;    formatted_name = get_formatted_name(&#x27;janis&#x27;, &#x27;joplin&#x27;)    assert formatted_name == &#x27;Janis Joplin&#x27;


测试文件名称和测试函数名称都要以test_打头
做出一个断言assert

11.2.3 运行测试pytest============== test session starts ===============platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0rootdir: E:\learn\Python_learning\CCF_ComputerDesign\yuhaolincollected 1 item                                  test_name_function.py .                     [100%]=============== 1 passed in 0.02s ================

**注意：要配下环境变量哦，不配可以py -m pytest

11.2.4 未通过的测试
我们故意修改原来的函数

pytest============== test session starts ===============platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0rootdir: E:\learn\Python_learning\CCF_ComputerDesign\yuhaolincollected 1 item                                   test_name_function.py F                     [100%]==================== FAILURES ==================== _______________ test_name_function _______________     def test_name_function():        &quot;&quot;&quot;能正确处理像 &#x27;janis joplin&#x27; 这样的姓名吗？&quot;&quot;&quot;&gt;       formatted_name = get_formatted_name(&#x27;janis&#x27;, &#x27;joplin&#x27;)                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^E       TypeError: get_formatted_name() missing 1 required positional argument: &#x27;last&#x27;test_name_function.py:5: TypeError============ short test summary info =============FAILED test_name_function.py::test_name_function - TypeError: get_formatted_name() missing 1 requ...  =============== 1 failed in 0.06s ================


接下来我们修改原函数

pytest============== test session starts ===============platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0rootdir: E:\learn\Python_learning\CCF_ComputerDesign\yuhaolincollected 1 item                                   test_name_function.py .                     [100%] =============== 1 passed in 0.01s ================ 

11.2.5 添加新的测试from name_function import get_formatted_namedef test_name_function():    &quot;&quot;&quot;能正确处理像 &#x27;janis joplin&#x27; 这样的姓名吗？&quot;&quot;&quot;    formatted_name = get_formatted_name(&#x27;janis&#x27;, &#x27;joplin&#x27;)    assert formatted_name == &#x27;Janis Joplin&#x27;    def test_first_last_middle_name():    &quot;&quot;&quot;能正确处理像 &#x27;wolfgang amadeus mozart&#x27; 这样的姓名吗？&quot;&quot;&quot;    formatted_name = get_formatted_name(&#x27;wolfgang&#x27;, &#x27;mozart&#x27;, &#x27;amadeus&#x27;)    assert formatted_name == &#x27;Wolfgang Amadeus Mozart&#x27;

pytest============== test session starts ===============platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0rootdir: E:\learn\Python_learning\CCF_ComputerDesign\yuhaolincollected 2 items                                  test_name_function.py ..                    [100%] =============== 2 passed in 0.01s ================

11.3 测试类11.3.1 各种断言


断言
用途



assert a &#x3D;&#x3D; b
判断a和b值相等


assert a !&#x3D; b
判断a和b值不相等


assert a &gt; b
判断a大于b


assert a &gt;&#x3D; b
判断a大于等于b


assert a &lt; b
判断a小于b


assert a &lt;&#x3D; b
判断a小于等于b


assert a is b
判断a和b是同一个对象（内存地址相同）


assert a is not b
判断a和b不是同一个对象（内存地址不同）


assert a
判断a为True（非空&#x2F;非0&#x2F;非False）


assert not a
判断a为False（空&#x2F;0&#x2F;False）


assert a is None
判断a是空值None


assert a is not None
判断a不是空值None


assert x in a
判断x是容器&#x2F;字符串a的成员&#x2F;子串


assert x not in a
判断x不是容器&#x2F;字符串a的成员&#x2F;子串


assert all(a)
判断容器a中所有元素为True


assert any(a)
判断容器a中至少一个元素为True


with pytest.raises(Err)
判断代码块抛出指定类型的异常Err


assert a &#x3D;&#x3D; pytest.approx(b)
判断浮点数a和b近似相等（解决精度问题）


assert a &#x3D;&#x3D; b, 提示语
断言失败时显示自定义提示语，快速定位问题


11.3.2 一个要测试的类class AnonymousSurvey:    &quot;&quot;&quot;收集匿名调查的问卷的答案&quot;&quot;&quot;    def __init__(self, question):        &quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;        self.question = question        self.responses = []    def show_question(self):        &quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;        print(self.question)    def store_response(self, new_response):        &quot;&quot;&quot;存储单份调查问卷&quot;&quot;&quot;        self.responses.append(new_response)    def show_results(self):        &quot;&quot;&quot;显示收集到的所有答案&quot;&quot;&quot;        print(&quot;Survey results:&quot;)        for response in self.responses:            print(f&quot;- &#123;response&#125;&quot;)



再编写一个使用它的程序

from survey import AnonymousSurvey# 定义一个问题，并创建一个表示调查的AnonymousSurvey对象question = &quot;What language did you first learn to speak?&quot;my_survey = AnonymousSurvey(question)# 显示问题并存储答案my_survey.show_question()print(&quot;Enter &#x27;q&#x27; at any time to quit.\n&quot;)while True:    response = input(&quot;Language: &quot;)    if response == &#x27;q&#x27;:        break    my_survey.store_response(response)    # 显示调查结果print(&quot;\nThank you to everyone who participated in the survey!&quot;)my_survey.show_results()

11.3.3 测试类from survey import AnonymousSurveydef test_store_single_response():    &quot;&quot;&quot;测试单个答案是否被妥善存储&quot;&quot;&quot;    question = &quot;What language did you first learn to speak?&quot;    language_survey = AnonymousSurvey(question)    language_survey.store_response(&#x27;English&#x27;)    assert &#x27;English&#x27; in language_survey.responsesdef test_store_three_responses():    &quot;&quot;&quot;测试多个答案是否被妥善存储&quot;&quot;&quot;    question = &quot;What language did you first learn to speak?&quot;    language_survey = AnonymousSurvey(question)    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]    for response in responses:        language_survey.store_response(response)    for response in responses:        assert response in language_survey.responses

pytest test_survey.py============== test session starts ===============platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0rootdir: E:\learn\Python_learning\CCF_ComputerDesign\yuhaolincollected 2 items                                  test_survey.py ..                           [100%] =============== 2 passed in 0.01s ================ 

11.3.4 使用夹具
夹具可以帮助我们搭建测试环境
在pytest中可以使用装饰器@pytest.fixture装饰的函数
装饰器是放在函数的定义前的指令

import pytestfrom survey import AnonymousSurvey@pytest.fixturedef language_survey():    &quot;&quot;&quot;一个可供所有测试函数使用的AnonymousSurvey实例&quot;&quot;&quot;    question = &quot;What language did you first learn to speak?&quot;    language_survey = AnonymousSurvey(question)    return language_survey    def test_store_single_response(language_survey):    &quot;&quot;&quot;测试单个答案是否被妥善存储&quot;&quot;&quot;    language_survey.store_response(&#x27;English&#x27;)    assert &#x27;English&#x27; in language_survey.responsesdef test_store_three_responses(language_survey):    &quot;&quot;&quot;测试多个答案是否被妥善存储&quot;&quot;&quot;    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]    for response in responses:        language_survey.store_response(response)    for response in responses:        assert response in language_survey.responses

以上是蟒蛇书第一部分核心语法]]></content>
  </entry>
  <entry>
    <title>翁恺C语言学习笔记</title>
    <url>/2025/11/05/%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[这是我学习C语言的笔记
1.1第一个C语言程序 #include&lt;stdio.h&gt;int main()&#123;printf(&quot;hello world!\n&quot;);return 0;  &#125;

程序框架
#include &lt;stdio.h&gt; int main() {
return 0;  

 }

1.2做点计算#include &lt;stdio.h&gt;int main()&#123;printf(&quot;%d&quot;,12+34);return 0;&#125;

1.2.2四则运算


四则运算
C符号
意义



+
+
加


-
-
减


×
*
乘


÷
&#x2F;
除



%
取余



2.1变量#include&lt;stdio.h&gt;int main()&#123;int price = 0;printf(&quot;请输入金额（元)：&quot;);scanf(&quot;%d&quot;,&amp;price);int change = 100 - price;printf(&quot;找您%d元。\n&quot;,change);return 0;&#125;


注意使用visual studio时，此处scanf需使用scanf_s

2.1.1变量定义
&lt;类型名称&gt;&lt;变量名称&gt;
int price;
int amount;
int price,amount;
变量的名字即标识符，标识符只能由数字，字母下划线组成，且数字不可以出现在第一个位置.



2.1.2赋值和初始化
int price &#x3D; 0；
这一行，定义了一个变量，变量的名字是price，类型是int，初始值是0
int price &#x3D; 0,amount &#x3D; 0;
左值必须是变量
变量和被赋的值（右值）类型应该相同

读整数
scanf(“%d”,&amp;price);
scanf()里的都是要输入的，必须满足每一项。

常量
我们称之为直接量(literal)
定义一个常量
const int AMOUNT &#x3D; 100




一般对一个const变量是全大写的，来强调它的只读性。

int a;int b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);printf(&quot;%d + %d = %d\n&quot;,a,b,a+b);

浮点数
两个整数的运算结果只能是整数
10和10.0在C中是完全不同的数

printf(&quot;请分别输入身高的英尺和英寸,&quot;&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;);int foot;int inch;scanf(&quot;%d %d&quot;,&amp;foot,&amp;inch);printf(&quot;身高是%f米。\n&quot;,((foot + inch/12.0)*0.3048));


double是双精度浮点数，上面的程序也可以这样写

printf(&quot;请分别输入身高的英尺和英寸,&quot;&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;);double foot;double inch;scanf(&quot;%lf %lf&quot;,&amp;foot,&amp;inch);printf(&quot;身高是%f米。\n&quot;,((foot + inch/12.0)*0.3048));


浮点数输出用%d,输入用%lf

表达式
一个表达式由运算符和算子组成
下面给一个计算时间差的程序

#include &lt;stdio.h&gt;int main()&#123; int hour1,minute1; int hour2,minute2; scanf(&quot;%d %d&quot;,&amp;hour1,&amp;minute1); scanf(&quot;%d %d&quot;,&amp;hour2,&amp;minute2); int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t2 - t1; printf(&quot;时间差是%d小时%d分。&quot;,t/60,t%60); return 0;&#125;

求平均值int a,b;scanf(&quot;%d %d&quot;,&amp;a,&amp;b);double c = (a+b)/2.0;printf(&quot;%d和%d的平均值=%f\n&quot;,a,b,c);


这引申出运算符优先级的概念，一般与数学运算相同，尤其注意的是_+,-在进行单目运算时优先级最高，即正负号，a*-b_

交换两个变量  int a = 5;int b = 6;int t;t = a;a = b;b = t;printf(&quot;a=%d,b=%d&quot;,a,b);

可以借用IDE的调试功能来观察如何进行交换，实际上就是要用一个临时变量来进行交换。

复合赋值
total +&#x3D; 5;
total &#x3D; total + 5;
注意两个运算符中间不要有空格
total *&#x3D; sum +12;
total &#x3D; total*(sum + 12);
都要先完成右边的运算

递增递减运算符
++，–是单目运算符，其效果是使变量+1或-1
注意其有前缀和后缀形式。
a++ &#x3D;10；
a &#x3D; 11;
++a &#x3D; 12;

条件判断int hour1,minute1;int hour2,minute2;scanf(&quot;%d %d&quot;,&amp;hour1,&amp;minute1);scanf(&quot;%d %d&quot;,&amp;hour2,&amp;minute2);int ih = hour2 - hour1;int im = minute2 - minute1;if (im &lt; 0)&#123;im = 60 + im;ih --;&#125; printf(&quot;时间差是%d小时%d分钟\n&quot;,ih,im);


关系运算符


运算符
意义



&#x3D;&#x3D;
相等


！&#x3D;
不相等


&gt;
大于


&lt;
小于


&gt;&#x3D;
大于或等于


&lt;&#x3D;
小于或等于



可以用printf(&quot;%d\n&quot;,5&gt;3)这样的代码来判断，输出1表示正确，0表示错误。且判断是否相等的优先级比其他的低，从左到右进行判断。

找零计算器//初始化int price = 0;int bill = 0;//读入金额和票面printf(&quot;请输入金额：&quot;);scanf(&quot;%d&quot;,&amp;price);printf(&quot;请输入金额：&quot;);scanf(&quot;%d&quot;,&amp;bill);//计算找零printf(&quot;应该找您：%d\n&quot;,bill - price);


注释可以用&#x2F;&#x2F;来开始（单行注释）也可以有/*  */用于多行注释和行内注释

if (bill&gt;= price)&#123;printf(&quot;应该找您：%d\n&quot;,bill - price);&#125;

不够怎么办if(bill&gt;= price)&#123;printf(&quot;应该找您：%d\n&quot;,bill - price);&#125;else&#123;printf(&quot;你的钱不够\n&quot;);&#125;


给出一个关于比较a和b的问题

方案一
int a,b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);int max = 0;if(a&gt;b)&#123; max = a;&#125;else&#123;max = b;&#125;printf(&quot;大的那个是%d\n&quot;,max);
方案二
int max = b;if(a&gt;b)&#123;max = a;&#125;

再探if语句if()后面可以不加大括号，那么紧接着的一行就是要执行的。else也相同。

下面给出一个例子，（计算工资）

const double RATE = 8.25;const int STANDARD = 40;double pay = 0.0;int hours;printf(&quot;请输入工作小时数:&quot;);scanf(&quot;%d&quot;,&amp;hours);printf(&quot;\n&quot;);if(hours &gt;STANDARD)pay = STANDARD*RATE+(hours - STANDARD)*(RATE*1.5);elsepay = hours*RATE;printf(&quot;应付工资：%f\n&quot;,pay);

嵌套if语句int a,b,c;scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);int max = 0;if(a&gt;b)&#123;if(a&gt;c)&#123;max = a;&#125;else&#123;max = c;&#125;&#125;else&#123;if(b&gt;c)&#123;max = b;&#125;else&#123;max = c;&#125;&#125;printf(&quot;The max is %d\n&quot;,max);

级联的if elseint f;if(x &lt; 0)&#123;  f = 1;&#125;else if(x == 0)&#123;  f = 0;&#125;else&#123;  f = 2 * x;&#125;printf(&quot;%d&quot;,f);

同时int f放在前面。即单一出口会更有效率。

switch case语句
为了提高运行效率，级联的if else可以用此替换

int type;scanf(&quot;%d&quot;,&amp;type);switch(type)&#123;	case 1:	printf(&quot;hello&quot;);	break;	case 2:	printf(&quot;okay&quot;);	break;	default:	printf(&quot;nothing correct&quot;);	break;&#125;


case只是一个入口，并不分隔，起分隔作用的是break且type位置只能是int类型case 后面必须是常量

循环
while循环

int x;int n = 0;scanf(&quot;%d&quot;,&amp;x);//下面两行是为了0的一位，因为0无法循环。n++;x /= 10;while(x &gt; 0)&#123;	n++;	x /= 10;&#125;printf(&quot;%d\n&quot;,n);

do while循环
进入循环时不做检查，在执行完一轮循环体代码之后再检查条件是否满足，满足则继续，不满足则结束循环。

int x;scanf(&quot;%d&quot;,&amp;x);int n = 0;do&#123;	x /= 10;	n++;&#125;while(x &gt; 0);printf(&quot;%d&quot;,n);

猜数游戏
要由计算机想一个随机数

#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123;	srand(time(0));	int number = rand()%100 + 1;	//那么由于随机数太大了，可以用%（取余），来得到多少位以内的数。	int count = 0;	int a = 0;	printf(&quot;我已经想好了一个1到100之间的整数。&quot;);	do&#123;		printf(&quot;请猜这个数:&quot;);		scanf(&quot;%d&quot;,&amp;a);		count ++;		if(a &gt; number)&#123;			printf(&quot;你猜的数大了&quot;);		&#125;else if(a &lt; number)&#123;			printf(&quot;你猜的数小了&quot;);		&#125;	&#125;while(a != number);	printf(&quot;太好了，你用了%d次就猜到了答案。\n&quot;,count);	return 0;&#125;

算平均数#include &lt;stdio.h&gt;int main()&#123;	int number;	int sum = 0;	int count =0;	scanf(&quot;%d&quot;,&amp;number);	while(number != -1)	&#123;		sum += number;		count++;		scanf(&quot;%d&quot;,&amp;number);	&#125;	printf(&quot;%f\n&quot;,1.0*sum/count);	return 0;&#125;

整数的分解
对一个整数做%10的操作，就得到了它的个位数；
对其做&#x2F;10的操作，就去掉了它的个位数；
然后再对2的结果做%10就得到了原来数的十位数。


下面给出一个整数逆序的代码

#include &lt;stdio.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	int digit;	int ret = 0;	while(x&gt;0)	&#123;		digit = x%10;		ret = ret*10 + digit;		x /= 10;		//可以给出调试结果		printf(&quot;x=%d,digit=%d,ret=%d\n&quot;,x,digit,ret);	&#125;	printf(&quot;%d&quot;,ret);	return 0;&#125;


那么注意，这样输出的是一个整数，如果想要输入700输出007可以做细微改动（实际上是更容易了）

//ret这个变量就不需要了。while(x&gt;0)&#123;	digit = x%10;	printf(&quot;%d&quot;,digit);	x /= 10;&#125;

阶乘#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int fact = 1;	int i =1;	while(i &lt;= n)	&#123;		fact *= i;		i++;	&#125;	printf(&quot;%d!=%d\n&quot;,n,fact);	return 0;&#125;


下面用for循环来写一下

for(i = 1;i &lt;= n;i++)&#123;	fact *= i;&#125;


还有一个小套路，在求积的时候变量初始化为1，求和时变量初始化为0。

判断是否为素数#include &lt;stdio.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	int i;	int is_prime = 1;	for(i = 2;i &lt; x;i++)	&#123;		if(x%i ==0)		&#123;			is_prime = 0;			break;		&#125;	&#125;	if(is_prime == 1)	//改为i&lt;x即可省去中间变量	&#123;		printf(&quot;是素数\n&quot;);	&#125;else&#123;		printf(&quot;不是素数\n&quot;);	&#125;	return 0;&#125;


那么实际上需要break来结束循环，会减少时间。还有一个循环控制语句continue，会跳过循环剩下的语句。

for(i=2;i&lt;x;i++)&#123;	if(x%i == 0)	&#123;		is_prime = 0;		continue;	&#125;	printf(&quot;%d\n&quot;,i);&#125;


给出流程图，作为对比![[Pasted image 20251009165244.png]]

循环的嵌套
下面要输出1到100之间的素数

#include &lt;stdio.h&gt;int main()&#123;	int x;	for(x = 2;x &lt; 100;x++)	&#123;		int is_prime = 1;		int i;		for(i = 2;i &lt; x;i++)			&#123;				if(x%i ==0)				&#123;					is_prime = 0;					break;				&#125;			&#125;			if(is_prime == 1)			&#123;				printf(&quot;%d &quot;,x);			&#125;	&#125;	return 0;&#125;


若int is_prime = 1;在for循环外面，代码只在程序开始时初始化了一次is_prime = 1，但在判断完一个数是否为质数后，没有重新将其重置为 1。这会导致一旦发现某个非质数后，is_prime就一直保持 0，后续的质数也无法被正确识别。那么想要输出前五十个素数只需要进行一下修改

#include &lt;stdio.h&gt;int main()&#123;	int x;	int cnt = 0;	for(x = 2;cnt &lt; 50;x++)	&#123;		int is_prime = 1;		int i;		for(i = 2;i &lt; x;i++)			&#123;				if(x%i ==0)				&#123;					is_prime = 0;					break;				&#125;			&#125;			if(is_prime == 1)			&#123;				printf(&quot;%d &quot;,x);				cnt++;			&#125;	&#125;	return 0;&#125;

接力breakint x;int one,two,five;int exit = 0;scanf(&quot;%d&quot;,&amp;x);for(one = 1;one &lt; x*10;one++)&#123;	for(two =1;two &lt; x*10/2;two++)	&#123;		for(five =1;five&lt;x*10/5;five++)		&#123;			if(one + two*2 +five*5 == x*10)			&#123;				printf(&quot;可以用%d个一角加%d个二角加%d个五角得到%d元\n&quot;,one,two,five,x);				exit = 1;				break;			&#125;		&#125;		if(exit)break;	&#125;	if(exit)break;//对于if来说（）内只要不为0就可以&#125;


还有一个更为方便的方法goto

for(one = 1;one &lt; x*10;one++)&#123;	for(two =1;two &lt; x*10/2;two++)	&#123;		for(five =1;five&lt;x*10/5;five++)		&#123;			if(one + two*2 +five*5 == x*10)			&#123;				printf(&quot;可以用%d个一角加%d个二角加%d个五角得到%d元\n&quot;,one,two,five,x);				exit = 1;				goto out;			&#125;		&#125;	&#125;&#125;out:


那么除了这种情况不建议使用goto

前n项求和int n;int i;double sum = 0.0;scanf(&quot;%d&quot;,&amp;n);for(i = 1;i&lt;=n;i++)&#123;	sum += 1.0/i;&#125;printf(&quot;f(%d)=%f&quot;,n,sum);


要实现加一个减一个，可以这样做

int n;int i;double sum = 0.0;double sgn = 1.0;scanf(&quot;%d&quot;,&amp;n);for(i = 1;i&lt;=n;i++)&#123;	sum += sgn/i;	sgn = -sgn;&#125;printf(&quot;f(%d)=%f&quot;,n,sum);

整数分解#include &lt;stdio.h&gt;//#include &lt;math.h&gt;int main()&#123;	int x;	scanf(&quot;%d&quot;,&amp;x);	//引入一个新的变量t，不改变x	int t = x;	int mask = 1;	//不用t&gt;0是因为，那样会多循环一次，mask会多一位，同时为了实现下面几行同样的效果还可以	//int cnt = 0;	//do&#123;	//	x /= 10;	//	cnt++;	//&#125;while(x &gt; 0);	//int mask = pow(10,cnt - 1);	while(t&gt;9)	&#123;		t /= 10;		mask *= 10;	&#125;	do&#123;		int d = x/mask;		printf(&quot;%d&quot;,d);		if(mask&gt;9)		&#123;			printf(&quot; &quot;);		&#125;		x %= mask;		mask /= 10;	&#125;while(mask &gt; 0);	printf(&quot;\n&quot;);	return 0;&#125;

最大公约数#include &lt;stdio.h&gt;int main()&#123;	int a,b;	scanf(&quot;%d %d&quot;,&amp;a,&amp;b);	int ret;	int i;	for(i = 1;i&lt;=a &amp;&amp; i &lt;= b;i++)	&#123;		if(a%i == 0 &amp;&amp; b%i == 0)		ret = i;	&#125;	printf(&quot;%d和%d的最大公约数是%d&quot;,a,b,ret);	return 0;&#125;

下来介绍辗转相除法
如果b等于0，计算结束，a就是最大公约数
否则，计算a除以b的余数，让a等于b，让b等于那个余数
回到第一步

#include &lt;stdio.h&gt;int main()&#123;	int a,b;	int t;	scanf(&quot;%d %d&quot;,&amp;a,&amp;b);	while( b!= 0)	&#123;		t = a%b;		a = b;		b = t;	&#125;	printf(&quot;gcd=%d&quot;,a);	return 0;&#125;

习题课水仙花数#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int first = 1;	int i;	 &#125;


九九乘法表#include &lt;stdio.h&gt;int main()&#123;	int n;	scanf(&quot;%d&quot;,&amp;n);	int i,j;	i = 1;	while(i&lt;=n)	&#123;		j = 1;		while(j &lt;= i)		&#123;			printf(&quot;%d*%d=%d&quot;,j,i,i*j);			if(i*j &lt; 9)			&#123;				printf(&quot;   &quot;);			&#125;else&#123;				printf(&quot;  &quot;);			&#125;			j++;		&#125;		printf(&quot;\n&quot;);		i++;	&#125;	return 0;	&#125;


可以用printf(&quot;%d*%d=%-4d&quot;,j,i,i*j);会更加简洁，且确保每个表达式占固定宽度。

数据类型
sizeof可以得到不同变量在内存中占用的字节的大小。
且sizeof是一个静态运算符，并不会实际运算里面的代码。

int a;a = 6;printf(&quot;sizeof(a++)=%ld\n&quot;,sizeof(a));print(&quot;sizeof(a+1.0)=%ld\n&quot;,sizeof(a + 1.0));

输出结果如下
sizeof(a++)=4sizeof(a+1.0)=8

原因在于变量a是一个int类型的变量，占4个字节+1.0后会变成一个浮点数，占8个字节

以下是C语言中常见数据类型在32位和64位系统中占用字节数的表格：



数据类型
32位系统
64位系统



char
1字节
1字节


short
2字节
2字节


int
4字节
4字节


long
4字节
8字节


long long
8字节
8字节


float
4字节
4字节


double
8字节
8字节


long double
10或16字节
16字节


指针
4字节
8字节


整数的内部表达
计算机内部一切都是二进制
18 00010010
0   00000000
-18


一个字节可以表达的数
0000000 -  11111111（255）
三种方案
仿照十进制，用一个特殊标志表示负数
取中间的数为0,1000000表示0，比他小的是负数，比他大的是正数
补码
-1 &#x3D; （1）00000000 - 00000001  -&gt; 11111111
在纯二进制时，11111111是255，在补码中是-1


char: -128~127
short: -32768~32767


要把该数（11111111）当做纯二进制数，需加unsigned也可以像255u这样字面量常数后加u或U

整数的输入输出
只有两种形式：int 或long long
%d  int
%u  unsigned
%ld long long
%lu unsigned long long


输入八进制在前面加上0，十六进制在前面加上0x
输出时%o和%x，但是这样不会输出前面的0和0x



浮点类型
float  和  double，但是这两个的范围![[Pasted image 20251013095853.png]]

输入输出


类型
scanf
printf



float
%f
%f,%e


double
%lf
%f,%e



输出用%e可以输出科学计数法的结果

1e-10,即1^(-10)
输出精度
在%和f之间加上.n是可以指定输出小数点后几位，这样的输出是做四舍五入的
在计算机里面是无法准确的表达一个数的

#include &lt;stdio.h&gt;int main()&#123;	printf(&quot;%.30f&quot;,0.0049);	return 0;&#125;

运行结果如下
0.004899999999999999841793218991

超过范围的浮点数
printf输出inf表示超过范围的浮点数：$\infty$
输出nan就表示不存在

浮点数的运算精度#include &lt;stdio.h&gt;int main()&#123;	float a,b,c;	a = 1.345;	b = 1.123;	c = a + b;	if(c == 2.468)	&#123;		printf(&quot;相等&quot;);	&#125;else	&#123;		printf(&quot;不相等！c=%.10f,或%f\n&quot;,c,c);	&#125;	return 0;&#125;
运行结果如下
不相等！c=2.4679999352,或2.468000


float需要用f或F后缀来表明身份，不加的话是double


f1 &#x3D;&#x3D; f2 可能失败
fabs（f1 - f2）&lt; 1e - 12(1e - 8一般就可以了)
fabs()是用来求绝对值的。



浮点数的内部表达![[Pasted image 20251013104911.png]]
字符类型
char是一种整数，也是字符
‘a’用单变量来表示，’ ‘也是一个字符
用%c来做输入输出
scanf(&quot;%c&quot;,&amp;c);—&gt; 1
scanf(&quot;%d&quot;,&amp;i);—&gt; 49
‘1’的ASCII编码是49，所以当c &#x3D;&#x3D; 49时，它代表’1’

逃逸字符


字符
意义
字符
意义



\b
回退一格
\“
双引号


\t
到下一个表格位
\‘
单引号


\n
换行
\\
反斜杠本身


\r
回车




类型转换自动类型转换
运算符两边出现不一致的类型时，会自动转换成较大的类型
大的意思是能表达的数的范围更大


char–&gt;short–&gt;int–&gt;long–&gt;long long
int–&gt;float–&gt;double
对于printf任何小于int的类型会被转换成int；float会转换成double但是scanf不会，要输入short，需要%hd



强制类型转换
（类型）值
比如
（int）2.0



逻辑类型bool
#include &lt;stdbool.h&gt;
之后就可以使用bool和true,false

逻辑运算
结果只有0和1




运算符
描述
示例



！
非
!a


&amp;&amp;
与
a &amp;&amp; b


||
或
a || b


条件运算符
count = (count&gt;20)?count-10:count+10;
相当于

if(count&gt;20)count -= 10;elsecount += 10;


逗号也是一个运算符需要注意的是，逗号运算符的优先级是 C 语言中最低的，因此在需要确保其运算顺序时，通常需要用括号括起来。

在for循环中，逗号运算符常用于初始化或更新多个变量，使代码更简洁：
for (int i = 0, j = 10; i &lt; j; i++, j--) &#123; 	printf(&quot;i=%d, j=%d\n&quot;, i, j); &#125;

函数函数的定义和使用void sum(int begin,int end)&#123;	int i;	int sum = 0;	for(i=begin;i&lt;=end;i++)	&#123;		sum += i;	&#125;	printf(&quot;%d到%d的和是%d\n&quot;,begin,end,sum);&#125;


返回类型 函数名（参数表）&#x2F;&#x2F;函数头{语句	}&#x2F;&#x2F;函数体


(起到了表示函数调用的作用，没有参数也需要，如果有参数则需要给出正确的数量和顺序)

从函数中返回值
return停止函数的执行，并送回一个值
return；
return 表达式；

函数先后关系
一般会把函数写在上面，一般而言C的编译器会自上而下的编译程序


C在调用函数的时候，永远只能传值给函数原因在于每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系

本地变量
函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量
定义在函数内部的变量和参数就是本地变量
定义在块内（就是大括号内）它的生存期只在块内
在不同的块内可以定义同名的变量

函数小知识没有参数时
void f(void)
void f()
在传统C中，它表示f函数的参数表未知，并不表示没有参数


因此一定要完整书写函数声明

逗号运算符
f(a,b)
f((a,b))
调用函数时的圆括号里的逗号是标点符号，不是运算符，但是加上括号就会先运算括号内的结果




C语言中不允许函数的嵌套定义

数组给一个情景引入，要输出一串数中大于这组数平均数的数
#include &lt;stdio.h&gt;int main(void)&#123;	int x;	double sum = 0;	int cnt = 0;	//定义数组	int number[100];	scanf(&quot;%d&quot;,&amp;x);	while(x!= -1)	&#123;	//对数组中的元素赋值		number[cnt] = x;		sum += x;		cnt++;		scanf(&quot;%d&quot;,&amp;x);	&#125;	if(cnt &gt; 0)	&#123;		int i;		double aver = sum/cnt;		for(i=0;i&lt;cnt;i++)		&#123;		//使用数组中的元素			if(number[i]&gt;aver)			&#123;				printf(&quot;%d&quot;,number[i]);			&#125;		&#125;	&#125;	return 0;&#125;

定义数组
&lt;类型&gt; 变量名称[元素数量]；
int grades[100];
double weight[20];


元素数量必须是整数
C99之前：元素数量必须是编译时刻确定的字面量

数组
是一种容器
其中所有的元素具有相同的数据类型；
一旦创建，不能改变大小
数组中的元素在内存中是连续依次排列的



数组的单元
使用数组时放在[ ]中的数字叫做下标或索引，从0开始计数

有效的下标范围
编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写
一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃
segmentation fault


但是也可能运气好，没有造成严重后果


下面给一个测试程序

#include&lt;stdio.h&gt;void f();int main()&#123;	f();	return 0;&#125;void f()&#123;	int a[10];	a[10] = 0;&#125;

经过运行，在VScode中没有报错。devcpp中也没有报错
数组的例子-统计个数
写一个程序，输入数量不确定的[0,9]范围内的整数，统计每一种数字出现的次数，输入-1表示结束。

#include &lt;stdio.h&gt;int main(void)&#123;	const int num = 10;	int x;	int cnt[num];	int i;	for(i=0;i&lt;num;i++)	&#123;		cnt[i] = 0;	&#125;	scanf(&quot;%d&quot;,&amp;x);	while(x != -1)	&#123;		if(x&gt;=0 &amp;&amp; x&lt;=9)		&#123;			cnt[x]++;		&#125;		scanf(&quot;%d&quot;,&amp;x);	&#125;	for(i = 0;i&lt;num;i++)	&#123;		printf(&quot;%d:%d\n&quot;,i,cnt[i]);	&#125;	return 0;&#125;

数组运算数组的集成初始化int a[] = &#123;2,4,5,6,7,8,9,11&#125;;


集成初始化时的定位int a[10] = { [0] = 2,[2] = 3,6,}用[n]在初始化数据中给出定位没有定位的数据接在前面的位置的后面其他位置的值补0也可以不给出数组大小特别适合初始数据稀疏的数组

数组的大小
sizeof给出整个数组所占据的内容的大小，单位是字节
sizeof(a)/sizeof(a[0])

数组的赋值
数组变量本身不能被赋值
要把一个数组的所有元素交给另一个数组，必须采用遍历

for(i=0;i&lt;length;i++)&#123;	b[i] = a[i];&#125;

遍历数组
***通常使用for循环，让循环变量i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标


***有一个常见错误，离开循环后，继续用i的值来做数组的下标


用数组作为函数参数时，往往必须再用另一个参数来传入数组的大小
而且不能在[]中给出数组的大小
不能再利用sizeof来计算数组的元素个数

数组例子从判断素数讲起
最原始的int is_prime(int x)&#123;	int ret = 1;	int i;	if(x == 1||(x%2 == 0 &amp;&amp; x != 2))	&#123;		ret = 0;	&#125;	for(i=3;i&lt;x;i++)&#123;		if(x%i == 0)&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;

时间复杂度O(n)

优化后的#include &lt;math.h&gt;int is_prime(int x)&#123;	int ret = 1;	int i;	if(x == 1||(x%2 == 0 &amp;&amp; x != 2))	&#123;		ret = 0;	&#125;	for(i=3;i&lt;sqrt(x);i++)&#123;		if(x%i == 0)&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;

时间复杂度O($\sqrt{n}$)

使用数组#include &lt;stdio.h&gt;#define number 100int is_prime(int x,int knownPrimes[],int number0fknownPrimes)&#123;	int ret = 1;	int i;	for(i=0;i&lt;number0fknownPrimes;i++)	&#123;		if(x%knownPrimes[i]==0)		&#123;			ret = 0;			break;		&#125;	&#125;	return ret;&#125;int main(void)&#123;	int prime[number] = &#123;2&#125;;	int cnt =1;	int i = 3;	while(cnt&lt;number)	&#123;		if(is_prime(i,prime,cnt))		&#123;			prime[cnt++] = i;			&#125;		i++;	&#125;	for(i=0;i&lt;number;i++)	&#123;		printf(&quot;%d&quot;,prime[i]);		if((i+1)%5) printf(&quot;\t&quot;);		else printf(&quot;\n&quot;);	&#125;	return 0;&#125;

运行结果如下
2       3       5       7       1113      17      19      23      2931      37      41      43      4753      59      61      67      7173      79      83      89      97101     103     107     109     113127     131     137     139     149151     157     163     167     173179     181     191     193     197199     211     223     227     229233     239     241     251     257263     269     271     277     281283     293     307     311     313317     331     337     347     349353     359     367     373     379383     389     397     401     409419     421     431     433     439443     449     457     461     463467     479     487     491     499503     509     521     523     541

构造素数表
预构造n以内的素数表
令x为2
将2x，3x，4x，直到ax&lt;n的数标记为非素数
令x为下一个没有被标记为非素数的数，重复2；直到所有的数都已经尝试完毕



埃拉托斯特尼筛法（Sieve of Eratosthenes）：构造n以内的素数表你描述的方法是埃拉托斯特尼筛法——高效构造“n以内所有素数”的经典算法，核心思想是“通过标记每个素数的倍数来排除合数”，时间复杂度（$O(n \log \log n)$）远低于“逐个判断素数”的方法（$O(n\sqrt{n})$）。以下是算法逻辑拆解、完整代码实现及关键细节解析。
一、算法核心逻辑（对应你的步骤）你的描述已覆盖筛法本质，补充细节后更便于代码实现：

初始化“筛子”创建长度为n+1的“标记数组”（如is_prime[]），用于标记每个数是否为素数：

初始默认所有数为素数（标记为1或true）；
特殊处理：0和1不是素数，提前标记为非素数（0或false）。


筛选合数（对应你的步骤2）  

从第一个素数x=2开始；
标记x的所有倍数（2x, 3x, 4x, ...）为非素数，但从x*x开始标记更高效（原因：2x~(x-1)x已被更小的素数标记过，无需重复处理）。


迭代筛选（对应你的步骤3）  

让x指向“下一个未被标记为非素数的数”（即下一个素数）；
重复步骤2，直到x*x &gt; n（此时所有合数已被比x小的素数标记，无需继续）。


提取结果遍历标记数组，所有仍标记为1的索引（即数本身），就是n以内的所有素数。


二、完整代码实现（以“构造100以内素数表”为例）用C语言实现筛法，包含“初始化→筛选→输出”全流程，关键步骤添加注释：
#include &lt;stdio.h&gt;#include &lt;string.h&gt;  // 用于memset函数（快速初始化数组）/** * @brief 用埃拉托斯特尼筛法构造max_num以内的素数表并输出 * @param max_num 素数表的上限（即构造“0~max_num”范围内的素数） */void sieve_of_eratosthenes(int max_num) &#123;    // 1. 初始化标记数组：is_prime[i] = 1 表示i是素数，0表示合数    int is_prime[max_num + 1];  // 数组索引覆盖0~max_num（共max_num+1个元素）        // 快速初始化：用memset将所有元素设为1（默认是素数）    // memset按字节赋值，int占4字节时，1的二进制为0x00000001，赋值后每个int元素为1    memset(is_prime, 1, sizeof(is_prime));        // 特殊处理：0和1不是素数，标记为0    is_prime[0] = 0;    is_prime[1] = 0;    // 2. 核心筛选逻辑：x从2开始，直到x*x &gt; max_num（所有合数已被标记）    for (int x = 2; x * x &lt;= max_num; x++) &#123;        // 若x未被标记为合数（即x是素数），则标记其倍数为合数        if (is_prime[x] == 1) &#123;            // 优化：从x*x开始标记（避免重复标记2x~(x-1)x）            for (int multiple = x * x; multiple &lt;= max_num; multiple += x) &#123;                is_prime[multiple] = 0;  // 标记x的倍数为合数            &#125;        &#125;    &#125;    // 3. 输出max_num以内的所有素数（每5个换一行，格式清晰）    printf(&quot;%d以内的素数表：\n&quot;, max_num);    int count = 0;  // 计数，控制每5个素数换行    for (int i = 0; i &lt;= max_num; i++) &#123;        if (is_prime[i] == 1) &#123;  // 若i是素数，输出            printf(&quot;%d\t&quot;, i);            count++;            if (count % 5 == 0) &#123;  // 每5个素数换一行                printf(&quot;\n&quot;);            &#125;        &#125;    &#125;    printf(&quot;\n&quot;);&#125;int main(void) &#123;    int n = 100;  // 目标：构造100以内的素数表（可修改为任意正整数）    sieve_of_eratosthenes(n);  // 调用筛法函数    return 0;&#125;


三、代码关键细节解释1. 标记数组初始化：memset的使用
作用：快速将is_prime数组所有元素设为1，比for循环初始化更高效（memset是C标准库的内存操作函数，直接操作字节，速度更快）。
注意：memset按“字节”赋值，若int占4字节（大部分编译器），1的十六进制为0x00000001，因此赋值后每个int元素恰好为1，符合“默认是素数”的需求。

2. 筛选终止条件：x * x &lt;= max_num
为什么不写x &lt;= max_num？数学原理：若max_num有一个合数m，其最小质因数一定≤$\sqrt{m}$。当x &gt; \sqrt{max_num}时，m的最小质因数已在x ≤ \sqrt{max_num}时被处理，m早已被标记为合数，无需继续遍历。示例：max_num=100，$\sqrt{100}&#x3D;10$，当x=11时，11*11=121&gt;100，直接终止循环即可。

3. 倍数标记起点：x * x（而非2x）
优化逻辑：避免重复标记已处理的合数。示例：x=5时，2x=10（已被x=2标记）、3x=15（已被x=3标记），从x*x=25开始标记，仅需处理25, 30, 35, ..., 100，减少无效操作。

四、运行结果（100以内素数表）编译运行后，输出格式如下（每5个素数一行，便于阅读）：
100以内的素数表：2       3       5       7       1113      17      19      23      2931      37      41      43      4753      59      61      67      7173      79      83      89      97


五、扩展：筛法的适用场景与优化1. 适用场景埃拉托斯特尼筛法适合**“预构造较大范围（如10⁶以内）的素数表”**，例如：

数学题中频繁判断“某数是否为素数”；
密码学、数论相关场景中需要批量素数。

2. 针对超大n的优化（减少内存占用）若需构造10⁸以上的素数表，普通int数组会占用过多内存（如10⁸个int需400MB），可通过以下方式优化：

位数组（bit array）：每个数用1个二进制位标记（而非4字节的int），内存占用仅为原来的1&#x2F;32；
分段筛法（Segmented Sieve）：将大区间（如1~10⁹）分成多个小区间（如1~10⁴、10⁴+1~2×10⁴），逐个筛选，避免一次性占用大量内存。

六、使用说明若需调整素数表的范围，只需修改main函数中n的值（如n=200或n=1000），函数会自动生成对应范围的素数表，灵活性极高。
二维数组
int a[3][5];
通常理解为a是一个3行5列的矩阵
![[Pasted image 20251026171423.png]]

二维数组的遍历for(i=0;i&lt;3;i++)&#123;	for(j=0;j&lt;5;j++)&#123;		a[i][j] = i*j;	&#125;&#125;


a[i][j]是一个int
a[i,j]就等于a[j]
原因在于i,j是一个表达式，取j





二维数组的初始化int a[][5] = &#123;	&#123;0,1,2,3,4&#125;,	&#123;2,3,4,5,6&#125;,&#125;;


列数必须给出
每行一个{}，逗号分隔
最后的逗号可以存在
如果省略，表示补零
也可以用定位

读入矩阵
 3x3 井字棋（ Tic-Tac-Toe ）的获胜检查逻辑

const int size = 3;int board[size][size];int i,j;int numOfX;int numOfO;int result = -1;//-1:没人赢；1:X赢;0:O赢//读入矩阵for(i=0;i&lt;size;i++)&#123;	for(j=0;j&lt;size;j++)&#123;		scanf(&quot;%d&quot;,&amp;board[i][j]);	&#125;&#125;//检查行for(i=0;i&lt;size &amp;&amp; result ==-1;i++)&#123;	numOfO = numOfX = 0;	for(j=0;j&lt;size;j++)&#123;		if(board[i][j] == 1)&#123;			numOfX ++;		&#125;else&#123;			numOfO ++;		&#125;	&#125;	if(numOfO == size)&#123;		result = 0;	&#125;else if(numOfX == size)&#123;		result = 1;	&#125;&#125;//检查列if(result == -1)&#123;	for(j=0;j&lt;size &amp;&amp; result == -1;j++)&#123;		numOfO = numOfX = 0;		for(i=0;i&lt;size;i++)&#123;			if(board[i][j] == 1)&#123;				numOfX ++;			&#125;else&#123;				numOfO ++;			&#125;		&#125;		if(numOfO == size)&#123;			result = 0;		&#125;else if(numOfX == size)&#123;			result = 1;		&#125;	&#125;&#125;// 检查对角线（主对角线 + 副对角线）if(result == -1)&#123; // 仅当之前未检测到获胜者时才检查    // 1. 检查主对角线（左上 → 右下：i == j，如 (0,0)、(1,1)、(2,2)）    numOfO = numOfX = 0; // 重置计数    for(i = 0; i &lt; size; i++)&#123;        if(board[i][i] == 1)&#123; // 当前位置是X（用1表示）            numOfX++;        &#125; else &#123; // 当前位置是O（用非1表示，如0）            numOfO++;        &#125;    &#125;    // 判断主对角线是否获胜    if(numOfO == size)&#123;        result = 0; // O赢    &#125; else if(numOfX == size)&#123;        result = 1; // X赢    &#125;    // 2. 检查副对角线（右上 → 左下：i + j == size-1，如 (0,2)、(1,1)、(2,0)）    if(result == -1)&#123; // 主对角线未分胜负时，再检查副对角线        numOfO = numOfX = 0; // 重置计数        for(i = 0; i &lt; size; i++)&#123;            // 副对角线列号 = size-1 - 行号（如i=0时j=2，i=1时j=1，i=2时j=0）            if(board[i][size - 1 - i] == 1)&#123;                numOfX++;            &#125; else &#123;                numOfO++;            &#125;        &#125;        // 判断副对角线是否获胜        if(numOfO == size)&#123;            result = 0; // O赢        &#125; else if(numOfX == size)&#123;            numOfX = size;            result = 1; // X赢        &#125;    &#125;&#125;// （可选）输出结果，验证逻辑正确性if(result == 1)&#123;    printf(&quot;X赢\n&quot;);&#125; else if(result == 0)&#123;    printf(&quot;O赢\n&quot;);&#125; else &#123;    printf(&quot;没人赢\n&quot;);&#125;

取地址运算
运算符&amp;
scanf(&quot;%d&quot;,&amp;i)里的&amp;
获取变量的地址，它的操作数必须是变量
int i;printf(&quot;0x%x\n&quot;,&amp;i);
这样输出实际上会得到i的地址



#include &lt;stdio.h&gt;int main(void)&#123;	int i = 0;	int p;	p = (int)&amp;i;	printf(&quot;0x%x\n&quot;,p);	printf(&quot;%p\n&quot;,&amp;i);		return 0;&#125;

运行结果如下
0x5ffe7800000000005ffe78


&amp;不能对没有地址的东西取地址&amp;(a+b)

下来试一试数组
#include &lt;stdio.h&gt;int main(void)&#123;	int a[10];	printf(&quot;%p\n&quot;,&amp;a);	printf(&quot;%p\n&quot;,a);	printf(&quot;%p\n&quot;,&amp;a[0]);	printf(&quot;%p\n&quot;,&amp;a[1]);	return 0;&#125;

运行结果如下
00000000005ffe5000000000005ffe5000000000005ffe5000000000005ffe54

指针
就是保存地址的变量int i;int* p = &amp;i;int* p,q;int *p,q;

三四行表示的是一个意思*p是一个指针，而q是一个int


void f(int *p);

在被调用的时候得到了某个变量的地址
int i=0;f(&amp;i);


在函数里面可以通过这个指针访问外面的这个i

*是一个单目运算符，用来访问指针的值所表示的地址上的变量

可以做右值也可以做左值

int k = *p;
*p = k+1;



int i = 6;int *p = &amp;i;printf(&quot;p=%d\n&quot;,p);printf(&quot;*p=%d\n&quot;,*p);

运行结果如下
p=6291060*p=6

那么再看
*p = 26;printf(&quot;%d\n&quot;,i);

结果如下
i=26

传入地址
int i;scanf(&quot;%d&quot;,i)没有报错
原因在于传入地址和传入一个整数是一样大的，这样的话，读进来的数没有被写到i那里，而是一个别的地方

指针应用场景交换两个变量的值#include &lt;stdio.h&gt;void swap(int *pa,int *pb);int main(void)&#123;	int a = 5;	int b = 6;	swap(&amp;a,&amp;b);	printf(&quot;a=%d,b=%d&quot;,a,b);	return 0;&#125;void swap(int *pa,int *pb)&#123;	int t = *pa;	*pa = *pb;	*pb = t;&#125;

#include&lt;stdio.h&gt;void maxmin(int a[],int len,int *max,int *min);int main(void)&#123;    int a[] = 1,2,3,4,5,6,7,8,9,12,13,14,15,16,17,21,23,55,&#125;;    int min,max;    maxmin(a,sizeof(a)/sizeof(a[0]),&amp;max,&amp;min);    printf(&quot;max=%d,min=%d\n&quot;,max,min);    return 0;&#125;void maxmin(int a[],int len,int *max,int *min)&#123;    int i;    *max = *min = a[0];    for(i=0;i&lt;len;i++)&#123;        if(a[i]&lt;*min)&#123;            *min = a[i];        &#125;        if(a[i]&gt;*max)&#123;            *max = a[i];        &#125;    &#125;&#125;


要输出的值不止一个，就用指针变量，让函数把对应的值填入对应的地址

应用场景二
函数返回运算的状态，结果通过指针返回
常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错
-1或0（在文件操作有很多例子）


但是当任何数值都是有效的可能结果是，就得分开返回了
后续的语言（C++，Java）采用了异常机制来解决这个问题



#include&lt;stdio.h&gt;int divide(int a,int b,int *result);int main(void)&#123;    int a = 5;    int b = 2;    int c;    if(divide(a,b,&amp;c))&#123;        printf(&quot;%d/%d=%d\n&quot;,a,b,c);    &#125;    return 0;&#125;int divide(int a,int b,int *result)&#123;    int ret = 1;    if(b == 0)&#123;        ret = 0;    &#125;else&#123;        *result = a/b;    &#125;    return ret;&#125;

没有得到实际地址之前，不可以用指针访问任何数据
指针与数组
函数参数部分的数组实际上传入的是指针
sizeof(a) == sizeof(int*)
但是可以用数组的运算符[]进行运算



数组变量是特殊的指针

数组变量本身表达地址
int a[10];int *p = a;&#x2F;&#x2F;无需用&amp;取地址
但是数组的单元表达的是变量，需要用&amp;取地址
a == &amp;a[0]


[]运算符可以对数组做，也可以对指针做
p[0]&lt;==&gt;a[0]


*运算符可以对指针做，也可以对数组做
*a = 24;


数组变量是const的指针，所以不能被赋值
int b[] --&gt; int * const b;



指针与const指针是const
表示一旦得到了某个变量的地址，不能指向其他变量
int * const q = &amp;i;
*q = 26&#x2F;&#x2F;OK
q++&#x2F;&#x2F;ERROR



所指是const
表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）
const int *p = &amp;i;
*p = 26;&#x2F;&#x2F;ERROR!*p是const



转换
总是可以把一个非const的值转换成const的

void f(const int *x);int a = 15;f(&amp;a);//okconst int b = a;f(&amp;b);//okb = a + 1;//Error

const数组
const int a[] = {1,2,3,3,4,5};
数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int
所以必须通过初始化进行赋值

保护数组值
为了保证数组不被函数破坏，可以设置参数为const
int sum(const int a[],int len);



数组运算 给个例子 #include &lt;stdio.h&gt;int main(void)&#123; char ac[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; char *p = ac; printf(&quot;p=%p\n&quot;,p); printf(&quot;p+1=%p\n&quot;,p+1); int ai[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int *q = ai; printf(&quot;q=%p\n&quot;,q); printf(&quot;q+1=%p\n&quot;,q+1);  return 0;&#125;
运行结果如下
p=00000000005ffe66p+1=00000000005ffe67q=00000000005ffe30q+1=00000000005ffe34


由此可见，给指针加1并不是给地址值加一，而是给地址值加一个sizeof(type),如果指针是char就加一，是int就加4


给指针加一实际上是指向下一个变量
+ += - -= ++ --都可以
两个指针也可以相减



#include &lt;stdio.h&gt;int main(void)&#123; char ac[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; char *p = ac; char *p1 = &amp;ac[5]; printf(&quot;p=%p\n&quot;,p); printf(&quot;p+1=%p\n&quot;,p+1); printf(&quot;p1-p=%d\n&quot;,p1-p); int ai[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; int *q = ai; int *q1 = &amp;ai[6]; printf(&quot;q=%p\n&quot;,q); printf(&quot;q+1=%p\n&quot;,q+1); printf(&quot;q1-q=%d\n&quot;,q1-q);  return 0;&#125;

运行结果如下
p=00000000005ffe56p+1=00000000005ffe57p1-p=5q=00000000005ffe20q+1=00000000005ffe24q1-q=6

显然两个指针的差是两个地址值之差除以sizeof得到的结果
*p++
去除p所指的那个数据，完事之后顺便把p移到下一个位置去
*的优先级虽然高，但是没有++高
常用语数组类的连续空间操作
在某些CPU上，这可以直接被翻译成一条汇编指令

指针比较
&lt; &lt;= == &gt; &gt;= !=都可以对指针做
比较它们在内存中的地址
数组中的单元的地址肯定是线性递增的

0地址
内存中有0地址，但通常是不能随便碰的地址
指针不应该具有0值
可以用0地址来表示特殊的事情
返回的指针是无效的
指针没有被真正初始化（先初始化为0）


NULL是一个预定定义的符号，表示0地址

指针的类型转换
void*表示不知道指向什么东西的指针
计算时与char*相同（但不相通）


int *p = &amp;i;void*q = (void*)p;
这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量

动态内存分配输入数据
int *a = (int*)malloc(n*sizeof(int));

#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;	int num;	int *a;	int i;	printf(&quot;请输入数量：&quot;);	scanf(&quot;%d&quot;,&amp;num);	a = (int*)malloc(num*sizeof(int));	for(i=0;i&lt;num;i++)&#123;		scanf(&quot;%d&quot;,&amp;a[i]);	&#125;	for(i=num-1;i&gt;=0;i--)&#123;		printf(&quot;%d&quot;,a[i]);	&#125;	free(a);//要还给malloc这个空间		return 0;&#125;

这样就在C99之前实现了变长数组如果申请失败则返回0，或者NULL试一下
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123;	void *p;	int cnt = 0;	while((p=malloc(100*1024*1024)))&#123;		cnt++;	&#125;	printf(&quot;分配了%d00MB的空间\n&quot;,cnt);		return 0;&#125;

分配了44100MB的空间

常见问题

申请了没free –&gt;长时间运行内存逐渐下降
新手：忘了
老手：找不到合适的free时机


free过了再free
地址变过了，直接free

递归
如果函数调用他本身，那么就是递归（recursive）

int fact(int n)&#123;	if(n&lt;=1)&#123;		return 1;	&#125;else&#123;		return n*fact(n-1);	&#125;&#125;


以上程序实现了n的阶乘

快速排序算法给出分治法(divide-and-conquer)的经典示例快速排序算法(quicksort)
]]></content>
  </entry>
  <entry>
    <title>翁恺C语言学习笔记</title>
    <url>/2026/01/24/%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E8%BF%91%E4%BA%94%E5%B9%B4%E5%BE%AE%E7%A7%AF%E5%88%86I-1%E7%A7%8B%E6%9C%9F%E6%9C%AB%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[四川大学微积分（I）-1 五年考点分布与题型统计（2020-2024）一、统计概述基于2020-2021至2024-2025学年共5套四川大学微积分（I）-1期末A卷，统计维度包括题型结构、考点分类及频次、分值占比，覆盖所有试题的核心考查内容，为后续可视化和备考提供数据支撑。![[Figure_calculus_statics.png]]
二、题型结构统计1. 题型分类及分值占比


题型
出现年份
单题分值范围
每套卷总分值占比
核心功能



填空题
2020-2023（4套）
3分&#x2F;题
15%（5题×3分）
基础概念与简单计算，覆盖广


计算题
2020-2024（5套）
5-8分&#x2F;题
25%-48%
核心运算能力，含极限、积分等


解答题
2020-2024（5套）
8-10分&#x2F;题
20%-40%
综合应用，含分段函数、隐函数等


应用题
2020-2024（5套）
9-12分&#x2F;题
18%-22%
实际场景转化，含几何、物理应用


证明题
2020-2024（5套）
6-8分&#x2F;题
13%-15%
逻辑推理，含不等式、存在性证明


2. 题型变化趋势
2020-2023年固定包含“填空题”，2024年取消，改为增加“计算题”数量；
应用题和证明题每年必考，分值占比稳定在30%-37%，是高分关键；
解答题分值逐年提高，从2020年20%升至2024年40%，强调综合能力。

三、考点分布统计（按频次+分值权重）1. 核心考点分类及频次（五年累计）


考点大类
具体考点
出现频次
分值权重（%）
对应题型



极限与连续性
函数极限（含数列极限）
12次
18.5
填空题、计算题



连续性与可导性判断
8次
10.2
解答题、计算题



无穷小量阶的判断
5次
6.3
计算题、解答题


导数与微分
高阶导数（含莱布尼茨公式）
9次
12.1
填空题、计算题



隐函数&#x2F;参数方程求导
7次
8.7
解答题、应用题



反函数求导
2次
2.1
填空题


积分学
不定积分（含分部、换元）
13次
19.8
所有题型均涉及



定积分（含对称区间积分）
11次
15.3
计算题、解答题



广义积分
4次
4.5
填空题、计算题



变限积分求导
6次
7.9
解答题、证明题


微分方程
一阶线性微分方程
6次
8.2
计算题、解答题



二阶线性非齐次微分方程
4次
5.7
解答题


几何应用
曲线渐近线
5次
4.8
填空题、计算题



旋转体体积
7次
9.3
应用题



弧长计算
2次
2.4
计算题



平面方程&#x2F;直线方程
2次
2.0
应用题


综合证明
积分不等式证明
6次
7.5
证明题



中值定理应用（含存在性证明）
5次
6.8
证明题


其他
分段函数综合运算
8次
9.6
解答题、应用题



函数单调性与极值
5次
5.1
解答题


2. 考点热度排序（Top10）
不定积分（13次，19.8%）→ 每年必考，覆盖所有题型；
函数极限（12次，18.5%）→ 基础核心，占比最高；
定积分（11次，15.3%）→ 含对称区间、变限积分等变体；
高阶导数（9次，12.1%）→ 重点考查莱布尼茨公式应用；
连续性与可导性（8次，10.2%）→ 分段函数为主要载体；
旋转体体积（7次，9.3%）→ 应用题高频考点；
隐函数&#x2F;参数方程求导（7次，8.7%）→ 解答题核心；
一阶线性微分方程（6次，8.2%）→ 计算题必考；
积分不等式证明（6次，7.5%）→ 证明题主力；
变限积分求导（6次，7.9%）→ 综合题常用工具。

四、可视化程序（Python）1. 代码功能
生成“考点频次柱状图”“题型分值占比饼图”“考点年度分布热力图”；
数据基于上述统计结果，可直接运行生成可视化文件。

2. 完整代码import matplotlib.pyplot as pltimport numpy as npimport pandas as pdfrom matplotlib import rcParams# 设置中文字体rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]  # 黑体rcParams[&#x27;axes.unicode_minus&#x27;] = False# 1. 数据准备# 考点频次数据subjects = [&#x27;不定积分&#x27;, &#x27;函数极限&#x27;, &#x27;定积分&#x27;, &#x27;高阶导数&#x27;, &#x27;连续与可导&#x27;,             &#x27;旋转体体积&#x27;, &#x27;隐函数求导&#x27;, &#x27;一阶微分方程&#x27;, &#x27;积分不等式&#x27;, &#x27;变限积分&#x27;]frequencies = [13, 12, 11, 9, 8, 7, 7, 6, 6, 6]weights = [19.8, 18.5, 15.3, 12.1, 10.2, 9.3, 8.7, 8.2, 7.5, 7.9]# 题型分值占比数据（以2024年为例）question_types = [&#x27;计算题&#x27;, &#x27;解答题&#x27;, &#x27;应用题&#x27;, &#x27;证明题&#x27;]type_scores = [30, 40, 18, 12]colors1 = [&#x27;#FF6B6B&#x27;, &#x27;#4ECDC4&#x27;, &#x27;#45B7D1&#x27;, &#x27;#96CEB4&#x27;]# 考点年度分布数据（频次）years = [&#x27;2020&#x27;, &#x27;2021&#x27;, &#x27;2022&#x27;, &#x27;2023&#x27;, &#x27;2024&#x27;]subject_year_data = &#123;    &#x27;不定积分&#x27;: [3, 2, 3, 2, 3],    &#x27;函数极限&#x27;: [2, 3, 2, 2, 3],    &#x27;定积分&#x27;: [2, 2, 3, 2, 2],    &#x27;高阶导数&#x27;: [2, 1, 2, 2, 2],    &#x27;连续与可导&#x27;: [1, 2, 2, 2, 1]&#125;# 2. 创建画布与子图fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))fig.suptitle(&#x27;四川大学微积分（I）-1 五年考点与题型统计（2020-2024）&#x27;, fontsize=16, fontweight=&#x27;bold&#x27;)# 3. 子图1：考点频次柱状图bars1 = ax1.bar(subjects, frequencies, color=&#x27;#FF6B6B&#x27;, alpha=0.7, edgecolor=&#x27;black&#x27;)ax1.set_title(&#x27;核心考点出现频次（五年累计）&#x27;, fontsize=12, fontweight=&#x27;bold&#x27;)ax1.set_xlabel(&#x27;考点名称&#x27;)ax1.set_ylabel(&#x27;出现频次&#x27;)ax1.tick_params(axis=&#x27;x&#x27;, rotation=45)# 添加数值标签for bar in bars1:    height = bar.get_height()    ax1.text(bar.get_x() + bar.get_width()/2., height + 0.1,             f&#x27;&#123;int(height)&#125;&#x27;, ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;)# 4. 子图2：题型分值占比饼图wedges, texts, autotexts = ax2.pie(type_scores, labels=question_types, colors=colors1,                                   autopct=&#x27;%1.1f%%&#x27;, startangle=90)ax2.set_title(&#x27;2024年题型分值占比&#x27;, fontsize=12, fontweight=&#x27;bold&#x27;)# 美化饼图文字for autotext in autotexts:    autotext.set_color(&#x27;white&#x27;)    autotext.set_fontweight(&#x27;bold&#x27;)# 5. 子图3：考点分值权重折线图ax3.plot(subjects, weights, marker=&#x27;o&#x27;, linewidth=2.5, color=&#x27;#45B7D1&#x27;, markersize=6)ax3.set_title(&#x27;核心考点分值权重&#x27;, fontsize=12, fontweight=&#x27;bold&#x27;)ax3.set_xlabel(&#x27;考点名称&#x27;)ax3.set_ylabel(&#x27;分值权重（%）&#x27;)ax3.tick_params(axis=&#x27;x&#x27;, rotation=45)ax3.grid(True, alpha=0.3)# 添加数值标签for x, y in zip(subjects, weights):    ax3.text(subjects.index(x), y + 0.3, f&#x27;&#123;y:.1f&#125;&#x27;, ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;, fontsize=9)# 6. 子图4：考点年度分布热力图df_year = pd.DataFrame(subject_year_data, index=years)im = ax4.imshow(df_year.values, cmap=&#x27;YlOrRd&#x27;, aspect=&#x27;auto&#x27;)ax4.set_title(&#x27;核心考点年度出现频次热力图&#x27;, fontsize=12, fontweight=&#x27;bold&#x27;)ax4.set_xlabel(&#x27;考点名称&#x27;)ax4.set_ylabel(&#x27;年份&#x27;)ax4.set_xticks(range(len(subject_year_data.keys())))ax4.set_xticklabels(subject_year_data.keys(), rotation=45)ax4.set_yticks(range(len(years)))ax4.set_yticklabels(years)# 添加数值标签for i in range(len(years)):    for j in range(len(subject_year_data.keys())):        text = ax4.text(j, i, df_year.values[i, j], ha=&#x27;center&#x27;, va=&#x27;center&#x27;,                       color=&#x27;black&#x27; if df_year.values[i, j] &lt; 3 else &#x27;white&#x27;, fontweight=&#x27;bold&#x27;)# 添加颜色条cbar = plt.colorbar(im, ax=ax4, shrink=0.8)cbar.set_label(&#x27;出现频次&#x27;, rotation=270, labelpad=15)# 调整布局plt.tight_layout()# 保存图片（高清格式）plt.savefig(&#x27;微积分考点题型统计.png&#x27;, dpi=300, bbox_inches=&#x27;tight&#x27;)plt.show()print(&quot;可视化图表已保存为：微积分考点题型统计.png&quot;)

3. 运行说明
依赖库：matplotlib、numpy、pandas，需提前安装（pip install matplotlib numpy pandas）；
输出文件：生成高清PNG图片，包含4个子图，覆盖频次、分值、年度分布；
可修改subject_year_data、type_scores等变量适配自定义统计需求。

四、核心结论
必考考点：不定积分、函数极限、定积分、旋转体体积、高阶导数，五年覆盖率100%，需重点突破；
高分重点：应用题（几何应用）和证明题（积分不等式）分值占比高，且难度逐年提升；
趋势预测：2025年大概率延续“计算题+解答题+应用题+证明题”结构，重点考查综合应用和逻辑推理能力。

]]></content>
  </entry>
</search>
